import type {
  Tower,
  Enemy,
  Hero,
  Troop,
  Projectile,
  Effect,
  Particle,
  DraggingTower,
  Position,
} from "../types";
import {
  TILE_SIZE,
  TOWER_DATA,
  ENEMY_DATA,
  HERO_DATA,
  MAP_PATHS,
  TOWER_COLORS,
  TROOP_DATA,
} from "../constants";
import { TOWER_STATS } from "../constants/towerStats";
import {
  gridToWorld,
  worldToScreen,
  getEnemyPosition,
  distance,
  isValidBuildPosition,
  lightenColor,
  darkenColor,
} from "../utils";

// ============================================================================
// ISOMETRIC BOX HELPER - Complete 4-wall rendering
// ============================================================================
function drawIsometricPrism(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  width: number,
  depth: number,
  height: number,
  colors: {
    top: string;
    left: string;
    right: string;
    leftBack?: string;
    rightBack?: string;
  },
  zoom: number = 1
) {
  const w = width * zoom * 0.5;
  const d = depth * zoom * 0.25;
  const h = height * zoom;

  // Calculate vertices for isometric box
  const topCenter = { x, y: y - h };
  const topFront = { x, y: y - h + d };
  const topBack = { x, y: y - h - d };
  const topLeft = { x: x - w, y: y - h };
  const topRight = { x: x + w, y: y - h };
  const bottomFront = { x, y: y + d };
  const bottomBack = { x, y: y - d };
  const bottomLeft = { x: x - w, y };
  const bottomRight = { x: x + w, y };

  // Draw back faces first
  ctx.fillStyle = colors.leftBack || darkenColor(colors.left, -20);
  ctx.beginPath();
  ctx.moveTo(topBack.x, topBack.y);
  ctx.lineTo(topLeft.x, topLeft.y);
  ctx.lineTo(bottomLeft.x, bottomLeft.y);
  ctx.lineTo(bottomBack.x, bottomBack.y);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "rgba(0,0,0,0.2)";
  ctx.lineWidth = 1;
  ctx.stroke();

  ctx.fillStyle = colors.rightBack || darkenColor(colors.right, -20);
  ctx.beginPath();
  ctx.moveTo(topBack.x, topBack.y);
  ctx.lineTo(topRight.x, topRight.y);
  ctx.lineTo(bottomRight.x, bottomRight.y);
  ctx.lineTo(bottomBack.x, bottomBack.y);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "rgba(0,0,0,0.2)";
  ctx.lineWidth = 1;
  ctx.stroke();

  // Front-left wall
  ctx.fillStyle = colors.left;
  ctx.beginPath();
  ctx.moveTo(topLeft.x, topLeft.y);
  ctx.lineTo(topFront.x, topFront.y);
  ctx.lineTo(bottomFront.x, bottomFront.y);
  ctx.lineTo(bottomLeft.x, bottomLeft.y);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "rgba(0,0,0,0.4)";
  ctx.lineWidth = 1;
  ctx.stroke();

  // Front-right wall
  ctx.fillStyle = colors.right;
  ctx.beginPath();
  ctx.moveTo(topRight.x, topRight.y);
  ctx.lineTo(topFront.x, topFront.y);
  ctx.lineTo(bottomFront.x, bottomFront.y);
  ctx.lineTo(bottomRight.x, bottomRight.y);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "rgba(0,0,0,0.3)";
  ctx.lineWidth = 1;
  ctx.stroke();

  // Top face
  ctx.fillStyle = colors.top;
  ctx.beginPath();
  ctx.moveTo(topBack.x, topBack.y);
  ctx.lineTo(topLeft.x, topLeft.y);
  ctx.lineTo(topFront.x, topFront.y);
  ctx.lineTo(topRight.x, topRight.y);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "rgba(0,0,0,0.2)";
  ctx.lineWidth = 1;
  ctx.stroke();
}

// ============================================================================
// ENHANCED MECHANICAL HELPER FUNCTIONS - Moving parts, gears, steam, etc.
// ============================================================================

// Draw an animated rotating gear
function drawGear(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  outerRadius: number,
  innerRadius: number,
  teeth: number,
  rotation: number,
  colors: { outer: string; inner: string; teeth: string; highlight: string },
  zoom: number
) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rotation);

  // Draw teeth
  ctx.fillStyle = colors.teeth;
  for (let i = 0; i < teeth; i++) {
    const angle = (i / teeth) * Math.PI * 2;
    const toothWidth = (Math.PI / teeth) * 0.6;
    ctx.beginPath();
    ctx.moveTo(
      Math.cos(angle - toothWidth) * innerRadius * zoom,
      Math.sin(angle - toothWidth) * innerRadius * zoom * 0.5
    );
    ctx.lineTo(
      Math.cos(angle - toothWidth * 0.5) * outerRadius * zoom,
      Math.sin(angle - toothWidth * 0.5) * outerRadius * zoom * 0.5
    );
    ctx.lineTo(
      Math.cos(angle + toothWidth * 0.5) * outerRadius * zoom,
      Math.sin(angle + toothWidth * 0.5) * outerRadius * zoom * 0.5
    );
    ctx.lineTo(
      Math.cos(angle + toothWidth) * innerRadius * zoom,
      Math.sin(angle + toothWidth) * innerRadius * zoom * 0.5
    );
    ctx.closePath();
    ctx.fill();
  }

  // Gear body
  ctx.fillStyle = colors.outer;
  ctx.beginPath();
  ctx.ellipse(
    0,
    0,
    innerRadius * zoom,
    innerRadius * zoom * 0.5,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Inner ring
  ctx.fillStyle = colors.inner;
  ctx.beginPath();
  ctx.ellipse(
    0,
    0,
    innerRadius * 0.6 * zoom,
    innerRadius * 0.6 * zoom * 0.5,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Center hub
  ctx.fillStyle = colors.highlight;
  ctx.beginPath();
  ctx.ellipse(
    0,
    0,
    innerRadius * 0.25 * zoom,
    innerRadius * 0.25 * zoom * 0.5,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Spokes
  ctx.strokeStyle = colors.teeth;
  ctx.lineWidth = 2 * zoom;
  for (let i = 0; i < 4; i++) {
    const angle = (i / 4) * Math.PI * 2;
    ctx.beginPath();
    ctx.moveTo(
      Math.cos(angle) * innerRadius * 0.3 * zoom,
      Math.sin(angle) * innerRadius * 0.3 * zoom * 0.5
    );
    ctx.lineTo(
      Math.cos(angle) * innerRadius * 0.85 * zoom,
      Math.sin(angle) * innerRadius * 0.85 * zoom * 0.5
    );
    ctx.stroke();
  }

  ctx.restore();
}

// Draw animated steam/smoke effect
function drawSteamVent(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  time: number,
  intensity: number,
  zoom: number,
  color: string = "rgba(200, 200, 200, "
) {
  const numPuffs = 4;
  for (let i = 0; i < numPuffs; i++) {
    const phase = (time * 2 + i * 0.3) % 1;
    const puffY = y - phase * 25 * zoom * intensity;
    const puffSize = (3 + phase * 4) * zoom * intensity;
    const alpha = (1 - phase) * 0.4;
    const drift = Math.sin(time * 3 + i) * 4 * zoom;

    ctx.fillStyle = `${color}${alpha})`;
    ctx.beginPath();
    ctx.ellipse(x + drift, puffY, puffSize, puffSize * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Draw animated conveyor belt with items
function drawConveyorBelt(
  ctx: CanvasRenderingContext2D,
  startX: number,
  startY: number,
  endX: number,
  endY: number,
  width: number,
  time: number,
  zoom: number,
  itemColor: string
) {
  const dx = endX - startX;
  const dy = endY - startY;
  const length = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx);

  ctx.save();
  ctx.translate(startX, startY);
  ctx.rotate(angle);

  // Belt track
  ctx.fillStyle = "#2a2a32";
  ctx.fillRect(0, -width * zoom * 0.5, length, width * zoom);

  // Belt segments (animated)
  ctx.fillStyle = "#3a3a42";
  const segmentWidth = 8 * zoom;
  const numSegments = Math.floor(length / segmentWidth) + 2;
  const offset = (time * 40 * zoom) % segmentWidth;

  for (let i = 0; i < numSegments; i++) {
    const segX = i * segmentWidth - offset;
    if (segX >= -segmentWidth && segX <= length) {
      ctx.fillRect(
        segX,
        -width * zoom * 0.4,
        segmentWidth * 0.6,
        width * zoom * 0.8
      );
    }
  }

  // Moving items (ammo boxes)
  const numItems = 2;
  for (let i = 0; i < numItems; i++) {
    const itemPhase = (time * 0.5 + i * 0.5) % 1;
    const itemX = itemPhase * length;

    ctx.fillStyle = itemColor;
    ctx.fillRect(
      itemX - 4 * zoom,
      -width * zoom * 0.35,
      8 * zoom,
      width * zoom * 0.7
    );

    // Item detail
    ctx.fillStyle = darkenColor(itemColor, 20);
    ctx.fillRect(
      itemX - 3 * zoom,
      -width * zoom * 0.25,
      2 * zoom,
      width * zoom * 0.5
    );
  }

  ctx.restore();
}

// Draw glowing energy tube/pipe
function drawEnergyTube(
  ctx: CanvasRenderingContext2D,
  startX: number,
  startY: number,
  endX: number,
  endY: number,
  radius: number,
  time: number,
  zoom: number,
  color: string
) {
  const dx = endX - startX;
  const dy = endY - startY;
  const length = Math.sqrt(dx * dx + dy * dy);

  // Tube body
  ctx.strokeStyle = "#2a2a32";
  ctx.lineWidth = radius * 2 * zoom;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(endX, endY);
  ctx.stroke();

  // Inner glow
  const glowPulse = 0.5 + Math.sin(time * 4) * 0.3;
  ctx.strokeStyle = color
    .replace(")", `, ${glowPulse})`)
    .replace("rgb", "rgba");
  ctx.lineWidth = radius * zoom;
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(endX, endY);
  ctx.stroke();

  // Energy flow particles
  const numParticles = 3;
  for (let i = 0; i < numParticles; i++) {
    const phase = (time * 2 + i / numParticles) % 1;
    const px = startX + dx * phase;
    const py = startY + dy * phase;
    const alpha = Math.sin(phase * Math.PI) * 0.8;

    ctx.fillStyle = color.replace(")", `, ${alpha})`).replace("rgb", "rgba");
    ctx.beginPath();
    ctx.arc(px, py, radius * 0.6 * zoom, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Draw animated ammunition/supply box
function drawAmmoBox(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  width: number,
  height: number,
  depth: number,
  colors: { main: string; accent: string; label: string },
  zoom: number,
  bouncePhase: number = 0
) {
  const bounce = Math.sin(bouncePhase) * 2 * zoom;
  const boxY = y - bounce;

  // Box body (isometric)
  const hw = width * zoom * 0.5;
  const hd = depth * zoom * 0.25;
  const hh = height * zoom;

  // Left face
  ctx.fillStyle = darkenColor(colors.main, 15);
  ctx.beginPath();
  ctx.moveTo(x - hw, boxY);
  ctx.lineTo(x, boxY + hd);
  ctx.lineTo(x, boxY + hd - hh);
  ctx.lineTo(x - hw, boxY - hh);
  ctx.closePath();
  ctx.fill();

  // Right face
  ctx.fillStyle = darkenColor(colors.main, 30);
  ctx.beginPath();
  ctx.moveTo(x + hw, boxY);
  ctx.lineTo(x, boxY + hd);
  ctx.lineTo(x, boxY + hd - hh);
  ctx.lineTo(x + hw, boxY - hh);
  ctx.closePath();
  ctx.fill();

  // Top face
  ctx.fillStyle = colors.main;
  ctx.beginPath();
  ctx.moveTo(x, boxY - hh - hd);
  ctx.lineTo(x - hw, boxY - hh);
  ctx.lineTo(x, boxY - hh + hd);
  ctx.lineTo(x + hw, boxY - hh);
  ctx.closePath();
  ctx.fill();

  // Warning stripes
  ctx.fillStyle = colors.accent;
  ctx.fillRect(x - hw * 0.4, boxY - hh * 0.7, hw * 0.8, hh * 0.15);
}

// Draw pulsing warning light
function drawWarningLight(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  radius: number,
  time: number,
  zoom: number,
  color: string,
  flashSpeed: number = 3
) {
  const flash = 0.5 + Math.sin(time * flashSpeed) * 0.5;

  // Glow
  ctx.shadowColor = color;
  ctx.shadowBlur = 10 * zoom * flash;

  // Light body
  ctx.fillStyle = darkenColor(color, 30);
  ctx.beginPath();
  ctx.arc(x, y, radius * zoom, 0, Math.PI * 2);
  ctx.fill();

  // Bright center
  ctx.fillStyle = color;
  ctx.globalAlpha = flash;
  ctx.beginPath();
  ctx.arc(x, y, radius * 0.7 * zoom, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;

  ctx.shadowBlur = 0;
}

function drawTowerBase(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  baseWidth: number,
  baseHeight: number,
  colors: { base: string; dark: string; light: string; accent: string },
  zoom: number
) {
  drawIsometricPrism(
    ctx,
    x,
    y + 8 * zoom,
    baseWidth + 8,
    baseWidth + 8,
    6,
    {
      top: darkenColor(colors.base, 30),
      left: darkenColor(colors.base, 50),
      right: darkenColor(colors.base, 40),
      leftBack: darkenColor(colors.base, 20),
      rightBack: darkenColor(colors.base, 25),
    },
    zoom
  );

  drawIsometricPrism(
    ctx,
    x,
    y,
    baseWidth,
    baseWidth,
    baseHeight,
    {
      top: colors.light,
      left: colors.base,
      right: colors.dark,
      leftBack: lightenColor(colors.base, 15),
      rightBack: lightenColor(colors.dark, 10),
    },
    zoom
  );
}

// ============================================================================
// TOWER PASSIVE EFFECTS HELPER
// ============================================================================
function drawTowerPassiveEffects(
  ctx: CanvasRenderingContext2D,
  screenPos: Position,
  tower: Tower,
  zoom: number,
  time: number,
  colors: { base: string; dark: string; light: string; accent: string }
) {
  // Add ambient particles floating around all towers
  const particleCount = 3 + tower.level;
  for (let i = 0; i < particleCount; i++) {
    const angle = time * (0.5 + i * 0.1) + i * ((Math.PI * 2) / particleCount);
    const radius = (25 + Math.sin(time * 2 + i) * 5) * zoom;
    const px = screenPos.x + Math.cos(angle) * radius;
    const py = screenPos.y - 30 * zoom + Math.sin(angle * 0.5) * radius * 0.3;
    const particleAlpha = 0.3 + Math.sin(time * 3 + i) * 0.2;
    const particleSize = (2 + Math.sin(time * 4 + i) * 1) * zoom;

    ctx.fillStyle = `rgba(255, 255, 255, ${particleAlpha})`;
    ctx.beginPath();
    ctx.arc(px, py, particleSize, 0, Math.PI * 2);
    ctx.fill();
  }

  // Subtle energy ring at base (except for station)
  if (tower.type !== "station") {
    const ringPulse = 1 + Math.sin(time * 2) * 0.1;
    ctx.strokeStyle = `rgba(${hexToRgb(colors.accent)}, ${
      0.15 + Math.sin(time * 3) * 0.1
    })`;
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      screenPos.y + 5 * zoom,
      30 * zoom * ringPulse,
      15 * zoom * ringPulse,
      0,
      0,
      Math.PI * 2
    );
    ctx.stroke();
  }
}

// Helper to convert hex to rgb values
function hexToRgb(hex: string): string {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  if (result) {
    return `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(
      result[3],
      16
    )}`;
  }
  return "255, 255, 255";
}

// ============================================================================
// TOWER RENDERING
// ============================================================================
export function renderTower(
  ctx: CanvasRenderingContext2D,
  tower: Tower,
  canvasWidth: number,
  canvasHeight: number,
  dpr: number,
  hoveredTower: string | null,
  selectedTower: string | null,
  enemies: Enemy[],
  selectedMap: string,
  cameraOffset?: Position,
  cameraZoom?: number
) {
  const worldPos = gridToWorld(tower.pos);
  const screenPos = worldToScreen(
    worldPos,
    canvasWidth,
    canvasHeight,
    dpr,
    cameraOffset,
    cameraZoom
  );
  const zoom = cameraZoom || 1;
  const time = Date.now() / 1000;
  const isHovered = hoveredTower === tower.id;
  const isSelected = selectedTower === tower.id;
  const colors = TOWER_COLORS[tower.type];

  // Draw passive effects first (behind tower)
  drawTowerPassiveEffects(ctx, screenPos, tower, zoom, time, colors);

  // Selection/hover glow with enhanced effect
  if (isSelected || isHovered) {
    ctx.save();
    ctx.shadowColor = isSelected ? "#c9a227" : "#ffffff";
    ctx.shadowBlur = 30 * zoom;

    // Outer glow ring
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      screenPos.y + 8 * zoom,
      42 * zoom,
      21 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fillStyle = isSelected
      ? "rgba(255, 215, 0, 0.15)"
      : "rgba(255,255,255,0.1)";
    ctx.fill();

    // Inner glow ring
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      screenPos.y + 8 * zoom,
      38 * zoom,
      19 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fillStyle = isSelected
      ? "rgba(255, 215, 0, 0.25)"
      : "rgba(255,255,255,0.2)";
    ctx.fill();

    // Animated selection ring
    if (isSelected) {
      const ringPulse = 1 + Math.sin(time * 4) * 0.05;
      ctx.strokeStyle = "rgba(255, 215, 0, 0.6)";
      ctx.lineWidth = 2 * zoom;
      ctx.setLineDash([8, 4]);
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        screenPos.y + 8 * zoom,
        44 * zoom * ringPulse,
        22 * zoom * ringPulse,
        0,
        0,
        Math.PI * 2
      );
      ctx.stroke();
      ctx.setLineDash([]);
    }
    ctx.restore();
  }

  // Enhanced shadow with soft edges
  const shadowGrad = ctx.createRadialGradient(
    screenPos.x,
    screenPos.y + 8 * zoom,
    0,
    screenPos.x,
    screenPos.y + 8 * zoom,
    32 * zoom
  );
  shadowGrad.addColorStop(0, "rgba(0,0,0,0.4)");
  shadowGrad.addColorStop(0.6, "rgba(0,0,0,0.2)");
  shadowGrad.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    screenPos.y + 8 * zoom,
    32 * zoom,
    16 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  switch (tower.type) {
    case "cannon":
      renderCannonTower(
        ctx,
        screenPos,
        tower,
        zoom,
        time,
        colors,
        enemies,
        selectedMap,
        canvasWidth,
        canvasHeight,
        dpr,
        cameraOffset,
        cameraZoom
      );
      break;
    case "library":
      renderLibraryTower(ctx, screenPos, tower, zoom, time, colors);
      break;
    case "lab":
      renderLabTower(
        ctx,
        screenPos,
        tower,
        zoom,
        time,
        colors,
        enemies,
        selectedMap,
        canvasWidth,
        canvasHeight,
        dpr,
        cameraOffset,
        cameraZoom
      );
      break;
    case "arch":
      renderArchTower(ctx, screenPos, tower, zoom, time, colors);
      break;
    case "club":
      renderClubTower(ctx, screenPos, tower, zoom, time, colors);
      break;
    case "station":
      renderStationTower(ctx, screenPos, tower, zoom, time, colors);
      break;
  }

  // Level indicator
  if (tower.level > 1) {
    const starY = screenPos.y + 20 * zoom - tower.level * 8 * zoom;
    ctx.fillStyle = "#c9a227";
    ctx.shadowColor = "#c9a227";
    ctx.shadowBlur = 6 * zoom;
    drawStar(ctx, screenPos.x, starY, 8 * zoom, 4 * zoom, "#c9a227");
    ctx.shadowBlur = 0;
    ctx.fillStyle = "#8b6914";
    ctx.font = `bold ${8 * zoom}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(tower.level.toString(), screenPos.x, starY + 1 * zoom);
  }

  // Upgrade path badge
  if (tower.level === 4 && tower.upgrade) {
    const badgeY = screenPos.y + 35 * zoom - tower.level * 8 * zoom;
    ctx.fillStyle = tower.upgrade === "A" ? "#ff6b6b" : "#4ecdc4";
    ctx.beginPath();
    ctx.arc(screenPos.x, badgeY, 6 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.font = `bold ${8 * zoom}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(tower.upgrade, screenPos.x, badgeY);
  }
}

function drawStar(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  outerR: number,
  innerR: number,
  color: string
) {
  ctx.fillStyle = color;
  ctx.beginPath();
  for (let i = 0; i < 10; i++) {
    const r = i % 2 === 0 ? outerR : innerR;
    const angle = ((i * 36 - 90) * Math.PI) / 180;
    if (i === 0) ctx.moveTo(x + Math.cos(angle) * r, y + Math.sin(angle) * r);
    else ctx.lineTo(x + Math.cos(angle) * r, y + Math.sin(angle) * r);
  }
  ctx.closePath();
  ctx.fill();
}

// CANNON TOWER - High-tech mechanical artillery platform
function renderCannonTower(
  ctx: CanvasRenderingContext2D,
  screenPos: Position,
  tower: Tower,
  zoom: number,
  time: number,
  colors: { base: string; dark: string; light: string; accent: string },
  enemies: Enemy[],
  selectedMap: string,
  canvasWidth: number,
  canvasHeight: number,
  dpr: number,
  cameraOffset?: Position,
  cameraZoom?: number
) {
  ctx.save();
  const level = tower.level;
  const baseWidth = 36 + level * 5;
  const baseHeight = 24 + level * 10;

  // Enhanced mechanical base with tech panels
  drawMechanicalTowerBase(
    ctx,
    screenPos.x,
    screenPos.y,
    baseWidth,
    baseHeight,
    {
      base: "#4a4a52",
      dark: "#2a2a32",
      light: "#6a6a72",
      accent: "#ff6600",
    },
    zoom,
    time,
    level
  );

  const topY = screenPos.y - baseHeight * zoom;

  // Tech platform on top
  ctx.fillStyle = "#3a3a42";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    topY + 2 * zoom,
    baseWidth * 0.5 * zoom,
    baseWidth * 0.25 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Glowing tech ring
  const pulse = 0.7 + Math.sin(time * 3) * 0.3;
  ctx.strokeStyle = `rgba(255, 102, 0, ${pulse * 0.6})`;
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    topY + 2 * zoom,
    baseWidth * 0.45 * zoom,
    baseWidth * 0.22 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.stroke();

  // Render appropriate cannon variant
  if (tower.level === 4 && tower.upgrade === "A") {
    renderGatlingGun(ctx, screenPos, topY, tower, zoom, time);
  } else if (tower.level === 4 && tower.upgrade === "B") {
    renderFlamethrower(ctx, screenPos, topY, tower, zoom, time);
  } else if (tower.level === 3) {
    renderHeavyCannon(ctx, screenPos, topY, tower, zoom, time);
  } else {
    renderStandardCannon(ctx, screenPos, topY, tower, zoom, time);
  }

  ctx.restore();
}

// Mechanical base with tech details - FULLY ENCLOSED isometric design
function drawMechanicalTowerBase(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  width: number,
  height: number,
  colors: { base: string; dark: string; light: string; accent: string },
  zoom: number,
  time: number,
  level: number
) {
  // Foundation platform (bottom layer)
  drawIsometricPrism(
    ctx,
    x,
    y + 10 * zoom,
    width + 12,
    width + 12,
    6,
    {
      top: "#3a3a42",
      left: "#2a2a32",
      right: "#252530",
      leftBack: "#32323a",
      rightBack: "#2d2d35",
    },
    zoom
  );

  // Main tower body (middle layer) - this is the core structure
  drawIsometricPrism(
    ctx,
    x,
    y + 4 * zoom,
    width,
    width,
    height - 8,
    {
      top: colors.light,
      left: colors.base,
      right: colors.dark,
      leftBack: lightenColor(colors.base, 10),
      rightBack: lightenColor(colors.dark, 5),
    },
    zoom
  );

  // Tech layer on top
  drawIsometricPrism(
    ctx,
    x,
    y - (height - 12) * zoom,
    width - 4,
    width - 4,
    8,
    {
      top: lightenColor(colors.base, 15),
      left: colors.base,
      right: colors.dark,
      leftBack: colors.light,
      rightBack: lightenColor(colors.dark, 8),
    },
    zoom
  );

  // Add tech details on top of the fully enclosed base
  const topY = y - height * zoom;
  const w = width * zoom * 0.5;
  const d = width * zoom * 0.25;

  // ========== STEAM VENTS ==========
  // Left side steam vent
  drawSteamVent(
    ctx,
    x - w * 0.75,
    y - height * zoom * 0.1,
    time,
    0.8 + level * 0.2,
    zoom
  );

  // Right side steam vent (higher levels)
  if (level >= 2) {
    drawSteamVent(
      ctx,
      x + w * 0.7,
      y - height * zoom * 0.15,
      time + 0.5,
      0.6 + level * 0.15,
      zoom
    );
  }

  // ========== ENERGY TUBES ==========
  drawEnergyTube(
    ctx,
    x - w * 0.4,
    y,
    x - w * 0.2,
    y - height * zoom * 0.6,
    2,
    time,
    zoom,
    "rgb(255, 102, 0)"
  );

  if (level >= 3) {
    drawEnergyTube(
      ctx,
      x + w * 0.45,
      y - 4 * zoom,
      x + w * 0.45,
      y - height * zoom * 0.55,
      2.5,
      time + 0.3,
      zoom,
      "rgb(255, 80, 0)"
    );
  }

  // Tech panel lines on front faces (flipped orientation)
  ctx.strokeStyle = lightenColor(colors.light, 20);
  ctx.lineWidth = 1 * zoom;

  // Left face panel lines (diagonal going other direction)
  for (let i = 1; i <= Math.min(level, 3); i++) {
    const lineY = y + 4 * zoom - ((height - 8) * zoom * i) / (level + 1);
    ctx.beginPath();
    ctx.moveTo(x - w * 0.15, lineY + d * 0.3);
    ctx.lineTo(x - w * 0.85, lineY - d * 0.4);
    ctx.stroke();
  }

  // Right face panel lines (diagonal going other direction)
  for (let i = 1; i <= Math.min(level, 3); i++) {
    const lineY = y + 4 * zoom - ((height - 8) * zoom * i) / (level + 1);
    ctx.beginPath();
    ctx.moveTo(x + w * 0.85, lineY - d * 0.3);
    ctx.lineTo(x + w * 0.15, lineY + d * 0.4);
    ctx.stroke();
  }

  // ========== GLOWING VENTS WITH PULSING LIGHT ==========
  const ventGlow = 0.6 + Math.sin(time * 4) * 0.3;
  ctx.fillStyle = `rgba(255, 102, 0, ${ventGlow})`;
  ctx.shadowColor = "#ff6600";
  ctx.shadowBlur = 6 * zoom;

  // Left face vents
  for (let i = 0; i < Math.min(level, 3); i++) {
    const ventY = y - height * zoom * 0.3 - i * 12 * zoom;
    ctx.beginPath();
    ctx.ellipse(
      x + w * 0.55,
      ventY + d * 1.4,
      3 * zoom,
      2 * zoom,
      -0.4,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  // Right face vents
  for (let i = 0; i < Math.min(level, 3); i++) {
    const ventY = y - height * zoom * 0.3 - i * 12 * zoom;
    ctx.beginPath();
    ctx.ellipse(
      x - w * 0.55,
      ventY + d * 1.4,
      3 * zoom,
      2 * zoom,
      0.4,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }
  ctx.shadowBlur = 0;

  // ========== ROTATING GEARS ==========
  const gearRotation = 1.25;

  // Large gear on left side (visible on front face)
  drawGear(
    ctx,
    x - w * 0.7,
    y - height * zoom * 0.5,
    12 + level * 2,
    8 + level,
    8 + level * 2,
    gearRotation,
    {
      outer: "#4a4a52",
      inner: "#3a3a42",
      teeth: "#5a5a62",
      highlight: colors.accent,
    },
    zoom
  );

  // Smaller gear meshing with large gear (counter-rotation)
  drawGear(
    ctx,
    x - w * 0.2,
    y - height * zoom * 0.65,
    8 + level,
    5 + level * 0.5,
    6 + level,
    gearRotation,
    {
      outer: "#5a5a62",
      inner: "#4a4a52",
      teeth: "#6a6a72",
      highlight: colors.accent,
    },
    zoom
  );

  // Gear on right side
  if (level >= 2) {
    drawGear(
      ctx,
      x + w * 0.55,
      y - height * zoom * 0.55,
      10 + level,
      7,
      8 + level,
      -gearRotation,
      {
        outer: "#4a4a52",
        inner: "#3a3a42",
        teeth: "#5a5a62",
        highlight: colors.accent,
      },
      zoom
    );
  }

  // ========== CONVEYOR BELT WITH AMMO ==========
  if (level >= 2) {
    drawConveyorBelt(
      ctx,
      x - w * 0.5,
      y + 6 * zoom,
      x - w * 0.5,
      y - height * zoom * 1.1,
      6,
      time,
      zoom,
      "#8b4513" // Brass ammo color
    );
  }

  // ========== WARNING LIGHTS ==========
  drawWarningLight(
    ctx,
    x - w * 0.85,
    y - height * zoom + 12 * zoom,
    3,
    time,
    zoom,
    "#ff4400",
    4
  );
  if (level >= 2) {
    drawWarningLight(
      ctx,
      x + w * 0.85,
      y - height * zoom + 12 * zoom,
      3,
      time + 0.5,
      zoom,
      "#ffaa00",
      3
    );
  }

  // ========== AMMO BOXES ==========
  if (level >= 2) {
    drawAmmoBox(
      ctx,
      x - w * 0.5,
      y + 5 * zoom,
      12,
      6,
      12,
      { main: "#5a4a3a", accent: "#ff6600", label: "#c9a227" },
      zoom,
      time * 2
    );
  }
  if (level >= 3) {
    drawAmmoBox(
      ctx,
      x - w * 0.5,
      y + 2 * zoom,
      14,
      5,
      10,
      { main: "#4a3a2a", accent: "#ffaa00", label: "#c9a227" },
      zoom,
      time * 2 + 1
    );
  }

  // Corner reinforcement bolts
  ctx.fillStyle = "#5a5a62";
  const boltSize = 2.5 * zoom;
  // Front corners
  ctx.beginPath();
  ctx.arc(x - w * 0.9, y + d * 0.3 - 4 * zoom, boltSize, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + w * 0.9, y + d * 0.3 - 4 * zoom, boltSize, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(
    x - w * 0.9,
    y - height * zoom + d + 8 * zoom,
    boltSize,
    0,
    Math.PI * 2
  );
  ctx.fill();
  ctx.beginPath();
  ctx.arc(
    x + w * 0.9,
    y - height * zoom + d + 8 * zoom,
    boltSize,
    0,
    Math.PI * 2
  );
  ctx.fill();
}
// Helper function to calculate pitch based on tower elevation and typical range
function calculateBarrelPitch(
  towerElevation: number,
  barrelLength: number
): number {
  // Towers are elevated, enemies are on ground - barrel should pitch down
  // Use a reasonable pitch based on geometry (typically 15-25 degrees)
  const typicalRange = barrelLength * 2.5;
  return Math.atan2(towerElevation, typicalRange);
}

function renderStandardCannon(
  ctx: CanvasRenderingContext2D,
  screenPos: Position,
  topY: number,
  tower: Tower,
  zoom: number,
  time: number
) {
  const rotation = tower.rotation || 0;
  const level = tower.level;

  // Recoil animation
  const timeSinceFire = Date.now() - tower.lastAttack;
  let recoilOffset = 0;
  let turretShake = 0;
  let reloadPhase = 0;

  if (timeSinceFire < 400) {
    const firePhase = timeSinceFire / 400;
    if (firePhase < 0.1) {
      recoilOffset = (firePhase / 0.1) * 8 * zoom;
      turretShake = Math.sin(firePhase * Math.PI * 20) * 2 * zoom;
    } else if (firePhase < 0.4) {
      const returnPhase = (firePhase - 0.1) / 0.3;
      recoilOffset =
        8 * zoom * (1 - returnPhase) * Math.cos(returnPhase * Math.PI * 2);
      turretShake =
        Math.sin(returnPhase * Math.PI * 6) * (1 - returnPhase) * 1.5 * zoom;
    } else {
      reloadPhase = (firePhase - 0.4) / 0.6;
    }
  }

  // Calculate isometric foreshortening based on rotation
  const cosR = Math.cos(rotation);
  const sinR = Math.sin(rotation);
  const foreshorten = Math.abs(cosR);

  // Larger barrel dimensions
  const baseBarrelLength = (30 + level * 12) * zoom;
  const barrelLength =
    baseBarrelLength * (0.4 + foreshorten * 0.6) - recoilOffset;
  const barrelWidth = (12 + level * 3) * zoom;

  // Determine if barrel is pointing "away" for draw order
  const facingAway = sinR < -0.3;

  // Apply turret shake
  const shakeX = turretShake * cosR;
  const shakeY = turretShake * sinR * 0.5;
  const turretX = screenPos.x + shakeX;
  const turretY = topY + shakeY;

  // Enhanced turret base platform with ring details
  ctx.fillStyle = "#2a2a32";
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 2 * zoom,
    20 * zoom,
    10 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Rotating platform ring with visible teeth/notches
  ctx.strokeStyle = "#4a4a52";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 4 * zoom,
    18 * zoom,
    9 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.stroke();

  // Rotating gear teeth around base (shows rotation)
  ctx.fillStyle = "#5a5a62";
  for (let i = 0; i < 12; i++) {
    const toothAngle = rotation + (i / 12) * Math.PI * 2;
    const toothX = turretX + Math.cos(toothAngle) * 17 * zoom;
    const toothY = turretY - 4 * zoom + Math.sin(toothAngle) * 8.5 * zoom;
    ctx.beginPath();
    ctx.arc(toothX, toothY, 2.5 * zoom, 0, Math.PI * 2);
    ctx.fill();
  }

  // Turret base
  ctx.fillStyle = "#3a3a42";
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 5 * zoom,
    17 * zoom,
    8.5 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // If facing away, draw barrel BEFORE turret housing
  if (facingAway) {
    drawCannonBarrel(
      ctx,
      turretX,
      turretY - 12 * zoom,
      rotation,
      barrelLength,
      barrelWidth,
      foreshorten,
      zoom,
      tower,
      time
    );
  }

  // Enhanced turret housing - layered dome design
  const housingGrad = ctx.createRadialGradient(
    turretX - 4 * zoom,
    turretY - 16 * zoom,
    0,
    turretX,
    turretY - 12 * zoom,
    18 * zoom
  );
  housingGrad.addColorStop(0, "#7a7a82");
  housingGrad.addColorStop(0.4, "#5a5a62");
  housingGrad.addColorStop(1, "#4a4a52");
  ctx.fillStyle = housingGrad;
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 12 * zoom,
    16 * zoom,
    8 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // ROTATING ARMOR PLATES
  for (let i = 0; i < 6; i++) {
    const plateAngle = rotation + (i / 6) * Math.PI * 2;
    const plateVisible = Math.cos(plateAngle - rotation);

    if (plateVisible > -0.3) {
      const plateX1 = turretX + Math.cos(plateAngle) * 8 * zoom;
      const plateY1 = turretY - 12 * zoom + Math.sin(plateAngle) * 4 * zoom;
      const plateX2 = turretX + Math.cos(plateAngle) * 15 * zoom;
      const plateY2 = turretY - 12 * zoom + Math.sin(plateAngle) * 7.5 * zoom;

      const shade = 0.4 + plateVisible * 0.3;
      ctx.strokeStyle = `rgba(140, 140, 150, ${shade})`;
      ctx.lineWidth = 2 * zoom;
      ctx.beginPath();
      ctx.moveTo(plateX1, plateY1);
      ctx.lineTo(plateX2, plateY2);
      ctx.stroke();

      ctx.fillStyle = `rgba(100, 100, 110, ${shade})`;
      ctx.beginPath();
      ctx.arc(plateX2, plateY2, 2 * zoom, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Armor plate divider lines (rotate with turret)
  ctx.strokeStyle = "#6a6a72";
  ctx.lineWidth = 1.5 * zoom;
  for (let i = 0; i < 6; i++) {
    const angle = rotation + (i / 6) * Math.PI * 2 + Math.PI / 12;
    ctx.beginPath();
    ctx.moveTo(turretX, turretY - 12 * zoom);
    ctx.lineTo(
      turretX + Math.cos(angle) * 14 * zoom,
      turretY - 12 * zoom + Math.sin(angle) * 7 * zoom
    );
    ctx.stroke();
  }

  // Central pivot mechanism
  ctx.fillStyle = "#2a2a32";
  ctx.beginPath();
  ctx.arc(turretX, turretY - 12 * zoom, 10 * zoom, 0, Math.PI * 2);
  ctx.fill();

  // Inner ring
  ctx.strokeStyle = "#5a5a62";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.arc(turretX, turretY - 12 * zoom, 7 * zoom, 0, Math.PI * 2);
  ctx.stroke();

  // Glowing core with pulsing animation
  const coreGlow = 0.6 + Math.sin(time * 5) * 0.3 + reloadPhase * 0.3;
  const coreGrad = ctx.createRadialGradient(
    turretX,
    turretY - 12 * zoom,
    0,
    turretX,
    turretY - 12 * zoom,
    6 * zoom
  );
  coreGrad.addColorStop(0, `rgba(255, 180, 80, ${coreGlow})`);
  coreGrad.addColorStop(0.4, `rgba(255, 120, 30, ${coreGlow * 0.8})`);
  coreGrad.addColorStop(0.7, `rgba(255, 80, 0, ${coreGlow * 0.5})`);
  coreGrad.addColorStop(1, `rgba(255, 50, 0, 0)`);
  ctx.fillStyle = coreGrad;
  ctx.beginPath();
  ctx.arc(turretX, turretY - 12 * zoom, 6 * zoom, 0, Math.PI * 2);
  ctx.fill();

  // Core highlight
  ctx.fillStyle = `rgba(255, 220, 180, ${coreGlow * 0.8})`;
  ctx.beginPath();
  ctx.arc(turretX - 1 * zoom, turretY - 13 * zoom, 2 * zoom, 0, Math.PI * 2);
  ctx.fill();

  // If not facing away, draw barrel AFTER turret housing
  if (!facingAway) {
    drawCannonBarrel(
      ctx,
      turretX,
      turretY - 12 * zoom,
      rotation,
      barrelLength,
      barrelWidth,
      foreshorten,
      zoom,
      tower,
      time
    );
  }

  // Calculate pitch for muzzle flash positioning
  const towerElevation = 25 * zoom;
  const pitch = calculateBarrelPitch(towerElevation, barrelLength);
  const pitchDrop = barrelLength * Math.sin(pitch) * 0.5;

  // Muzzle flash effect
  if (timeSinceFire < 100) {
    const flashPhase = timeSinceFire / 100;
    const flashSize = (15 - flashPhase * 10) * zoom;
    const turretRadius = 8 * zoom;
    const totalLength =
      turretRadius + barrelLength * Math.cos(pitch) + 5 * zoom;
    const flashX = turretX + cosR * totalLength;
    const flashY = turretY - 12 * zoom + sinR * totalLength * 0.5 + pitchDrop;

    ctx.fillStyle = `rgba(255, 200, 100, ${1 - flashPhase})`;
    ctx.shadowColor = "#ff6600";
    ctx.shadowBlur = 20 * zoom;
    ctx.beginPath();
    ctx.arc(flashX, flashY, flashSize, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// Helper function to draw cannon barrel with isometric perspective, recoil, and pitch
function drawCannonBarrel(
  ctx: CanvasRenderingContext2D,
  pivotX: number,
  pivotY: number,
  rotation: number,
  barrelLength: number,
  barrelWidth: number,
  foreshorten: number,
  zoom: number,
  tower: Tower,
  time: number
) {
  const cosR = Math.cos(rotation);
  const sinR = Math.sin(rotation);

  // Calculate pitch - barrel aims down at ground-level enemies
  const towerElevation = 25 * zoom;
  const pitch = calculateBarrelPitch(towerElevation, barrelLength);
  const pitchCos = Math.cos(pitch);
  const pitchSin = Math.sin(pitch);

  // Calculate recoil
  const timeSinceFire = Date.now() - tower.lastAttack;
  let recoilOffset = 0;
  if (timeSinceFire < 150) {
    const recoilPhase = timeSinceFire / 150;
    if (recoilPhase < 0.2) {
      recoilOffset = (recoilPhase / 0.2) * 8 * zoom;
    } else {
      recoilOffset = 8 * zoom * (1 - (recoilPhase - 0.2) / 0.8);
    }
  }

  // Barrel emerges from inside the turret housing
  const turretRadius = 8 * zoom;
  const barrelStartX = pivotX + cosR * turretRadius;
  const barrelStartY = pivotY + sinR * turretRadius * 0.5;

  // Apply recoil
  const recoiledPivotX = barrelStartX - cosR * recoilOffset;
  const recoiledPivotY = barrelStartY - sinR * recoilOffset * 0.5;

  // Apply pitch to barrel length
  const effectiveBarrelLength = barrelLength * pitchCos;
  const pitchDrop = barrelLength * pitchSin * 0.5;

  // Calculate barrel end point with pitch
  const endX = recoiledPivotX + cosR * effectiveBarrelLength;
  const endY = recoiledPivotY + sinR * effectiveBarrelLength * 0.5 + pitchDrop;

  // Calculate perpendicular offset for barrel thickness
  const perpX = -sinR * barrelWidth * 0.5;
  const perpY = cosR * barrelWidth * 0.25;

  const lightSide = sinR < 0;

  // Main barrel body
  const barrelGrad = ctx.createLinearGradient(
    recoiledPivotX + perpX,
    recoiledPivotY + perpY,
    recoiledPivotX - perpX,
    recoiledPivotY - perpY
  );
  if (lightSide) {
    barrelGrad.addColorStop(0, "#7a7a82");
    barrelGrad.addColorStop(0.4, "#6a6a72");
    barrelGrad.addColorStop(1, "#4a4a52");
  } else {
    barrelGrad.addColorStop(0, "#5a5a62");
    barrelGrad.addColorStop(0.6, "#6a6a72");
    barrelGrad.addColorStop(1, "#5a5a62");
  }
  ctx.fillStyle = barrelGrad;
  ctx.beginPath();
  const taperMult = 0.7;
  ctx.moveTo(recoiledPivotX + perpX, recoiledPivotY + perpY);
  ctx.lineTo(endX + perpX * taperMult, endY + perpY * taperMult);
  ctx.lineTo(endX - perpX * taperMult, endY - perpY * taperMult);
  ctx.lineTo(recoiledPivotX - perpX, recoiledPivotY - perpY);
  ctx.closePath();
  ctx.fill();

  // Barrel reinforcement bands - adjusted for pitch
  ctx.strokeStyle = "#8a8a92";
  ctx.lineWidth = 2.5 * zoom;
  for (let i = 0; i < 3; i++) {
    const t = 0.2 + i * 0.25;
    const bx = recoiledPivotX + cosR * effectiveBarrelLength * t;
    const by =
      recoiledPivotY + sinR * effectiveBarrelLength * t * 0.5 + pitchDrop * t;
    const widthMult = 1 - t * 0.3;
    ctx.beginPath();
    ctx.moveTo(bx + perpX * widthMult, by + perpY * widthMult);
    ctx.lineTo(bx - perpX * widthMult, by - perpY * widthMult);
    ctx.stroke();
  }

  // Energy conduits along barrel
  const conduitGlow = 0.5 + Math.sin(time * 6) * 0.3;
  ctx.strokeStyle = `rgba(255, 102, 0, ${conduitGlow})`;
  ctx.lineWidth = 1.5 * zoom;

  ctx.beginPath();
  ctx.moveTo(recoiledPivotX + perpX * 0.3, recoiledPivotY + perpY * 0.3);
  ctx.lineTo(endX + perpX * 0.2 * taperMult, endY + perpY * 0.2 * taperMult);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(recoiledPivotX - perpX * 0.3, recoiledPivotY - perpY * 0.3);
  ctx.lineTo(endX - perpX * 0.2 * taperMult, endY - perpY * 0.2 * taperMult);
  ctx.stroke();

  // Muzzle assembly - adjusted for pitch
  ctx.fillStyle = "#3a3a42";
  const muzzleStart = 0.85;
  const msx = recoiledPivotX + cosR * effectiveBarrelLength * muzzleStart;
  const msy =
    recoiledPivotY +
    sinR * effectiveBarrelLength * muzzleStart * 0.5 +
    pitchDrop * muzzleStart;
  ctx.beginPath();
  ctx.moveTo(msx + perpX * taperMult * 0.9, msy + perpY * taperMult * 0.9);
  ctx.lineTo(endX + perpX * taperMult * 1.1, endY + perpY * taperMult * 1.1);
  ctx.lineTo(endX - perpX * taperMult * 1.1, endY - perpY * taperMult * 1.1);
  ctx.lineTo(msx - perpX * taperMult * 0.9, msy - perpY * taperMult * 0.9);
  ctx.closePath();
  ctx.fill();

  // Muzzle bore - angled for pitch
  ctx.fillStyle = "#1a1a1a";
  ctx.beginPath();
  ctx.ellipse(
    endX + cosR * 1.35 * zoom,
    endY + sinR * 1 * zoom + pitchSin * 2 * zoom,
    barrelWidth * 0.2 * foreshorten * pitchCos,
    barrelWidth * 0.15,
    rotation,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Muzzle flash effect
  if (timeSinceFire < 150) {
    const flash = 1 - timeSinceFire / 150;
    const flashX = endX + cosR * 10 * zoom;
    const flashY = endY + sinR * 5 * zoom + pitchDrop * 0.2;
    const flashGrad = ctx.createRadialGradient(
      flashX,
      flashY,
      0,
      flashX,
      flashY,
      25 * zoom * flash
    );
    flashGrad.addColorStop(0, `rgba(255, 255, 220, ${flash})`);
    flashGrad.addColorStop(0.2, `rgba(255, 200, 100, ${flash * 0.9})`);
    flashGrad.addColorStop(0.5, `rgba(255, 120, 0, ${flash * 0.6})`);
    flashGrad.addColorStop(1, `rgba(255, 50, 0, 0)`);
    ctx.fillStyle = flashGrad;
    ctx.beginPath();
    ctx.arc(flashX, flashY, 25 * zoom * flash, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Level 3 Heavy Cannon - reinforced barrel with stabilizers and isometric rendering
function renderHeavyCannon(
  ctx: CanvasRenderingContext2D,
  screenPos: Position,
  topY: number,
  tower: Tower,
  zoom: number,
  time: number
) {
  const rotation = tower.rotation || 0;

  // Recoil animation - heavier recoil for heavy cannon
  const timeSinceFire = Date.now() - tower.lastAttack;
  let recoilOffset = 0;
  let turretShake = 0;
  let reloadPhase = 0;

  if (timeSinceFire < 600) {
    const firePhase = timeSinceFire / 600;
    if (firePhase < 0.15) {
      recoilOffset = (firePhase / 0.15) * 12 * zoom;
      turretShake = Math.sin(firePhase * Math.PI * 15) * 3 * zoom;
    } else if (firePhase < 0.5) {
      const returnPhase = (firePhase - 0.15) / 0.35;
      recoilOffset =
        12 * zoom * (1 - returnPhase) * Math.cos(returnPhase * Math.PI * 1.5);
      turretShake =
        Math.sin(returnPhase * Math.PI * 4) * (1 - returnPhase) * 2 * zoom;
    } else {
      reloadPhase = (firePhase - 0.5) / 0.5;
    }
  }

  // Calculate isometric foreshortening
  const cosR = Math.cos(rotation);
  const sinR = Math.sin(rotation);
  const foreshorten = Math.abs(cosR);
  const facingAway = sinR < -0.3;

  // Larger barrel for heavy cannon
  const baseBarrelLength = 65 * zoom;
  const barrelLength =
    baseBarrelLength * (0.4 + foreshorten * 0.6) - recoilOffset;
  const barrelWidth = 18 * zoom;

  // Apply turret shake
  const shakeX = turretShake * cosR;
  const shakeY = turretShake * sinR * 0.5;
  const turretX = screenPos.x + shakeX;
  const turretY = topY + shakeY;

  // Heavy turret base with armored rim
  ctx.fillStyle = "#1a1a22";
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 1 * zoom,
    26 * zoom,
    13 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Outer ring detail with rotating gear teeth
  ctx.strokeStyle = "#4a4a52";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 3 * zoom,
    24 * zoom,
    12 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.stroke();

  // Rotating gear teeth around base
  ctx.fillStyle = "#5a5a62";
  for (let i = 0; i < 16; i++) {
    const toothAngle = rotation + (i / 16) * Math.PI * 2;
    const toothX = turretX + Math.cos(toothAngle) * 23 * zoom;
    const toothY = turretY - 3 * zoom + Math.sin(toothAngle) * 11.5 * zoom;
    ctx.beginPath();
    ctx.arc(toothX, toothY, 2.5 * zoom, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.fillStyle = "#2a2a32";
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 4 * zoom,
    23 * zoom,
    11.5 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  ctx.fillStyle = "#3a3a42";
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 6 * zoom,
    21 * zoom,
    10.5 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Draw barrel behind housing if facing away
  if (facingAway) {
    drawHeavyCannonBarrel(
      ctx,
      turretX,
      turretY - 16 * zoom,
      rotation,
      barrelLength,
      barrelWidth,
      foreshorten,
      zoom,
      tower,
      time
    );
  }

  // Armored turret housing
  const housingGrad = ctx.createRadialGradient(
    turretX - 5 * zoom,
    turretY - 20 * zoom,
    0,
    turretX,
    turretY - 16 * zoom,
    24 * zoom
  );
  housingGrad.addColorStop(0, "#7a7a82");
  housingGrad.addColorStop(0.3, "#6a6a72");
  housingGrad.addColorStop(0.6, "#5a5a62");
  housingGrad.addColorStop(1, "#3a3a42");
  ctx.fillStyle = housingGrad;
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 16 * zoom,
    20 * zoom,
    10 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // ROTATING ARMOR PLATES - Heavy duty version
  for (let i = 0; i < 8; i++) {
    const plateAngle = rotation + (i / 8) * Math.PI * 2;
    const plateVisible = Math.cos(plateAngle - rotation);

    if (plateVisible > -0.4) {
      const shade = 0.5 + plateVisible * 0.35;
      const innerR = 10 * zoom;
      const outerR = 18 * zoom;
      const plateX1 = turretX + Math.cos(plateAngle) * innerR;
      const plateY1 = turretY - 16 * zoom + Math.sin(plateAngle) * innerR * 0.5;
      const plateX2 = turretX + Math.cos(plateAngle) * outerR;
      const plateY2 = turretY - 16 * zoom + Math.sin(plateAngle) * outerR * 0.5;

      ctx.strokeStyle = `rgba(130, 130, 140, ${shade})`;
      ctx.lineWidth = 3 * zoom;
      ctx.beginPath();
      ctx.moveTo(plateX1, plateY1);
      ctx.lineTo(plateX2, plateY2);
      ctx.stroke();

      ctx.fillStyle = `rgba(90, 90, 100, ${shade})`;
      ctx.beginPath();
      ctx.arc(plateX2, plateY2, 3 * zoom, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = `rgba(150, 150, 160, ${shade * 0.7})`;
      ctx.beginPath();
      ctx.arc(
        plateX2 - 0.5 * zoom,
        plateY2 - 0.5 * zoom,
        1 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }
  }

  // Additional armor plate divider lines
  ctx.strokeStyle = "#8a8a92";
  ctx.lineWidth = 1.5 * zoom;
  for (let i = 0; i < 6; i++) {
    const angle = rotation + (i / 6) * Math.PI * 2 + Math.PI / 12;
    const x1 = turretX + Math.cos(angle) * 12 * zoom;
    const y1 = turretY - 16 * zoom + Math.sin(angle) * 6 * zoom;
    const x2 = turretX + Math.cos(angle) * 18 * zoom;
    const y2 = turretY - 16 * zoom + Math.sin(angle) * 9 * zoom;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  // Bolt details on housing
  ctx.fillStyle = "#5a5a62";
  for (let i = 0; i < 8; i++) {
    const angle = rotation + (i / 8) * Math.PI * 2;
    const bx = turretX + Math.cos(angle) * 16 * zoom;
    const by = turretY - 16 * zoom + Math.sin(angle) * 8 * zoom;
    ctx.beginPath();
    ctx.arc(bx, by, 2 * zoom, 0, Math.PI * 2);
    ctx.fill();
  }

  // Heavy pivot mechanism
  ctx.fillStyle = "#2a2a32";
  ctx.beginPath();
  ctx.arc(turretX, turretY - 16 * zoom, 12 * zoom, 0, Math.PI * 2);
  ctx.fill();

  // Inner ring
  ctx.strokeStyle = "#5a5a62";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.arc(turretX, turretY - 16 * zoom, 9 * zoom, 0, Math.PI * 2);
  ctx.stroke();

  // Power core
  const coreGlow = 0.7 + Math.sin(time * 4) * 0.3 + reloadPhase * 0.4;
  const coreGrad = ctx.createRadialGradient(
    turretX,
    turretY - 16 * zoom,
    0,
    turretX,
    turretY - 16 * zoom,
    9 * zoom
  );
  coreGrad.addColorStop(0, `rgba(255, 220, 120, ${coreGlow})`);
  coreGrad.addColorStop(0.25, `rgba(255, 180, 80, ${coreGlow * 0.9})`);
  coreGrad.addColorStop(0.5, `rgba(255, 130, 30, ${coreGlow * 0.6})`);
  coreGrad.addColorStop(0.75, `rgba(255, 80, 0, ${coreGlow * 0.3})`);
  coreGrad.addColorStop(1, `rgba(255, 50, 0, 0)`);
  ctx.fillStyle = coreGrad;
  ctx.beginPath();
  ctx.arc(turretX, turretY - 16 * zoom, 9 * zoom, 0, Math.PI * 2);
  ctx.fill();

  // Core highlight
  ctx.fillStyle = `rgba(255, 240, 200, ${coreGlow * 0.9})`;
  ctx.beginPath();
  ctx.arc(turretX - 2 * zoom, turretY - 18 * zoom, 2.5 * zoom, 0, Math.PI * 2);
  ctx.fill();

  // Core ring
  ctx.strokeStyle = `rgba(255, 150, 50, ${coreGlow * 0.7})`;
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.arc(turretX, turretY - 16 * zoom, 6 * zoom, 0, Math.PI * 2);
  ctx.stroke();

  // Draw barrel in front if not facing away
  if (!facingAway) {
    drawHeavyCannonBarrel(
      ctx,
      turretX,
      turretY - 16 * zoom,
      rotation,
      barrelLength,
      barrelWidth,
      foreshorten,
      zoom,
      tower,
      time
    );
  }

  // Calculate pitch for muzzle flash positioning
  const towerElevation = 35 * zoom;
  const pitch = calculateBarrelPitch(towerElevation, barrelLength);
  const pitchDrop = barrelLength * Math.sin(pitch) * 0.5;

  // Muzzle flash effect for heavy cannon
  if (timeSinceFire < 150) {
    const flashPhase = timeSinceFire / 150;
    const flashSize = (25 - flashPhase * 18) * zoom;
    const turretRadius = 10 * zoom;
    const totalLength =
      turretRadius + barrelLength * Math.cos(pitch) + 8 * zoom;
    const flashX = turretX + cosR * totalLength;
    const flashY = turretY - 16 * zoom + sinR * totalLength * 0.5 + pitchDrop;

    ctx.fillStyle = `rgba(255, 220, 100, ${1 - flashPhase})`;
    ctx.shadowColor = "#ff8800";
    ctx.shadowBlur = 30 * zoom;
    ctx.beginPath();
    ctx.arc(flashX, flashY, flashSize, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// Heavy cannon barrel with stabilizers, recoil, and pitch
function drawHeavyCannonBarrel(
  ctx: CanvasRenderingContext2D,
  pivotX: number,
  pivotY: number,
  rotation: number,
  barrelLength: number,
  barrelWidth: number,
  foreshorten: number,
  zoom: number,
  tower: Tower,
  time: number
) {
  const cosR = Math.cos(rotation);
  const sinR = Math.sin(rotation);

  // Calculate pitch - heavier cannon, more elevated turret
  const towerElevation = 35 * zoom;
  const pitch = calculateBarrelPitch(towerElevation, barrelLength);
  const pitchCos = Math.cos(pitch);
  const pitchSin = Math.sin(pitch);

  // Calculate recoil
  const timeSinceFire = Date.now() - tower.lastAttack;
  let recoilOffset = 0;
  if (timeSinceFire < 200) {
    const recoilPhase = timeSinceFire / 200;
    if (recoilPhase < 0.15) {
      recoilOffset = (recoilPhase / 0.15) * 10 * zoom;
    } else {
      recoilOffset = 10 * zoom * (1 - (recoilPhase - 0.15) / 0.85);
    }
  }

  const turretRadius = 10 * zoom;
  const barrelStartX = pivotX + cosR * turretRadius;
  const barrelStartY = pivotY + sinR * turretRadius * 0.5;

  const recoiledPivotX = barrelStartX - cosR * recoilOffset;
  const recoiledPivotY = barrelStartY - sinR * recoilOffset * 0.5;

  // Apply pitch
  const effectiveBarrelLength = barrelLength * pitchCos;
  const pitchDrop = barrelLength * pitchSin * 0.5;

  const endX = recoiledPivotX + cosR * effectiveBarrelLength;
  const endY = recoiledPivotY + sinR * effectiveBarrelLength * 0.5 + pitchDrop;

  const perpX = -sinR * barrelWidth * 0.5;
  const perpY = cosR * barrelWidth * 0.25;

  const lightSide = sinR < 0;
  const taperMult = 0.6;

  // Barrel housing at base
  ctx.fillStyle = "#4a4a52";
  const housingSize = barrelWidth * 0.8;
  ctx.beginPath();
  ctx.ellipse(
    recoiledPivotX,
    recoiledPivotY,
    housingSize,
    housingSize * 0.5,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Main heavy barrel
  const barrelGrad = ctx.createLinearGradient(
    recoiledPivotX + perpX,
    recoiledPivotY + perpY,
    recoiledPivotX - perpX,
    recoiledPivotY - perpY
  );
  if (lightSide) {
    barrelGrad.addColorStop(0, "#7a7a82");
    barrelGrad.addColorStop(0.3, "#6a6a72");
    barrelGrad.addColorStop(1, "#4a4a52");
  } else {
    barrelGrad.addColorStop(0, "#5a5a62");
    barrelGrad.addColorStop(0.5, "#6a6a72");
    barrelGrad.addColorStop(1, "#5a5a62");
  }

  ctx.fillStyle = barrelGrad;
  ctx.beginPath();
  ctx.moveTo(recoiledPivotX + perpX, recoiledPivotY + perpY);
  ctx.lineTo(endX + perpX * taperMult, endY + perpY * taperMult);
  ctx.lineTo(endX - perpX * taperMult, endY - perpY * taperMult);
  ctx.lineTo(recoiledPivotX - perpX, recoiledPivotY - perpY);
  ctx.closePath();
  ctx.fill();

  // Stabilizer fins (scaled for isometric and pitch)
  if (foreshorten > 0.3) {
    ctx.fillStyle = "#4a4a52";
    const finStart = 0.4;
    const finEnd = 0.75;
    const finPeak = 0.6;

    const fs1x = recoiledPivotX + cosR * effectiveBarrelLength * finStart;
    const fs1y =
      recoiledPivotY +
      sinR * effectiveBarrelLength * finStart * 0.5 +
      pitchDrop * finStart;
    const fp1x = recoiledPivotX + cosR * effectiveBarrelLength * finPeak;
    const fp1y =
      recoiledPivotY +
      sinR * effectiveBarrelLength * finPeak * 0.5 +
      pitchDrop * finPeak -
      barrelWidth * 0.4;
    const fe1x = recoiledPivotX + cosR * effectiveBarrelLength * finEnd;
    const fe1y =
      recoiledPivotY +
      sinR * effectiveBarrelLength * finEnd * 0.5 +
      pitchDrop * finEnd;

    ctx.beginPath();
    ctx.moveTo(fs1x + perpX * 0.5, fs1y + perpY * 0.5);
    ctx.lineTo(fp1x + perpX * 0.8, fp1y);
    ctx.lineTo(fe1x + perpX * 0.5, fe1y + perpY * 0.5);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(fs1x - perpX * 0.5, fs1y - perpY * 0.5);
    ctx.lineTo(
      fp1x - perpX * 0.8,
      recoiledPivotY +
        sinR * effectiveBarrelLength * finPeak * 0.5 +
        pitchDrop * finPeak +
        barrelWidth * 0.4
    );
    ctx.lineTo(fe1x - perpX * 0.5, fe1y - perpY * 0.5);
    ctx.closePath();
    ctx.fill();
  }

  // Heavy reinforcement bands
  ctx.strokeStyle = "#8a8a92";
  ctx.lineWidth = 3.5 * zoom;
  for (let i = 0; i < 4; i++) {
    const t = 0.15 + i * 0.2;
    const bx = recoiledPivotX + cosR * effectiveBarrelLength * t;
    const by =
      recoiledPivotY + sinR * effectiveBarrelLength * t * 0.5 + pitchDrop * t;
    const widthMult = 1 - t * 0.35;
    ctx.beginPath();
    ctx.moveTo(bx + perpX * widthMult, by + perpY * widthMult);
    ctx.lineTo(bx - perpX * widthMult, by - perpY * widthMult);
    ctx.stroke();
  }

  // Energy conduits
  const conduitGlow = 0.6 + Math.sin(time * 6) * 0.3;
  ctx.strokeStyle = `rgba(255, 120, 0, ${conduitGlow})`;
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(recoiledPivotX + perpX * 0.25, recoiledPivotY + perpY * 0.25);
  ctx.lineTo(endX + perpX * 0.15 * taperMult, endY + perpY * 0.15 * taperMult);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(recoiledPivotX - perpX * 0.25, recoiledPivotY - perpY * 0.25);
  ctx.lineTo(endX - perpX * 0.15 * taperMult, endY - perpY * 0.15 * taperMult);
  ctx.stroke();

  // Heavy muzzle brake
  ctx.fillStyle = "#3a3a42";
  const muzzleStart = 0.82;
  const msx = recoiledPivotX + cosR * effectiveBarrelLength * muzzleStart;
  const msy =
    recoiledPivotY +
    sinR * effectiveBarrelLength * muzzleStart * 0.5 +
    pitchDrop * muzzleStart;
  ctx.beginPath();
  ctx.moveTo(msx + perpX * taperMult, msy + perpY * taperMult);
  ctx.lineTo(endX + perpX * taperMult * 1.2, endY + perpY * taperMult * 1.2);
  ctx.lineTo(endX - perpX * taperMult * 1.2, endY - perpY * taperMult * 1.2);
  ctx.lineTo(msx - perpX * taperMult, msy - perpY * taperMult);
  ctx.closePath();
  ctx.fill();

  // Muzzle vents
  ctx.fillStyle = "#2a2a32";
  for (let i = 0; i < 2; i++) {
    const vt = 0.88 + i * 0.06;
    const vx = recoiledPivotX + cosR * effectiveBarrelLength * vt;
    const vy =
      recoiledPivotY + sinR * effectiveBarrelLength * vt * 0.5 + pitchDrop * vt;
    ctx.beginPath();
    ctx.moveTo(vx + perpX * taperMult * 1.1, vy + perpY * taperMult * 1.1);
    ctx.lineTo(vx - perpX * taperMult * 1.1, vy - perpY * taperMult * 1.1);
    ctx.lineWidth = 2 * zoom;
    ctx.stroke();
  }

  // Muzzle bore - angled for pitch
  ctx.fillStyle = "#1a1a1a";
  ctx.beginPath();
  ctx.ellipse(
    endX + cosR * 3 * zoom,
    endY + sinR * 1.5 * zoom + pitchSin * 3 * zoom,
    barrelWidth * 0.18 * foreshorten * pitchCos + barrelWidth * 0.08,
    barrelWidth * 0.12,
    rotation,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Enhanced muzzle flash
  if (timeSinceFire < 200) {
    const flash = 1 - timeSinceFire / 200;
    const flashX = endX + cosR * 12 * zoom;
    const flashY = endY + sinR * 6 * zoom + pitchDrop * 0.15;
    const flashGrad = ctx.createRadialGradient(
      flashX,
      flashY,
      0,
      flashX,
      flashY,
      40 * zoom * flash
    );
    flashGrad.addColorStop(0, `rgba(255, 255, 200, ${flash})`);
    flashGrad.addColorStop(0.15, `rgba(255, 220, 100, ${flash * 0.95})`);
    flashGrad.addColorStop(0.4, `rgba(200, 120, 0, ${flash * 0.7})`);
    flashGrad.addColorStop(0.7, `rgba(255, 80, 0, ${flash * 0.4})`);
    flashGrad.addColorStop(1, `rgba(255, 30, 0, 0)`);
    ctx.fillStyle = flashGrad;
    ctx.beginPath();
    ctx.arc(flashX, flashY, 40 * zoom * flash, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = `rgba(255, 255, 255, ${flash})`;
    ctx.beginPath();
    ctx.arc(flashX, flashY, 10 * zoom * flash, 0, Math.PI * 2);
    ctx.fill();
  }
}

function renderGatlingGun(
  ctx: CanvasRenderingContext2D,
  screenPos: Position,
  topY: number,
  tower: Tower,
  zoom: number,
  time: number
) {
  const rotation = tower.rotation || 0;
  const spinAngle = time * 30;
  const timeSinceFire = Date.now() - tower.lastAttack;
  const isAttacking = timeSinceFire < 100;
  const attackPulse = isAttacking ? 1 - timeSinceFire / 100 : 0;

  const cosR = Math.cos(rotation);
  const sinR = Math.sin(rotation);
  const foreshorten = Math.abs(cosR);
  const facingAway = sinR < -0.3;

  // Recoil animation
  let recoilOffset = 0;
  let turretShake = 0;

  if (timeSinceFire < 150) {
    const firePhase = timeSinceFire / 150;
    if (firePhase < 0.2) {
      recoilOffset = (firePhase / 0.2) * 6 * zoom;
      turretShake = Math.sin(firePhase * Math.PI * 20) * 2 * zoom;
    } else {
      const returnPhase = (firePhase - 0.2) / 0.8;
      recoilOffset = 6 * zoom * (1 - returnPhase);
      turretShake =
        Math.sin(returnPhase * Math.PI * 8) * (1 - returnPhase) * 1.5 * zoom;
    }
  }

  const shakeX = turretShake * cosR;
  const shakeY = turretShake * sinR * 0.5;
  const turretX = screenPos.x + shakeX;
  const turretY = topY + shakeY;

  // === MASSIVE ARMORED BASE ===
  ctx.fillStyle = "#1a1a22";
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY + 2 * zoom,
    26 * zoom,
    13 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  ctx.fillStyle = "#2a2a32";
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 2 * zoom,
    22 * zoom,
    11 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  ctx.fillStyle = "#5a5a62";
  for (let i = 0; i < 16; i++) {
    const toothAngle = rotation + (i / 16) * Math.PI * 2;
    const toothX = turretX + Math.cos(toothAngle) * 21 * zoom;
    const toothY = turretY - 2 * zoom + Math.sin(toothAngle) * 10.5 * zoom;
    ctx.beginPath();
    ctx.arc(toothX, toothY, 2.5 * zoom, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.fillStyle = "#3a3a42";
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 4 * zoom,
    20 * zoom,
    10 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Glowing ammunition indicators
  for (let i = 0; i < 6; i++) {
    const angle = rotation + (i / 6) * Math.PI * 2;
    const indicatorX = turretX + Math.cos(angle) * 18 * zoom;
    const indicatorY = turretY - 3 * zoom + Math.sin(angle) * 9 * zoom;
    const glow = 0.4 + Math.sin(time * 8 + i * 0.5) * 0.3 + attackPulse * 0.3;

    ctx.fillStyle = `rgba(255, 180, 50, ${glow})`;
    ctx.beginPath();
    ctx.arc(indicatorX, indicatorY, 2 * zoom, 0, Math.PI * 2);
    ctx.fill();
  }

  if (facingAway) {
    drawGatlingBarrels(
      ctx,
      turretX,
      turretY - 14 * zoom,
      rotation,
      foreshorten,
      spinAngle,
      zoom,
      tower,
      time,
      recoilOffset
    );
  }

  // === HEAVY GUN SHIELD ===
  const shieldGrad = ctx.createLinearGradient(
    turretX - 20 * zoom,
    turretY - 6 * zoom,
    turretX + 20 * zoom,
    turretY - 28 * zoom
  );
  shieldGrad.addColorStop(0, "#3a3a42");
  shieldGrad.addColorStop(0.2, "#5a5a62");
  shieldGrad.addColorStop(0.5, "#6a6a72");
  shieldGrad.addColorStop(0.8, "#5a5a62");
  shieldGrad.addColorStop(1, "#2a2a32");
  ctx.fillStyle = shieldGrad;
  ctx.beginPath();
  ctx.moveTo(turretX - 18 * zoom, turretY - 4 * zoom);
  ctx.lineTo(turretX - 14 * zoom, turretY - 26 * zoom);
  ctx.lineTo(turretX + 14 * zoom, turretY - 26 * zoom);
  ctx.lineTo(turretX + 18 * zoom, turretY - 4 * zoom);
  ctx.closePath();
  ctx.fill();

  // Shield battle damage marks
  ctx.strokeStyle = "#4a4a52";
  ctx.lineWidth = 1 * zoom;
  for (let i = 0; i < 3; i++) {
    const markX = turretX + (i - 1) * 8 * zoom;
    const markY = turretY - 12 * zoom - i * 4 * zoom;
    ctx.beginPath();
    ctx.moveTo(markX - 3 * zoom, markY - 2 * zoom);
    ctx.lineTo(markX + 2 * zoom, markY + 3 * zoom);
    ctx.stroke();
  }

  ctx.strokeStyle = "#7a7a82";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(turretX - 14 * zoom, turretY - 26 * zoom);
  ctx.lineTo(turretX + 14 * zoom, turretY - 26 * zoom);
  ctx.stroke();

  // Skull emblem on shield
  ctx.fillStyle = "#1a1a22";
  ctx.beginPath();
  ctx.arc(turretX, turretY - 15 * zoom, 6 * zoom, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = `rgba(255, 100, 50, ${0.5 + attackPulse * 0.5})`;
  ctx.beginPath();
  ctx.arc(turretX - 2 * zoom, turretY - 16 * zoom, 1.5 * zoom, 0, Math.PI * 2);
  ctx.arc(turretX + 2 * zoom, turretY - 16 * zoom, 1.5 * zoom, 0, Math.PI * 2);
  ctx.fill();

  // Shield tech panels
  ctx.strokeStyle = "#5a5a62";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(turretX - 10 * zoom, turretY - 8 * zoom);
  ctx.lineTo(turretX - 8 * zoom, turretY - 22 * zoom);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(turretX + 10 * zoom, turretY - 8 * zoom);
  ctx.lineTo(turretX + 8 * zoom, turretY - 22 * zoom);
  ctx.stroke();

  // Heavy rivets
  ctx.fillStyle = "#8a8a92";
  for (let row = 0; row < 2; row++) {
    for (let i = -1; i <= 1; i += 2) {
      ctx.beginPath();
      ctx.arc(
        turretX + i * 11 * zoom,
        turretY - 10 * zoom - row * 8 * zoom,
        2.5 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }
  }

  // === CENTRAL TURRET MECHANISM ===
  const turretGrad = ctx.createRadialGradient(
    turretX - 3 * zoom,
    turretY - 18 * zoom,
    0,
    turretX,
    turretY - 14 * zoom,
    16 * zoom
  );
  turretGrad.addColorStop(0, "#7a7a82");
  turretGrad.addColorStop(0.5, "#5a5a62");
  turretGrad.addColorStop(1, "#3a3a42");
  ctx.fillStyle = turretGrad;
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 14 * zoom,
    14 * zoom,
    12 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // ROTATING ARMOR PLATES
  for (let i = 0; i < 8; i++) {
    const plateAngle = rotation + (i / 8) * Math.PI * 2;
    const plateVisible = Math.cos(plateAngle - rotation);

    if (plateVisible > -0.3) {
      const shade = 0.5 + plateVisible * 0.35;
      const innerR = 6 * zoom;
      const outerR = 13 * zoom;
      const plateX1 = turretX + Math.cos(plateAngle) * innerR;
      const plateY1 = turretY - 14 * zoom + Math.sin(plateAngle) * innerR * 0.8;
      const plateX2 = turretX + Math.cos(plateAngle) * outerR;
      const plateY2 = turretY - 14 * zoom + Math.sin(plateAngle) * outerR * 0.8;

      ctx.strokeStyle = `rgba(120, 120, 130, ${shade})`;
      ctx.lineWidth = 2.5 * zoom;
      ctx.beginPath();
      ctx.moveTo(plateX1, plateY1);
      ctx.lineTo(plateX2, plateY2);
      ctx.stroke();

      ctx.fillStyle = `rgba(90, 90, 100, ${shade})`;
      ctx.beginPath();
      ctx.arc(plateX2, plateY2, 2 * zoom, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Ammunition belt feed
  ctx.fillStyle = "#3a3a42";
  ctx.beginPath();
  ctx.moveTo(turretX - 8 * zoom, turretY - 6 * zoom);
  ctx.lineTo(turretX - 14 * zoom, turretY);
  ctx.lineTo(turretX - 10 * zoom, turretY + 2 * zoom);
  ctx.lineTo(turretX - 4 * zoom, turretY - 4 * zoom);
  ctx.closePath();
  ctx.fill();

  // Ammo belt bullets
  ctx.fillStyle = "#daa520";
  for (let i = 0; i < 4; i++) {
    const bulletX = turretX - 6 * zoom - i * 2.5 * zoom;
    const bulletY = turretY - 4 * zoom + i * 1.5 * zoom;
    ctx.beginPath();
    ctx.ellipse(bulletX, bulletY, 1.5 * zoom, 2.5 * zoom, 0.3, 0, Math.PI * 2);
    ctx.fill();
  }

  // === POWER CORE ===
  ctx.fillStyle = "#1a1a22";
  ctx.beginPath();
  ctx.arc(turretX, turretY - 14 * zoom, 7 * zoom, 0, Math.PI * 2);
  ctx.fill();

  const coreGlow = 0.7 + Math.sin(time * 10) * 0.3 + attackPulse * 0.3;
  const coreGrad = ctx.createRadialGradient(
    turretX,
    turretY - 14 * zoom,
    0,
    turretX,
    turretY - 14 * zoom,
    6 * zoom
  );
  coreGrad.addColorStop(0, `rgba(255, 240, 150, ${coreGlow})`);
  coreGrad.addColorStop(0.3, `rgba(255, 200, 80, ${coreGlow * 0.8})`);
  coreGrad.addColorStop(0.6, `rgba(255, 150, 30, ${coreGlow * 0.5})`);
  coreGrad.addColorStop(1, `rgba(255, 80, 0, 0)`);

  ctx.shadowColor = "#ff8800";
  ctx.shadowBlur = (10 + attackPulse * 10) * zoom;
  ctx.fillStyle = coreGrad;
  ctx.beginPath();
  ctx.arc(turretX, turretY - 14 * zoom, 6 * zoom, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Spinning core indicator
  ctx.strokeStyle = `rgba(255, 200, 100, ${coreGlow})`;
  ctx.lineWidth = 1.5 * zoom;
  for (let i = 0; i < 4; i++) {
    const indicatorAngle = spinAngle * 0.2 + (i / 4) * Math.PI * 2;
    ctx.beginPath();
    ctx.arc(
      turretX,
      turretY - 14 * zoom,
      4 * zoom,
      indicatorAngle,
      indicatorAngle + 0.3
    );
    ctx.stroke();
  }

  if (!facingAway) {
    drawGatlingBarrels(
      ctx,
      turretX,
      turretY - 14 * zoom,
      rotation,
      foreshorten,
      spinAngle,
      zoom,
      tower,
      time,
      recoilOffset
    );
  }

  // === HEAT VENTS ===
  if (isAttacking) {
    for (let i = 0; i < 3; i++) {
      const ventX = turretX + (i - 1) * 8 * zoom;
      const ventY = turretY - 24 * zoom - Math.random() * 5 * zoom;
      const ventAlpha = attackPulse * (0.3 + Math.random() * 0.2);

      ctx.fillStyle = `rgba(255, 150, 50, ${ventAlpha})`;
      ctx.beginPath();
      ctx.ellipse(ventX, ventY, 3 * zoom, 6 * zoom, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// Helper for gatling barrel cluster with pitch
function drawGatlingBarrels(
  ctx: CanvasRenderingContext2D,
  pivotX: number,
  pivotY: number,
  rotation: number,
  foreshorten: number,
  spinAngle: number,
  zoom: number,
  tower: Tower,
  time: number,
  recoilOffset: number = 0
) {
  const cosR = Math.cos(rotation);
  const sinR = Math.sin(rotation);
  const timeSinceFire = Date.now() - tower.lastAttack;
  const isAttacking = timeSinceFire < 80;

  // Calculate pitch
  const towerElevation = 30 * zoom;
  const baseLength = 42 * zoom;
  const pitch = calculateBarrelPitch(towerElevation, baseLength);
  const pitchCos = Math.cos(pitch);
  const pitchSin = Math.sin(pitch);

  const barrelLength =
    (baseLength * (0.5 + foreshorten * 0.5) - recoilOffset) * pitchCos;
  const pitchDrop = baseLength * (0.5 + foreshorten * 0.5) * pitchSin * 0.5;

  const endX = pivotX + cosR * barrelLength;
  const endY = pivotY + sinR * barrelLength * 0.5 + pitchDrop;

  // === ANGULAR BARREL HOUSING ===
  const housingOffset = (10 * zoom - recoilOffset * 0.3) * pitchCos;
  const housingPitchDrop = (10 * zoom - recoilOffset * 0.3) * pitchSin * 0.3;
  const housingCenterX = pivotX + cosR * housingOffset;
  const housingCenterY = pivotY + sinR * housingOffset * 0.5 + housingPitchDrop;

  const housingGrad = ctx.createLinearGradient(
    housingCenterX - 12 * zoom,
    housingCenterY - 10 * zoom,
    housingCenterX + 8 * zoom,
    housingCenterY + 10 * zoom
  );
  housingGrad.addColorStop(0, "#5a5a62");
  housingGrad.addColorStop(0.3, "#7a7a82");
  housingGrad.addColorStop(0.5, "#8a8a92");
  housingGrad.addColorStop(0.7, "#6a6a72");
  housingGrad.addColorStop(1, "#3a3a42");
  ctx.fillStyle = housingGrad;

  ctx.beginPath();
  const hexRadius = 11 * zoom;
  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2 - Math.PI / 6;
    const hx = housingCenterX + Math.cos(angle) * hexRadius;
    const hy = housingCenterY + Math.sin(angle) * hexRadius * 0.7;
    if (i === 0) ctx.moveTo(hx, hy);
    else ctx.lineTo(hx, hy);
  }
  ctx.closePath();
  ctx.fill();

  ctx.strokeStyle = "#9a9aa2";
  ctx.lineWidth = 2 * zoom;
  ctx.stroke();

  // Armored face plates
  ctx.fillStyle = "#4a4a52";
  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2 - Math.PI / 6;
    const nextAngle = ((i + 1) / 6) * Math.PI * 2 - Math.PI / 6;
    ctx.beginPath();
    ctx.moveTo(housingCenterX, housingCenterY);
    ctx.lineTo(
      housingCenterX + Math.cos(angle) * hexRadius * 0.9,
      housingCenterY + Math.sin(angle) * hexRadius * 0.7 * 0.9
    );
    ctx.lineTo(
      housingCenterX + Math.cos(nextAngle) * hexRadius * 0.9,
      housingCenterY + Math.sin(nextAngle) * hexRadius * 0.7 * 0.9
    );
    ctx.closePath();
    if (i % 2 === 0) ctx.fill();
  }

  ctx.fillStyle = "#2a2a32";
  ctx.beginPath();
  ctx.arc(housingCenterX, housingCenterY, 5 * zoom, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = `rgba(255, 180, 50, ${
    0.6 + Math.sin(spinAngle * 0.5) * 0.3
  })`;
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.arc(
    housingCenterX,
    housingCenterY,
    4 * zoom,
    spinAngle,
    spinAngle + Math.PI
  );
  ctx.stroke();

  // === 8 SPINNING BARRELS with pitch ===
  for (let i = 0; i < 8; i++) {
    const barrelAngle = spinAngle + (i / 8) * Math.PI * 2;
    const barrelDepth = Math.cos(barrelAngle);
    const barrelOffset = Math.sin(barrelAngle) * 6 * zoom;

    if (barrelDepth > -0.6) {
      const shade = 0.3 + barrelDepth * 0.4;
      const barrelColor = Math.floor(50 + shade * 60);

      const perpX = -sinR * barrelOffset;
      const perpY = cosR * barrelOffset * 0.5;

      const bStartX =
        pivotX + cosR * ((10 * zoom - recoilOffset * 0.3) * pitchCos) + perpX;
      const bStartY =
        pivotY +
        sinR * ((5 * zoom - recoilOffset * 0.15) * pitchCos) +
        perpY +
        housingPitchDrop;
      const bEndX = endX + perpX * 0.75;
      const bEndY = endY + perpY * 0.75;

      const bw = 3 * zoom;
      const perpBX = -sinR * bw;
      const perpBY = cosR * bw * 0.5;

      const barrelGrad = ctx.createLinearGradient(
        bStartX,
        bStartY,
        bEndX,
        bEndY
      );
      barrelGrad.addColorStop(
        0,
        `rgb(${barrelColor + 20}, ${barrelColor + 20}, ${barrelColor + 28})`
      );
      barrelGrad.addColorStop(
        0.5,
        `rgb(${barrelColor}, ${barrelColor}, ${barrelColor + 8})`
      );
      barrelGrad.addColorStop(
        1,
        `rgb(${barrelColor - 10}, ${barrelColor - 10}, ${barrelColor})`
      );
      ctx.fillStyle = barrelGrad;

      ctx.beginPath();
      ctx.moveTo(bStartX + perpBX, bStartY + perpBY);
      ctx.lineTo(bEndX + perpBX * 0.6, bEndY + perpBY * 0.6);
      ctx.lineTo(bEndX - perpBX * 0.6, bEndY - perpBY * 0.6);
      ctx.lineTo(bStartX - perpBX, bStartY - perpBY);
      ctx.closePath();
      ctx.fill();

      if (barrelDepth > 0.2) {
        ctx.strokeStyle = `rgba(90, 90, 100, ${shade})`;
        ctx.lineWidth = 0.5 * zoom;
        ctx.beginPath();
        ctx.moveTo(bStartX, bStartY);
        ctx.lineTo(bEndX, bEndY);
        ctx.stroke();
      }

      if (barrelDepth > 0.2) {
        ctx.fillStyle = "#0a0a0a";
        ctx.beginPath();
        ctx.arc(
          bEndX,
          bEndY,
          2 * zoom * foreshorten + 0.5 * zoom,
          0,
          Math.PI * 2
        );
        ctx.fill();

        if (isAttacking) {
          ctx.fillStyle = `rgba(255, 150, 50, ${
            0.5 * (1 - timeSinceFire / 80)
          })`;
          ctx.beginPath();
          ctx.arc(
            bEndX,
            bEndY,
            1.5 * zoom * foreshorten + 0.3 * zoom,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
      }
    }
  }

  // === FRONT BARREL PLATE ===
  const plateX = endX - cosR * 5 * zoom * pitchCos;
  const plateY = endY - sinR * 2.5 * zoom;

  const plateGrad = ctx.createRadialGradient(
    plateX - 2 * zoom,
    plateY - 1 * zoom,
    0,
    plateX,
    plateY,
    12 * zoom
  );
  plateGrad.addColorStop(0, "#8a8a92");
  plateGrad.addColorStop(0.5, "#6a6a72");
  plateGrad.addColorStop(1, "#4a4a52");
  ctx.fillStyle = plateGrad;

  ctx.beginPath();
  const plateRadius = 9 * zoom * (0.6 + foreshorten * 0.4);
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2 + rotation;
    const px = plateX + Math.cos(angle) * plateRadius;
    const py = plateY + Math.sin(angle) * plateRadius * 0.6;
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fill();

  ctx.strokeStyle = "#9a9aa2";
  ctx.lineWidth = 1.5 * zoom;
  ctx.stroke();

  // Barrel holes
  for (let i = 0; i < 8; i++) {
    const holeAngle = spinAngle + (i / 8) * Math.PI * 2;
    const holeDepth = Math.cos(holeAngle);
    if (holeDepth > 0) {
      const holeR = 5 * zoom * (0.5 + foreshorten * 0.5);
      const holeX = plateX + Math.cos(holeAngle + rotation) * holeR;
      const holeY = plateY + Math.sin(holeAngle + rotation) * holeR * 0.5;
      ctx.fillStyle = "#1a1a1a";
      ctx.beginPath();
      ctx.arc(holeX, holeY, 2 * zoom * foreshorten, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.fillStyle = "#2a2a32";
  ctx.beginPath();
  ctx.arc(plateX, plateY, 3 * zoom, 0, Math.PI * 2);
  ctx.fill();

  // === MUZZLE FLASH ===
  if (isAttacking) {
    const flash = 1 - timeSinceFire / 80;
    const flashX = endX + cosR * 8 * zoom;
    const flashY = endY + sinR * 4 * zoom + pitchDrop * 0.1;

    ctx.shadowColor = "#ffaa00";
    ctx.shadowBlur = 20 * zoom;

    const flashGrad = ctx.createRadialGradient(
      flashX,
      flashY,
      0,
      flashX,
      flashY,
      18 * zoom * flash
    );
    flashGrad.addColorStop(0, `rgba(255, 255, 220, ${flash})`);
    flashGrad.addColorStop(0.2, `rgba(255, 240, 150, ${flash * 0.9})`);
    flashGrad.addColorStop(0.5, `rgba(255, 180, 80, ${flash * 0.6})`);
    flashGrad.addColorStop(1, `rgba(200, 80, 0, 0)`);
    ctx.fillStyle = flashGrad;
    ctx.beginPath();
    ctx.arc(flashX, flashY, 18 * zoom * flash, 0, Math.PI * 2);
    ctx.fill();

    for (let i = 0; i < 6; i++) {
      const streakAngle = rotation + (Math.random() - 0.5) * 0.8;
      const streakLen = (10 + Math.random() * 15) * zoom * flash;
      ctx.strokeStyle = `rgba(255, 220, 100, ${flash * 0.7})`;
      ctx.lineWidth = 2 * zoom * flash;
      ctx.beginPath();
      ctx.moveTo(flashX, flashY);
      ctx.lineTo(
        flashX + Math.cos(streakAngle) * streakLen,
        flashY + Math.sin(streakAngle) * streakLen * 0.5 + pitchDrop * 0.05
      );
      ctx.stroke();
    }

    ctx.shadowBlur = 0;
  }

  // === SMOKE WISPS ===
  if (timeSinceFire > 60 && timeSinceFire < 300) {
    const smokePhase = (timeSinceFire - 60) / 240;
    for (let i = 0; i < 3; i++) {
      const smokeX =
        endX +
        cosR * (5 + smokePhase * 10) * zoom +
        (Math.random() - 0.5) * 8 * zoom;
      const smokeY = endY - smokePhase * 15 * zoom - i * 4 * zoom;
      const smokeAlpha = (1 - smokePhase) * 0.3;

      ctx.fillStyle = `rgba(100, 100, 110, ${smokeAlpha})`;
      ctx.beginPath();
      ctx.arc(smokeX, smokeY, (3 + smokePhase * 4) * zoom, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

function renderFlamethrower(
  ctx: CanvasRenderingContext2D,
  screenPos: Position,
  topY: number,
  tower: Tower,
  zoom: number,
  time: number
) {
  const rotation = tower.rotation || 0;

  const cosR = Math.cos(rotation);
  const sinR = Math.sin(rotation);
  const foreshorten = Math.abs(cosR);
  const facingAway = sinR < -0.3;

  const timeSinceFire = Date.now() - tower.lastAttack;
  let recoilOffset = 0;
  let turretShake = 0;

  if (timeSinceFire < 300) {
    const firePhase = timeSinceFire / 300;
    if (firePhase < 0.1) {
      recoilOffset = (firePhase / 0.1) * 5 * zoom;
      turretShake = Math.sin(firePhase * Math.PI * 12) * 1.5 * zoom;
    } else {
      const returnPhase = (firePhase - 0.1) / 0.9;
      recoilOffset = 5 * zoom * (1 - returnPhase);
      turretShake =
        Math.sin(returnPhase * Math.PI * 3) * (1 - returnPhase) * zoom;
    }
  }

  const shakeX = turretShake * cosR;
  const shakeY = turretShake * sinR * 0.5;
  const turretX = screenPos.x + shakeX;
  const turretY = topY + shakeY;

  // Armored base platform
  ctx.fillStyle = "#2a2a32";
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 2 * zoom,
    20 * zoom,
    10 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  ctx.fillStyle = "#3a3a42";
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 4 * zoom,
    18 * zoom,
    9 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  ctx.fillStyle = "#5a5a62";
  for (let i = 0; i < 16; i++) {
    const toothAngle = rotation + (i / 16) * Math.PI * 2;
    const toothX = turretX + Math.cos(toothAngle) * 21 * zoom;
    const toothY = turretY - 2 * zoom + Math.sin(toothAngle) * 10.5 * zoom;
    ctx.beginPath();
    ctx.arc(toothX, toothY, 2.5 * zoom, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.fillStyle = "#3a3a42";
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 4 * zoom,
    20 * zoom,
    10 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  if (facingAway) {
    drawFlamethrowerNozzle(
      ctx,
      turretX,
      turretY - 10 * zoom,
      rotation,
      foreshorten,
      zoom,
      tower,
      time,
      recoilOffset
    );
  }

  // Main fuel tank
  const tankGrad = ctx.createLinearGradient(
    turretX - 12 * zoom,
    turretY - 24 * zoom,
    turretX + 4 * zoom,
    turretY
  );
  tankGrad.addColorStop(0, "#cc3030");
  tankGrad.addColorStop(0.2, "#aa2020");
  tankGrad.addColorStop(0.5, "#881515");
  tankGrad.addColorStop(0.8, "#661010");
  tankGrad.addColorStop(1, "#440808");
  ctx.fillStyle = tankGrad;
  ctx.beginPath();
  ctx.ellipse(
    turretX - 6 * zoom,
    turretY - 12 * zoom,
    9 * zoom,
    14 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Tank highlights
  ctx.strokeStyle = "#dd4040";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.ellipse(
    turretX - 8 * zoom,
    turretY - 12 * zoom,
    2 * zoom,
    10 * zoom,
    0,
    -0.3,
    0.3
  );
  ctx.stroke();

  // Warning stripes
  ctx.strokeStyle = "#ffcc00";
  ctx.lineWidth = 2.5 * zoom;
  for (let i = 0; i < 3; i++) {
    const stripeY = turretY - 18 * zoom + i * 6 * zoom;
    ctx.beginPath();
    ctx.ellipse(
      turretX - 6 * zoom,
      stripeY,
      6 * zoom,
      9 * zoom,
      0,
      -0.35 * Math.PI,
      0.35 * Math.PI
    );
    ctx.stroke();
  }

  // Black hazard stripes
  ctx.strokeStyle = "#222";
  ctx.lineWidth = 1.5 * zoom;
  for (let i = 0; i < 2; i++) {
    const stripeY = turretY - 15 * zoom + i * 6 * zoom;
    ctx.beginPath();
    ctx.ellipse(
      turretX - 6 * zoom,
      stripeY,
      6 * zoom,
      9 * zoom,
      0,
      -0.35 * Math.PI,
      0.35 * Math.PI
    );
    ctx.stroke();
  }

  // Tank cap
  ctx.fillStyle = "#4a4a52";
  ctx.beginPath();
  ctx.ellipse(
    turretX - 6 * zoom,
    turretY - 26 * zoom,
    6 * zoom,
    3 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();
  ctx.fillStyle = "#5a5a62";
  ctx.beginPath();
  ctx.arc(turretX - 6 * zoom, turretY - 26 * zoom, 3 * zoom, 0, Math.PI * 2);
  ctx.fill();

  // Pressure gauge
  ctx.fillStyle = "#ddd";
  ctx.beginPath();
  ctx.arc(turretX + 2 * zoom, turretY - 6 * zoom, 5 * zoom, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#222";
  ctx.beginPath();
  ctx.arc(turretX + 2 * zoom, turretY - 6 * zoom, 4 * zoom, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = "#0f0";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.arc(
    turretX + 2 * zoom,
    turretY - 6 * zoom,
    3 * zoom,
    Math.PI * 0.8,
    Math.PI * 1.2
  );
  ctx.stroke();
  ctx.strokeStyle = "#f00";
  ctx.beginPath();
  ctx.arc(
    turretX + 2 * zoom,
    turretY - 6 * zoom,
    3 * zoom,
    Math.PI * 1.5,
    Math.PI * 1.8
  );
  ctx.stroke();

  const needleJump =
    timeSinceFire < 300 ? Math.sin(timeSinceFire * 0.05) * 0.2 : 0;
  const needleAngle = Math.PI * (0.9 + Math.sin(time * 2) * 0.15 + needleJump);
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(turretX + 2 * zoom, turretY - 6 * zoom);
  ctx.lineTo(
    turretX + 2 * zoom + Math.cos(needleAngle) * 3 * zoom,
    turretY - 6 * zoom + Math.sin(needleAngle) * 3 * zoom
  );
  ctx.stroke();

  // Secondary fuel tank
  ctx.fillStyle = "#884020";
  ctx.beginPath();
  ctx.ellipse(
    turretX + 8 * zoom,
    turretY - 10 * zoom,
    5 * zoom,
    8 * zoom,
    0.2,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Fuel lines
  ctx.strokeStyle = "#555";
  ctx.lineWidth = 3 * zoom;
  ctx.beginPath();
  ctx.moveTo(turretX - 2 * zoom, turretY - 8 * zoom);
  ctx.quadraticCurveTo(
    turretX + 4 * zoom,
    turretY - 14 * zoom,
    turretX + 6 * zoom,
    turretY - 10 * zoom
  );
  ctx.stroke();

  // Igniter housing
  ctx.fillStyle = "#4a4a52";
  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - 10 * zoom,
    8 * zoom,
    6 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  if (!facingAway) {
    drawFlamethrowerNozzle(
      ctx,
      turretX,
      turretY - 10 * zoom,
      rotation,
      foreshorten,
      zoom,
      tower,
      time,
      recoilOffset
    );
  }
}

// Helper for flamethrower nozzle with pitch
function drawFlamethrowerNozzle(
  ctx: CanvasRenderingContext2D,
  pivotX: number,
  pivotY: number,
  rotation: number,
  foreshorten: number,
  zoom: number,
  tower: Tower,
  time: number,
  recoilOffset: number = 0
) {
  const cosR = Math.cos(rotation);
  const sinR = Math.sin(rotation);

  // Calculate pitch
  const towerElevation = 25 * zoom;
  const baseLength = 35 * zoom;
  const pitch = calculateBarrelPitch(towerElevation, baseLength);
  const pitchCos = Math.cos(pitch);
  const pitchSin = Math.sin(pitch);

  const recoiledPivotX = pivotX - cosR * recoilOffset;
  const recoiledPivotY = pivotY - sinR * recoilOffset * 0.5;

  const nozzleLength = baseLength * (0.5 + foreshorten * 0.5) * pitchCos;
  const pitchDrop = baseLength * (0.5 + foreshorten * 0.5) * pitchSin * 0.5;

  const endX = recoiledPivotX + cosR * nozzleLength;
  const endY = recoiledPivotY + sinR * nozzleLength * 0.5 + pitchDrop;

  const perpX = -sinR * 5 * zoom;
  const perpY = cosR * 2.5 * zoom;

  // Fuel line
  ctx.strokeStyle = "#555";
  ctx.lineWidth = 3 * zoom;
  ctx.beginPath();
  ctx.moveTo(recoiledPivotX - 4 * zoom, recoiledPivotY);
  ctx.quadraticCurveTo(
    recoiledPivotX + cosR * 6 * zoom,
    recoiledPivotY + sinR * 3 * zoom - 4 * zoom,
    recoiledPivotX + cosR * 10 * zoom * pitchCos,
    recoiledPivotY + sinR * 5 * zoom + pitchDrop * 0.3
  );
  ctx.stroke();

  // Nozzle body
  const nozzleGrad = ctx.createLinearGradient(
    recoiledPivotX + perpX,
    recoiledPivotY + perpY,
    recoiledPivotX - perpX,
    recoiledPivotY - perpY
  );
  nozzleGrad.addColorStop(0, "#5a5a62");
  nozzleGrad.addColorStop(0.3, "#6a6a72");
  nozzleGrad.addColorStop(0.7, "#5a5a62");
  nozzleGrad.addColorStop(1, "#4a4a52");
  ctx.fillStyle = nozzleGrad;
  ctx.beginPath();
  ctx.moveTo(recoiledPivotX + perpX, recoiledPivotY + perpY);
  ctx.lineTo(endX + perpX * 0.7, endY + perpY * 0.7);
  ctx.lineTo(endX - perpX * 0.7, endY - perpY * 0.7);
  ctx.lineTo(recoiledPivotX - perpX, recoiledPivotY - perpY);
  ctx.closePath();
  ctx.fill();

  // Nozzle rings - adjusted for pitch
  ctx.strokeStyle = "#7a7a82";
  ctx.lineWidth = 2 * zoom;
  for (let i = 0; i < 3; i++) {
    const t = 0.3 + i * 0.2;
    const rx = recoiledPivotX + cosR * nozzleLength * t;
    const ry = recoiledPivotY + sinR * nozzleLength * t * 0.5 + pitchDrop * t;
    const ringMult = 1 - t * 0.3;
    ctx.beginPath();
    ctx.moveTo(rx + perpX * ringMult, ry + perpY * ringMult);
    ctx.lineTo(rx - perpX * ringMult, ry - perpY * ringMult);
    ctx.stroke();
  }

  // Flared nozzle tip
  ctx.fillStyle = "#3a3a42";
  const tipStart = 0.8;
  const tsx = recoiledPivotX + cosR * nozzleLength * tipStart;
  const tsy =
    recoiledPivotY +
    sinR * nozzleLength * tipStart * 0.5 +
    pitchDrop * tipStart;
  ctx.beginPath();
  ctx.moveTo(tsx + perpX * 0.7, tsy + perpY * 0.7);
  ctx.lineTo(endX + perpX * 1.4, endY + perpY * 1.4);
  ctx.lineTo(endX - perpX * 1.4, endY - perpY * 1.4);
  ctx.lineTo(tsx - perpX * 0.7, tsy - perpY * 0.7);
  ctx.closePath();
  ctx.fill();

  // Pilot light
  const pilotGlow = 0.7 + Math.sin(time * 10) * 0.3;
  ctx.fillStyle = `rgba(0, 180, 255, ${pilotGlow})`;
  ctx.shadowColor = "#00aaff";
  ctx.shadowBlur = 4 * zoom;
  const pilotX = endX - cosR * 6 * zoom * pitchCos + perpX * 0.5;
  const pilotY = endY - sinR * 3 * zoom + perpY * 0.5;
  ctx.beginPath();
  ctx.arc(pilotX, pilotY, 2.5 * zoom, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Flame effect - follows pitched direction
  const timeSinceFire = Date.now() - tower.lastAttack;
  if (timeSinceFire < 500) {
    const flameIntensity = 1 - timeSinceFire / 500;
    ctx.shadowColor = "#ff4400";
    ctx.shadowBlur = 25 * zoom * flameIntensity;

    for (let i = 0; i < 10; i++) {
      const flameT = 1 + i * 0.12;
      const flameX = recoiledPivotX + cosR * nozzleLength * flameT;
      const flameY =
        recoiledPivotY +
        sinR * nozzleLength * flameT * 0.5 +
        pitchDrop * flameT;
      const wobble = Math.sin(time * 35 + i * 0.8) * (2 + i * 0.4) * zoom;
      const flameSize = (16 - i * 1.2) * zoom * flameIntensity;

      const flameGrad = ctx.createRadialGradient(
        flameX,
        flameY + wobble,
        0,
        flameX,
        flameY + wobble,
        flameSize
      );
      flameGrad.addColorStop(0, `rgba(255, 255, 180, ${flameIntensity})`);
      flameGrad.addColorStop(
        0.15,
        `rgba(255, 220, 80, ${flameIntensity * 0.95})`
      );
      flameGrad.addColorStop(
        0.4,
        `rgba(255, 120, 0, ${flameIntensity * 0.75})`
      );
      flameGrad.addColorStop(0.7, `rgba(220, 60, 0, ${flameIntensity * 0.45})`);
      flameGrad.addColorStop(1, "rgba(120, 30, 0, 0)");
      ctx.fillStyle = flameGrad;
      ctx.beginPath();
      ctx.arc(flameX, flameY + wobble, flameSize, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.shadowBlur = 0;
  }
}

// LIBRARY TOWER - Enhanced Gothic design
function renderLibraryTower(
  ctx: CanvasRenderingContext2D,
  screenPos: Position,
  tower: Tower,
  zoom: number,
  time: number,
  colors: { base: string; dark: string; light: string; accent: string }
) {
  ctx.save();
  const baseWidth = 34 + tower.level * 5;
  const baseHeight = 30 + tower.level * 10;
  const w = baseWidth * zoom * 0.5;
  const d = baseWidth * zoom * 0.25;
  const h = baseHeight * zoom;

  let mainColor = "rgba(180, 100, 255,";

  if (tower.level > 3 && tower.upgrade === "A") {
    // maincolor is orangeish
    mainColor = "rgba(255, 150, 100,";
  } else if (tower.level > 3 && tower.upgrade === "B") {
    // maincolor is lightblue
    mainColor = "rgba(100, 150, 255,";
  }

  // Attack animation - piston mechanism (top part slams down into base)
  const timeSinceFire = Date.now() - tower.lastAttack;
  let attackPulse = 0;
  let pistonOffset = 0; // Only affects top portion
  let groundShockwave = 0;
  let groundCrackPhase = 0;
  let impactFlash = 0;

  if (timeSinceFire < 500) {
    const attackPhase = timeSinceFire / 500;
    attackPulse = (1 - attackPhase) * 0.4;

    // Piston animation: top rises up, then slams into the base plate
    if (attackPhase < 0.2) {
      // Rise up phase - top section lifts
      pistonOffset = (-attackPhase / 0.2) * 12 * zoom;
    } else if (attackPhase < 0.35) {
      // Slam down phase - fast compression
      const slamPhase = (attackPhase - 0.2) / 0.15;
      pistonOffset = -12 * zoom * (1 - slamPhase * slamPhase);
      // Impact flash when hitting
      if (slamPhase > 0.8) {
        impactFlash = (slamPhase - 0.8) / 0.2;
      }
    } else if (attackPhase < 0.5) {
      // Compressed state - slight overshoot
      const compressPhase = (attackPhase - 0.35) / 0.15;
      pistonOffset = 4 * zoom * Math.sin(compressPhase * Math.PI);
      impactFlash = 1 - compressPhase;
    } else {
      // Return to rest
      const returnPhase = (attackPhase - 0.5) / 0.5;
      pistonOffset = 0;
    }

    // Ground shockwave expands after slam
    if (attackPhase > 0.3) {
      groundShockwave = (attackPhase - 0.3) / 0.7;
      groundCrackPhase = Math.min(1, (attackPhase - 0.3) / 0.5);
    }
  }

  // Base stays in place
  const shakeX = 0;
  const shakeY = 0;

  // Brown foundation platform with tech details (STAYS IN PLACE)
  drawIsometricPrism(
    ctx,
    screenPos.x,
    screenPos.y + 8 * zoom,
    baseWidth + 10,
    baseWidth + 10,
    8,
    {
      top: "#5a4a3a",
      left: "#4a3a2a",
      right: "#3a2a1a",
      leftBack: "#6a5a4a",
      rightBack: "#5a4a3a",
    },
    zoom
  );

  // Lower tower body - STAYS IN PLACE (base mechanism housing)
  const lowerBodyHeight = baseHeight * 0.5;
  drawIsometricPrism(
    ctx,
    screenPos.x,
    screenPos.y,
    baseWidth,
    baseWidth,
    lowerBodyHeight,
    {
      top: "#6a5a4a",
      left: "#5a4a3a",
      right: "#4a3a2a",
      leftBack: "#7a6a5a",
      rightBack: "#6a5a4a",
    },
    zoom
  );

  // Stone block pattern on lower body
  ctx.strokeStyle = "#3a2a1a";
  ctx.lineWidth = 1 * zoom;
  for (let row = 0; row < 4; row++) {
    const blockY = screenPos.y - row * lowerBodyHeight * zoom * 0.22;
    const offset = row % 2 === 0 ? 0 : w * 0.3;
    // Left face blocks
    ctx.beginPath();
    ctx.moveTo(screenPos.x - w * 0.1, blockY + d * 0.15);
    ctx.lineTo(screenPos.x - w * 0.85, blockY - d * 0.55);
    ctx.stroke();
    // Right face blocks
    ctx.beginPath();
    ctx.moveTo(screenPos.x + w * 0.1, blockY + d * 0.15);
    ctx.lineTo(screenPos.x + w * 0.85, blockY - d * 0.55);
    ctx.stroke();
  }

  // Corner buttresses for Gothic look
  for (let side of [-1, 1]) {
    ctx.fillStyle = "#5a4a3a";
    ctx.beginPath();
    ctx.moveTo(screenPos.x + side * w * 0.9, screenPos.y + d * 0.4);
    ctx.lineTo(screenPos.x + side * w * 1.05, screenPos.y + d * 0.5);
    ctx.lineTo(
      screenPos.x + side * w * 1.05,
      screenPos.y - lowerBodyHeight * zoom + d * 0.3
    );
    ctx.lineTo(
      screenPos.x + side * w * 0.9,
      screenPos.y - lowerBodyHeight * zoom + d * 0.2
    );
    ctx.closePath();
    ctx.fill();
  }

  // Piston plate/anvil - the striking surface (STAYS IN PLACE)
  const plateY = screenPos.y - lowerBodyHeight * zoom;

  // Outer plate ring (heavy iron)
  ctx.fillStyle = "#6a6a72";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    plateY + 2 * zoom,
    (baseWidth + 8) * zoom * 0.5,
    (baseWidth + 8) * zoom * 0.25,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  ctx.fillStyle = "#8a7a6a";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    plateY,
    (baseWidth + 6) * zoom * 0.5,
    (baseWidth + 6) * zoom * 0.25,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();
  ctx.fillStyle = "#9a8a7a";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    plateY - 3 * zoom,
    (baseWidth + 4) * zoom * 0.5,
    (baseWidth + 4) * zoom * 0.25,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Rune inscriptions on plate
  const runeGlow = 0.3 + Math.sin(time * 2) * 0.15 + attackPulse * 0.5;
  ctx.strokeStyle = `${mainColor} ${runeGlow})`;
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    plateY - 2 * zoom,
    baseWidth * zoom * 0.35,
    baseWidth * zoom * 0.18,
    0,
    0,
    Math.PI * 2
  );
  ctx.stroke();

  // Impact flash on the plate
  if (impactFlash > 0) {
    ctx.fillStyle = `${mainColor} ${impactFlash * 0.8})`;
    ctx.shadowColor = "#b466ff";
    ctx.shadowBlur = 20 * zoom * impactFlash;
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      plateY - 2 * zoom,
      baseWidth * zoom * 0.4,
      baseWidth * zoom * 0.2,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Piston guides/rails on sides (STAY IN PLACE) - Enhanced with rivets
  for (let dx of [-1, 1]) {
    // Main rail
    ctx.fillStyle = "#4a3a2a";
    ctx.fillRect(
      screenPos.x + dx * baseWidth * zoom * 0.4 - 4 * zoom,
      plateY - baseHeight * zoom * 0.6,
      8 * zoom,
      baseHeight * zoom * 0.6
    );

    // Rail highlight edge
    ctx.fillStyle = "#5a4a3a";
    ctx.fillRect(
      screenPos.x + dx * baseWidth * zoom * 0.4 - 4 * zoom,
      plateY - baseHeight * zoom * 0.6,
      2 * zoom,
      baseHeight * zoom * 0.6
    );

    // Rivets on rails
    ctx.fillStyle = "#6a5a4a";
    for (let r = 0; r < 4; r++) {
      const rivetY =
        plateY - baseHeight * zoom * 0.15 - r * baseHeight * zoom * 0.14;
      ctx.beginPath();
      ctx.arc(
        screenPos.x + dx * baseWidth * zoom * 0.4,
        rivetY,
        2 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }
  }

  // UPPER PISTON SECTION - MOVES WITH pistonOffset
  const pistonTopY = plateY - 4 * zoom + pistonOffset;

  // Upper tower body - piston hammer
  drawIsometricPrism(
    ctx,
    screenPos.x,
    pistonTopY,
    baseWidth - 4,
    baseWidth - 4,
    baseHeight * 0.4,
    {
      top: "#7a6a5a",
      left: "#6a5a4a",
      right: "#5a4a3a",
      leftBack: "#8a7a6a",
      rightBack: "#7a6a5a",
    },
    zoom
  );

  // Piston connector ring
  ctx.fillStyle = "#5a4a3a";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    pistonTopY + 2 * zoom,
    (baseWidth - 2) * zoom * 0.5,
    (baseWidth - 2) * zoom * 0.25,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Stone blocks on upper piston section
  ctx.strokeStyle = "#4a3a2a";
  ctx.lineWidth = 1 * zoom;
  for (let row = 0; row < 4; row++) {
    const blockY = pistonTopY + 12 - row * baseHeight * 0.12 * zoom;
    // Left face blocks
    ctx.beginPath();
    ctx.moveTo(screenPos.x - w * 0.1, blockY + d * 0.15);
    ctx.lineTo(screenPos.x - w * 0.85, blockY - d * 0.55);
    ctx.stroke();
    // Right face blocks
    ctx.beginPath();
    ctx.moveTo(screenPos.x + w * 0.1, blockY + d * 0.15);
    ctx.lineTo(screenPos.x + w * 0.85, blockY - d * 0.55);
    ctx.stroke();
  }

  const topY = pistonTopY - baseHeight * 0.4 * zoom;
  const sX = screenPos.x;

  // Purple accent panel lines on upper section
  const panelGlow = 0.4 + Math.sin(time * 3) * 0.2 + attackPulse;
  ctx.strokeStyle = `${mainColor} ${panelGlow})`;
  ctx.lineWidth = 1 * zoom;

  // Left face tech lines on upper section
  for (let i = 1; i <= tower.level; i++) {
    const lineY =
      pistonTopY + 16 - (baseHeight * 0.6 * zoom * i) / (tower.level + 1);
    ctx.beginPath();
    ctx.moveTo(sX - w * 0.15, lineY + d * 0.3);
    ctx.lineTo(sX - w * 0.7, lineY - d * 0.2);
    ctx.stroke();
  }

  // Right face tech lines on upper section
  for (let i = 1; i <= tower.level; i++) {
    const lineY =
      pistonTopY + 16 - (baseHeight * 0.6 * zoom * i) / (tower.level + 1);
    ctx.beginPath();
    ctx.moveTo(sX + w * 0.7, lineY - d * 0.2);
    ctx.lineTo(sX + w * 0.15, lineY + d * 0.3);
    ctx.stroke();
  }

  // Glowing purple energy vents on lower section (STAY IN PLACE)
  for (let i = 0; i < Math.min(tower.level, 2); i++) {
    const ventY = screenPos.y - lowerBodyHeight * zoom * 0.4 - i * 10 * zoom;
    const ventGlow = 0.5 + Math.sin(time * 4 + i * 0.5) * 0.3 + attackPulse;

    ctx.fillStyle = `${mainColor} ${ventGlow})`;
    ctx.shadowColor = "#b466ff";
    ctx.shadowBlur = 6 * zoom;
    ctx.beginPath();
    ctx.ellipse(
      sX - w * 0.55,
      ventY + d * 0.15,
      3 * zoom,
      1.5 * zoom,
      0.4,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(
      sX + w * 0.55,
      ventY + d * 0.15,
      3 * zoom,
      1.5 * zoom,
      -0.4,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Brown spire/antenna with purple energy - MOVES WITH PISTON
  const spireHeight = (25 + tower.level * 5) * zoom;

  // Spire back face (darker)
  ctx.fillStyle = "#3a2a1a";
  ctx.beginPath();
  ctx.moveTo(sX, topY - spireHeight);
  ctx.lineTo(sX - baseWidth * zoom * 0.35, topY);
  ctx.lineTo(sX, topY + baseWidth * zoom * 0.15);
  ctx.closePath();
  ctx.fill();

  // Spire front face (lighter)
  ctx.fillStyle = "#4a3a2a";
  ctx.beginPath();
  ctx.moveTo(sX, topY - spireHeight);
  ctx.lineTo(sX, topY + baseWidth * zoom * 0.15);
  ctx.lineTo(sX + baseWidth * zoom * 0.35, topY);
  ctx.closePath();
  ctx.fill();

  // Spire right face
  ctx.fillStyle = "#5a4a3a";
  ctx.beginPath();
  ctx.moveTo(sX, topY - spireHeight);
  ctx.lineTo(sX + baseWidth * zoom * 0.35, topY);
  ctx.lineTo(sX + baseWidth * zoom * 0.35, topY + 4 * zoom);
  ctx.lineTo(sX, topY + baseWidth * zoom * 0.15 + 4 * zoom);
  ctx.closePath();
  ctx.fill();

  // Gothic spire ridge lines
  ctx.strokeStyle = "#2a1a0a";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(sX, topY - spireHeight);
  ctx.lineTo(sX, topY + baseWidth * zoom * 0.15);
  ctx.stroke();

  // Spire ornamental bands
  for (let band = 0; band < 3; band++) {
    const bandY = topY - spireHeight * (0.3 + band * 0.25);
    const bandWidth = baseWidth * zoom * 0.35 * (0.85 - band * 0.2);
    ctx.strokeStyle = "#6a5a4a";
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.moveTo(sX - bandWidth, bandY + bandWidth * 0.4);
    ctx.lineTo(sX, bandY - bandWidth * 0.2);
    ctx.lineTo(sX + bandWidth, bandY + bandWidth * 0.4);
    ctx.stroke();
  }

  // Floating arcane rings around spire
  const ringGlow = 0.4 + Math.sin(time * 3) * 0.2 + attackPulse * 0.5;
  ctx.strokeStyle = `${mainColor} ${ringGlow})`;
  ctx.lineWidth = 1.5 * zoom;
  for (let ring = 0; ring < 2; ring++) {
    const ringY = topY - 12 - spireHeight * (0.5 + ring * 0.25);
    const ringSize = (8 - ring * 2) * zoom;
    ctx.beginPath();
    ctx.ellipse(
      sX,
      ringY,
      ringSize,
      ringSize * 0.4,
      time * 2 + ring,
      0,
      Math.PI * 2
    );
    ctx.stroke();
  }

  // Purple energy orb at antenna tip - Enhanced
  const orbGlow = 0.6 + Math.sin(time * 4) * 0.3 + attackPulse;
  const orbSize = (10 + tower.level * 2 + attackPulse * 5) * zoom;

  // Outer energy field
  const outerGrad = ctx.createRadialGradient(
    sX,
    topY - spireHeight - 8 * zoom,
    0,
    sX,
    topY - spireHeight - 8 * zoom,
    orbSize * 1.5
  );
  outerGrad.addColorStop(0, `${mainColor} ${orbGlow * 0.3})`);
  outerGrad.addColorStop(0.5, `rgba(140, 60, 200, ${orbGlow * 0.15})`);
  outerGrad.addColorStop(1, `rgba(100, 40, 160, 0)`);
  ctx.fillStyle = outerGrad;
  ctx.beginPath();
  ctx.arc(sX, topY - spireHeight - 8 * zoom, orbSize * 1.5, 0, Math.PI * 2);
  ctx.fill();

  // Main orb
  const orbGrad = ctx.createRadialGradient(
    sX - 2 * zoom,
    topY - spireHeight - 10 * zoom,
    0,
    sX,
    topY - spireHeight - 8 * zoom,
    orbSize
  );

  //change depending on tower level
  if (tower.level <= 3) {
    orbGrad.addColorStop(0, `rgba(255, 220, 255, ${orbGlow})`);
    orbGrad.addColorStop(0.3, `rgba(200, 150, 255, ${orbGlow})`);
    orbGrad.addColorStop(0.6, `rgba(150, 80, 220, ${orbGlow * 0.7})`);
    orbGrad.addColorStop(1, `rgba(100, 50, 180, 0)`);
  } else if (tower.level === 4 && tower.upgrade === "A") {
    // make it orange
    orbGrad.addColorStop(0, `rgba(255, 220, 180, ${orbGlow})`);
    orbGrad.addColorStop(0.3, `rgba(255, 180, 100, ${orbGlow})`);
    orbGrad.addColorStop(0.6, `rgba(220, 100, 40, ${orbGlow * 0.7})`);
    orbGrad.addColorStop(1, `rgba(180, 60, 30, 0)`);
  } else {
    // make it ice blue
    orbGrad.addColorStop(0, `rgba(180, 240, 255, ${orbGlow})`);
    orbGrad.addColorStop(0.3, `rgba(100, 200, 255, ${orbGlow})`);
    orbGrad.addColorStop(0.6, `rgba(40, 150, 220, ${orbGlow * 0.7})`);
    orbGrad.addColorStop(1, `rgba(30, 100, 180, 0)`);
  }

  ctx.fillStyle = orbGrad;
  ctx.shadowColor = "#b466ff";
  ctx.shadowBlur = 15 * zoom * orbGlow;
  ctx.beginPath();
  ctx.arc(sX, topY - spireHeight - 8 * zoom, orbSize, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Inner bright core
  ctx.fillStyle = `rgba(255, 230, 255, ${orbGlow})`;
  ctx.beginPath();
  ctx.arc(sX, topY - spireHeight - 8 * zoom, 3 * zoom, 0, Math.PI * 2);
  ctx.fill();

  // Energy tendrils from orb during attack
  if (attackPulse > 0.1) {
    for (let t = 0; t < 4; t++) {
      const tendrilAngle = time * 5 + (t / 4) * Math.PI * 2;
      const tendrilLen = (15 + attackPulse * 20) * zoom;
      ctx.strokeStyle = `${mainColor} ${attackPulse * 0.6})`;
      ctx.lineWidth = 1.5 * zoom;
      ctx.beginPath();
      ctx.moveTo(sX, topY - spireHeight - 8 * zoom);
      ctx.quadraticCurveTo(
        sX + Math.cos(tendrilAngle) * tendrilLen * 0.5,
        topY -
          spireHeight -
          8 * zoom +
          Math.sin(tendrilAngle) * tendrilLen * 0.3,
        sX + Math.cos(tendrilAngle + 0.3) * tendrilLen,
        topY -
          spireHeight -
          8 * zoom +
          Math.sin(tendrilAngle + 0.3) * tendrilLen * 0.5
      );
      ctx.stroke();
    }
  }

  // Holographic windows on lower section with brown frames (STAY IN PLACE)
  const windowY = screenPos.y - lowerBodyHeight * zoom * 0.5;
  const glowIntensity = 0.5 + Math.sin(time * 2) * 0.3 + attackPulse;

  for (let dx of [-1, 1]) {
    const wx = sX + dx * 10 * zoom;

    // Window frame (Gothic arch shape)
    ctx.fillStyle = "#3a2a1a";
    ctx.beginPath();
    ctx.moveTo(wx - 4 * zoom, windowY + 8 * zoom);
    ctx.lineTo(wx - 4 * zoom, windowY - 2 * zoom);
    ctx.quadraticCurveTo(
      wx,
      windowY - 8 * zoom,
      wx + 4 * zoom,
      windowY - 2 * zoom
    );
    ctx.lineTo(wx + 4 * zoom, windowY + 8 * zoom);
    ctx.closePath();
    ctx.fill();

    // Window frame border
    ctx.strokeStyle = "#2a1a0a";
    ctx.lineWidth = 1 * zoom;
    ctx.stroke();

    // Glowing window interior
    ctx.fillStyle = `${mainColor} ${glowIntensity})`;
    ctx.shadowColor = "#b466ff";
    ctx.shadowBlur = 10 * zoom;
    ctx.beginPath();
    ctx.moveTo(wx - 2.5 * zoom, windowY + 6 * zoom);
    ctx.lineTo(wx - 2.5 * zoom, windowY - 1 * zoom);
    ctx.quadraticCurveTo(
      wx,
      windowY - 5 * zoom,
      wx + 2.5 * zoom,
      windowY - 1 * zoom
    );
    ctx.lineTo(wx + 2.5 * zoom, windowY + 6 * zoom);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;

    // Window mullion (divider)
    ctx.strokeStyle = "#3a2a1a";
    ctx.lineWidth = 1 * zoom;
    ctx.beginPath();
    ctx.moveTo(wx, windowY - 4 * zoom);
    ctx.lineTo(wx, windowY + 6 * zoom);
    ctx.stroke();
  }

  // Central purple core display
  ctx.fillStyle = "#3a2a1a";
  ctx.beginPath();
  ctx.arc(sX, topY + 5 * zoom, 8 * zoom, 0, Math.PI * 2);
  ctx.fill();

  const coreGrad = ctx.createRadialGradient(
    sX,
    topY + 5 * zoom,
    0,
    sX,
    topY + 5 * zoom,
    6 * zoom
  );
  coreGrad.addColorStop(0, `${mainColor} ${glowIntensity})`);
  coreGrad.addColorStop(0.5, `rgba(140, 80, 200, ${glowIntensity * 0.7})`);
  coreGrad.addColorStop(1, `rgba(100, 50, 150, ${glowIntensity * 0.4})`);
  ctx.fillStyle = coreGrad;
  ctx.shadowColor = "#b466ff";
  ctx.shadowBlur = 10 * zoom;
  ctx.beginPath();
  ctx.arc(sX, topY + 5 * zoom, 6 * zoom, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Data ring pattern
  ctx.strokeStyle = "#3a2a1a";
  ctx.lineWidth = 1;
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2 + time * 2;
    ctx.beginPath();
    ctx.moveTo(sX, topY + 5 * zoom);
    ctx.lineTo(
      sX + Math.cos(angle) * 5 * zoom,
      topY + 5 * zoom + Math.sin(angle) * 5 * zoom
    );
    ctx.stroke();
  }

  // Floating data tablets
  if (tower.level >= 2) {
    for (let i = 0; i < tower.level + 1; i++) {
      const bookAngle = time * 1.2 + i * ((Math.PI * 2) / (tower.level + 1));
      const bookRadius = 28 * zoom;
      const bookX = sX + Math.cos(bookAngle) * bookRadius;
      const bookY = topY - 18 * zoom + Math.sin(bookAngle * 2) * 8 * zoom;
      const bookFloat = Math.sin(time * 3 + i) * 3 * zoom;

      ctx.fillStyle = `${mainColor} 0.3)`;
      ctx.beginPath();
      ctx.ellipse(
        bookX,
        bookY + bookFloat + 2 * zoom,
        8 * zoom,
        3 * zoom,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();

      ctx.fillStyle =
        i % 3 === 0 ? "#5a4a3a" : i % 3 === 1 ? "#4a5a5a" : "#4a4a5a";
      ctx.fillRect(
        bookX - 7 * zoom,
        bookY + bookFloat - 5 * zoom,
        14 * zoom,
        10 * zoom
      );

      ctx.fillStyle = `rgba(180, 150, 255, ${
        0.6 + Math.sin(time * 5 + i) * 0.2
      })`;
      ctx.fillRect(
        bookX - 5 * zoom,
        bookY + bookFloat - 4 * zoom,
        10 * zoom,
        8 * zoom
      );
    }
  }

  // Level 3 - Energy amplifier rings
  if (tower.level === 3 && !tower.upgrade) {
    const ringGlow = 0.5 + Math.sin(time * 3) * 0.3 + attackPulse;
    ctx.strokeStyle = `${mainColor} ${ringGlow})`;
    ctx.lineWidth = 2 * zoom;

    ctx.beginPath();
    ctx.ellipse(
      sX,
      topY - 15 * zoom,
      18 * zoom,
      9 * zoom,
      time * 0.5,
      0,
      Math.PI * 2
    );
    ctx.stroke();

    for (let i = 0; i < 4; i++) {
      const runeAngle = (i / 4) * Math.PI * 2 + time * 1.5;
      const rx = sX + Math.cos(runeAngle) * 22 * zoom;
      const ry = topY - 15 * zoom + Math.sin(runeAngle) * 11 * zoom;

      ctx.fillStyle = `rgba(220, 180, 255, ${ringGlow})`;
      ctx.beginPath();
      ctx.arc(rx, ry, 3 * zoom, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Level 4 upgrade visuals
  if (tower.level === 4) {
    if (tower.upgrade === "A") {
      const wavePhase = (time * 2) % 1;
      const waveRadius = 30 + wavePhase * 60;

      ctx.strokeStyle = `rgba(255, 100, 50, ${0.7 * (1 - wavePhase)})`;
      ctx.lineWidth = 4 * zoom;
      ctx.beginPath();
      ctx.ellipse(
        sX,
        screenPos.y + shakeY + 5 * zoom,
        waveRadius * zoom * 0.7,
        waveRadius * zoom * 0.35,
        0,
        0,
        Math.PI * 2
      );
      ctx.stroke();

      ctx.strokeStyle = `rgba(255, 150, 50, 0.5)`;
      ctx.lineWidth = 2 * zoom;
      for (let i = 0; i < 6; i++) {
        const crackAngle = (i / 6) * Math.PI * 2 + time * 0.2;
        ctx.beginPath();
        ctx.moveTo(sX, screenPos.y + shakeY + 5 * zoom);
        ctx.lineTo(
          sX + Math.cos(crackAngle) * 35 * zoom,
          screenPos.y + shakeY + 5 * zoom + Math.sin(crackAngle) * 17 * zoom
        );
        ctx.stroke();
      }
    } else if (tower.upgrade === "B") {
      for (let i = 0; i < 6; i++) {
        const crystalAngle = (i * Math.PI) / 3 + time * 0.5;
        const cx = sX + Math.cos(crystalAngle) * 25 * zoom;
        const cy = topY - 10 * zoom + Math.sin(crystalAngle) * 12 * zoom;
        const crystalSize = (8 + Math.sin(time * 2 + i) * 3) * zoom;

        ctx.fillStyle = "rgba(100, 200, 255, 0.3)";
        ctx.shadowColor = "#66ddff";
        ctx.shadowBlur = 8 * zoom;
        ctx.beginPath();
        ctx.ellipse(
          cx,
          cy,
          crystalSize * 0.8,
          crystalSize * 0.4,
          0,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = "rgba(150, 230, 255, 0.9)";
        ctx.beginPath();
        ctx.moveTo(cx, cy - crystalSize);
        ctx.lineTo(cx + crystalSize * 0.5, cy);
        ctx.lineTo(cx, cy + crystalSize * 0.7);
        ctx.lineTo(cx - crystalSize * 0.5, cy);
        ctx.closePath();
        ctx.fill();
      }

      ctx.strokeStyle = `rgba(100, 200, 255, ${
        0.4 + Math.sin(time * 3) * 0.2
      })`;
      ctx.lineWidth = 2 * zoom;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.ellipse(
        sX,
        screenPos.y + shakeY,
        40 * zoom,
        20 * zoom,
        0,
        0,
        Math.PI * 2
      );
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  // Purple energy field around tower
  const auraSize = 30 + Math.sin(time * 3) * 5;
  ctx.strokeStyle = `${mainColor} ${
    0.35 + Math.sin(time * 2) * 0.15 + attackPulse * 0.5
  })`;
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.ellipse(
    sX,
    screenPos.y + shakeY - baseHeight * zoom * 0.3,
    auraSize * zoom,
    auraSize * zoom * 0.5,
    0,
    0,
    Math.PI * 2
  );
  ctx.stroke();

  // Ground-crushing shockwave effect during attack
  if (groundShockwave > 0 && groundShockwave < 1) {
    const shockRadius = 40 + groundShockwave * 80;
    const shockAlpha = (1 - groundShockwave) * 0.8;

    // Multiple expanding rings
    for (let ring = 0; ring < 3; ring++) {
      const ringDelay = ring * 0.15;
      const ringPhase = Math.max(0, groundShockwave - ringDelay);
      if (ringPhase > 0 && ringPhase < 1) {
        const ringRadius = 30 + ringPhase * 70;
        const ringAlpha = (1 - ringPhase) * 0.6;

        ctx.strokeStyle = `${mainColor} ${ringAlpha})`;
        ctx.lineWidth = (4 - ring) * zoom;
        ctx.beginPath();
        ctx.ellipse(
          sX,
          screenPos.y + 5 * zoom,
          ringRadius * zoom,
          ringRadius * zoom * 0.5,
          0,
          0,
          Math.PI * 2
        );
        ctx.stroke();
      }
    }

    // Ground crack lines radiating outward
    if (groundCrackPhase > 0) {
      ctx.strokeStyle = `${mainColor} ${(1 - groundCrackPhase) * 0.7})`;
      ctx.lineWidth = 2 * zoom;
      for (let i = 0; i < 8; i++) {
        const crackAngle = (i / 8) * Math.PI * 2 + Math.PI / 16;
        const crackLength = 25 + groundCrackPhase * 50;
        const wobble1 = Math.sin(i * 3 + time * 5) * 5;
        const wobble2 = Math.cos(i * 2 + time * 3) * 8;

        ctx.beginPath();
        ctx.moveTo(sX, screenPos.y + 5 * zoom);
        // Jagged crack line
        ctx.lineTo(
          sX + Math.cos(crackAngle) * crackLength * 0.4 * zoom + wobble1 * zoom,
          screenPos.y +
            5 * zoom +
            Math.sin(crackAngle) * crackLength * 0.2 * zoom
        );
        ctx.lineTo(
          sX + Math.cos(crackAngle) * crackLength * zoom + wobble2 * zoom,
          screenPos.y +
            5 * zoom +
            Math.sin(crackAngle) * crackLength * 0.5 * zoom
        );
        ctx.stroke();
      }
    }

    // Debris particles flying up
    for (let i = 0; i < 6; i++) {
      const debrisAngle = (i / 6) * Math.PI * 2 + time * 0.5;
      const debrisPhase = (groundShockwave + i * 0.1) % 1;
      const debrisRadius = 20 + debrisPhase * 40;
      const debrisHeight = Math.sin(debrisPhase * Math.PI) * 30;
      const debrisAlpha = (1 - debrisPhase) * 0.8;

      const dx = sX + Math.cos(debrisAngle) * debrisRadius * zoom;
      const dy =
        screenPos.y +
        5 * zoom +
        Math.sin(debrisAngle) * debrisRadius * 0.5 * zoom -
        debrisHeight * zoom;

      ctx.fillStyle = `rgba(100, 80, 60, ${debrisAlpha})`;
      ctx.beginPath();
      ctx.arc(dx, dy, (2 + Math.random()) * zoom, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.restore();
}

// LAB TOWER - Tesla coil with fixed projectile origins
function renderLabTower(
  ctx: CanvasRenderingContext2D,
  screenPos: Position,
  tower: Tower,
  zoom: number,
  time: number,
  colors: { base: string; dark: string; light: string; accent: string },
  enemies: Enemy[],
  selectedMap: string,
  canvasWidth: number,
  canvasHeight: number,
  dpr: number,
  cameraOffset?: Position,
  cameraZoom?: number
) {
  ctx.save();
  const baseWidth = 30 + tower.level * 4;
  const baseHeight = 25 + tower.level * 8;
  const w = baseWidth * zoom * 0.5;
  const d = baseWidth * zoom * 0.25;
  const h = baseHeight * zoom;

  // Foundation platform with tech details
  drawIsometricPrism(
    ctx,
    screenPos.x,
    screenPos.y + 10 * zoom,
    baseWidth + 10,
    baseWidth + 10,
    6,
    {
      top: "#1a3a4f",
      left: "#153040",
      right: "#102535",
      leftBack: "#1d4055",
      rightBack: "#183548",
    },
    zoom
  );

  // Foundation edge glow
  const foundGlow = 0.3 + Math.sin(time * 2) * 0.15;
  ctx.strokeStyle = `rgba(0, 255, 255, ${foundGlow})`;
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(
    screenPos.x - (baseWidth + 10) * zoom * 0.5,
    screenPos.y + 4 * zoom
  );
  ctx.lineTo(
    screenPos.x,
    screenPos.y + (baseWidth + 10) * zoom * 0.25 + 4 * zoom
  );
  ctx.lineTo(
    screenPos.x + (baseWidth + 10) * zoom * 0.5,
    screenPos.y + 4 * zoom
  );
  ctx.stroke();

  // Main sci-fi tower body
  drawIsometricPrism(
    ctx,
    screenPos.x,
    screenPos.y + 2 * zoom,
    baseWidth,
    baseWidth,
    baseHeight - 6,
    {
      top: "#4d7a9b",
      left: "#3a6585",
      right: "#2d5a7b",
      leftBack: "#4a7595",
      rightBack: "#3d6888",
    },
    zoom
  );

  // Structural panel lines for better 3D effect
  ctx.strokeStyle = "#2a5a75";
  ctx.lineWidth = 1 * zoom;
  // Left face vertical panels
  for (let panel = 0; panel < 3; panel++) {
    const panelX = screenPos.x - w * (0.2 + panel * 0.3);
    ctx.beginPath();
    ctx.moveTo(panelX, screenPos.y + 2 * zoom);
    ctx.lineTo(
      panelX - d * 0.5,
      screenPos.y - (baseHeight - 6) * zoom + d * 0.5
    );
    ctx.stroke();
  }
  // Right face vertical panels
  for (let panel = 0; panel < 3; panel++) {
    const panelX = screenPos.x + w * (0.2 + panel * 0.3);
    ctx.beginPath();
    ctx.moveTo(panelX, screenPos.y + 2 * zoom);
    ctx.lineTo(
      panelX + d * 0.5,
      screenPos.y - (baseHeight - 6) * zoom + d * 0.5
    );
    ctx.stroke();
  }

  // Corner reinforcement struts
  ctx.fillStyle = "#3a6a8a";
  for (let side of [-1, 1]) {
    ctx.beginPath();
    ctx.moveTo(screenPos.x + side * w * 0.95, screenPos.y + d * 0.4);
    ctx.lineTo(screenPos.x + side * w * 1.05, screenPos.y + d * 0.5);
    ctx.lineTo(
      screenPos.x + side * w * 1.05,
      screenPos.y - (baseHeight - 10) * zoom + d * 0.4
    );
    ctx.lineTo(
      screenPos.x + side * w * 0.95,
      screenPos.y - (baseHeight - 10) * zoom + d * 0.3
    );
    ctx.closePath();
    ctx.fill();
  }

  // ========== ROTATING ENERGY RINGS ==========
  const ringRotation = time * 2;
  for (let ring = 0; ring < 2 + tower.level; ring++) {
    const ringY = screenPos.y - h * (0.3 + ring * 0.15);
    const ringRadius = 12 + tower.level * 2 - ring * 2;
    const ringAlpha = 0.3 + Math.sin(time * 4 + ring) * 0.15;

    ctx.strokeStyle = `rgba(0, 255, 255, ${ringAlpha})`;
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      ringY,
      ringRadius * zoom,
      ringRadius * 0.4 * zoom,
      ringRotation + ring * 0.5,
      0,
      Math.PI * 2
    );
    ctx.stroke();

    // Ring energy nodes
    for (let node = 0; node < 4; node++) {
      const nodeAngle = ringRotation + ring * 0.5 + (node / 4) * Math.PI * 2;
      const nodeX = screenPos.x + Math.cos(nodeAngle) * ringRadius * zoom;
      const nodeY = ringY + Math.sin(nodeAngle) * ringRadius * 0.4 * zoom;
      ctx.fillStyle = `rgba(0, 255, 255, ${ringAlpha + 0.2})`;
      ctx.beginPath();
      ctx.arc(nodeX, nodeY, 1.5 * zoom, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // ========== ENERGY TUBES (multiple) ==========
  // Left side energy tubes
  drawEnergyTube(
    ctx,
    screenPos.x - w * 0.8,
    screenPos.y + 8 * zoom,
    screenPos.x - w * 0.5,
    screenPos.y - h * 0.6,
    2.5,
    time,
    zoom,
    "rgb(0, 200, 255)"
  );

  // Right side energy tubes
  drawEnergyTube(
    ctx,
    screenPos.x + w * 0.8,
    screenPos.y + 8 * zoom,
    screenPos.x + w * 0.5,
    screenPos.y - h * 0.6,
    2.5,
    time + 0.5,
    zoom,
    "rgb(0, 200, 255)"
  );

  // Cross-connecting tube
  if (tower.level >= 2) {
    drawEnergyTube(
      ctx,
      screenPos.x - w * 0.6,
      screenPos.y - h * 0.3,
      screenPos.x + w * 0.6,
      screenPos.y - h * 0.4,
      2,
      time + 0.3,
      zoom,
      "rgb(100, 255, 255)"
    );
  }

  // ========== ROTATING CAPACITOR DISCS ==========
  const discRotation = time * 3;
  ctx.save();
  ctx.translate(screenPos.x, screenPos.y - h * 0.7);

  // Multiple rotating discs
  for (let disc = 0; disc < tower.level; disc++) {
    const discAngle = discRotation + (disc * Math.PI) / tower.level;
    const discRadius = 6 + disc * 2;
    const discY = disc * 8 * zoom;

    ctx.fillStyle = `rgba(40, 80, 120, ${0.6 - disc * 0.1})`;
    ctx.beginPath();
    ctx.ellipse(
      0,
      discY,
      discRadius * zoom,
      discRadius * 0.4 * zoom,
      discAngle,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Disc edge glow
    ctx.strokeStyle = `rgba(0, 255, 255, ${
      0.5 + Math.sin(time * 5 + disc) * 0.3
    })`;
    ctx.lineWidth = 2 * zoom;
    ctx.stroke();
  }
  ctx.restore();

  // Add sci-fi panel details on left face (flipped orientation)
  const panelGlow = 0.4 + Math.sin(time * 3) * 0.2;
  ctx.strokeStyle = `rgba(0, 255, 255, ${panelGlow})`;
  ctx.lineWidth = 1 * zoom;

  // Left face horizontal tech lines (flipped)
  for (let i = 1; i <= tower.level + 1; i++) {
    const lineY =
      screenPos.y +
      2 * zoom -
      ((baseHeight - 6) * zoom * i) / (tower.level + 2);
    ctx.beginPath();
    ctx.moveTo(screenPos.x - w * 0.2, lineY + d * 0.3);
    ctx.lineTo(screenPos.x - w * 0.85, lineY - d * 0.2);
    ctx.stroke();
  }

  // Right face tech lines (flipped)
  for (let i = 1; i <= tower.level + 1; i++) {
    const lineY =
      screenPos.y +
      2 * zoom -
      ((baseHeight - 6) * zoom * i) / (tower.level + 2);
    ctx.beginPath();
    ctx.moveTo(screenPos.x + w * 0.85, lineY - d * 0.2);
    ctx.lineTo(screenPos.x + w * 0.2, lineY + d * 0.3);
    ctx.stroke();
  }

  // ========== ANIMATED COOLANT FLOW ==========
  // Coolant tanks on sides
  ctx.fillStyle = "#1a4a6a";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x - w * 0.75,
    screenPos.y - h * 0.15,
    5 * zoom,
    8 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x + w * 0.75,
    screenPos.y - h * 0.15,
    5 * zoom,
    8 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Animated coolant bubbles
  for (let i = 0; i < 3; i++) {
    const bubblePhase = (time * 2 + i * 0.4) % 1;
    const bubbleY = screenPos.y - h * 0.05 - bubblePhase * h * 0.2;
    const bubbleAlpha = Math.sin(bubblePhase * Math.PI) * 0.6;

    ctx.fillStyle = `rgba(100, 200, 255, ${bubbleAlpha})`;
    ctx.beginPath();
    ctx.arc(
      screenPos.x - w * 0.75 + (i - 1) * 2 * zoom,
      bubbleY,
      2 * zoom,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.beginPath();
    ctx.arc(
      screenPos.x + w * 0.75 + (i - 1) * 2 * zoom,
      bubbleY + 3 * zoom,
      2 * zoom,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  // Glowing vents on sides with enhanced glow
  for (let i = 0; i < tower.level; i++) {
    const ventY = screenPos.y - h * 0.3 - i * 12 * zoom;
    const ventGlow = 0.5 + Math.sin(time * 4 + i * 0.5) * 0.3;

    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 8 * zoom;

    // Left vent
    ctx.fillStyle = `rgba(0, 255, 255, ${ventGlow})`;
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x - w * 0.6,
      ventY + d * 0.2,
      4 * zoom,
      2 * zoom,
      0.4,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Right vent
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x + w * 0.6,
      ventY + d * 0.2,
      4 * zoom,
      2 * zoom,
      -0.4,
      0,
      Math.PI * 2
    );
    ctx.fill();

    ctx.shadowBlur = 0;
  }

  // ========== CIRCUIT BOARD PATTERNS WITH ANIMATED CURRENT ==========
  ctx.strokeStyle = "#5a8aab";
  ctx.lineWidth = 1.5 * zoom;

  // Left circuit (flipped to go other direction)
  ctx.beginPath();
  ctx.moveTo(screenPos.x - w * 0.4, screenPos.y - h * 0.2);
  ctx.lineTo(screenPos.x - w * 0.4, screenPos.y - h * 0.4);
  ctx.lineTo(screenPos.x - w * 0.7, screenPos.y - h * 0.5);
  ctx.stroke();

  // Right circuit (flipped)
  ctx.beginPath();
  ctx.moveTo(screenPos.x + w * 0.4, screenPos.y - h * 0.2);
  ctx.lineTo(screenPos.x + w * 0.4, screenPos.y - h * 0.4);
  ctx.lineTo(screenPos.x + w * 0.7, screenPos.y - h * 0.5);
  ctx.stroke();

  // Animated current flowing through circuits
  const currentPhase = (time * 3) % 1;
  ctx.fillStyle = `rgba(0, 255, 255, ${0.8})`;
  ctx.shadowColor = "#00ffff";
  ctx.shadowBlur = 6 * zoom;

  // Left circuit current
  const leftCurrentX = screenPos.x - w * (0.4 + currentPhase * 0.3);
  const leftCurrentY = screenPos.y - h * (0.2 + currentPhase * 0.3);
  ctx.beginPath();
  ctx.arc(leftCurrentX, leftCurrentY, 2 * zoom, 0, Math.PI * 2);
  ctx.fill();

  // Right circuit current
  const rightCurrentX = screenPos.x + w * (0.4 + currentPhase * 0.3);
  const rightCurrentY = screenPos.y - h * (0.2 + currentPhase * 0.3);
  ctx.beginPath();
  ctx.arc(rightCurrentX, rightCurrentY, 2 * zoom, 0, Math.PI * 2);
  ctx.fill();

  ctx.shadowBlur = 0;

  // Node points with enhanced glow
  const nodeGlow = 0.6 + Math.sin(time * 5) * 0.3;
  ctx.fillStyle = `rgba(0, 255, 255, ${nodeGlow})`;
  ctx.shadowColor = "#00ffff";
  ctx.shadowBlur = 10 * zoom;
  ctx.beginPath();
  ctx.arc(
    screenPos.x - w * 0.7,
    screenPos.y - h * 0.5,
    3 * zoom,
    0,
    Math.PI * 2
  );
  ctx.fill();
  ctx.beginPath();
  ctx.arc(
    screenPos.x + w * 0.7,
    screenPos.y - h * 0.5,
    3 * zoom,
    0,
    Math.PI * 2
  );
  ctx.fill();
  ctx.shadowBlur = 0;

  // ========== HOLOGRAPHIC DATA DISPLAY ==========
  ctx.fillStyle = "#0a2030";
  const screenW = 10 * zoom;
  const screenH = 8 * zoom;
  ctx.fillRect(
    screenPos.x - screenW / 2,
    screenPos.y - h * 0.38,
    screenW,
    screenH
  );

  // Screen frame glow
  ctx.strokeStyle = `rgba(0, 255, 255, ${0.6 + Math.sin(time * 3) * 0.2})`;
  ctx.lineWidth = 1.5 * zoom;
  ctx.strokeRect(
    screenPos.x - screenW / 2,
    screenPos.y - h * 0.38,
    screenW,
    screenH
  );

  // Screen content (scrolling data with waveform)
  ctx.fillStyle = `rgba(0, 255, 255, 0.8)`;
  for (let i = 0; i < 4; i++) {
    const lineOffset = (time * 30 + i * 2) % 8;
    ctx.fillRect(
      screenPos.x - screenW / 2 + 1 * zoom,
      screenPos.y - h * 0.38 + lineOffset * zoom,
      (3 + Math.sin(time * 15 + i * 2) * 2) * zoom,
      1 * zoom
    );
  }

  // Waveform on screen
  ctx.strokeStyle = `rgba(0, 255, 255, 0.9)`;
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  for (let i = 0; i < 8; i++) {
    const waveX = screenPos.x - screenW / 2 + 1 * zoom + i * zoom;
    const waveY =
      screenPos.y - h * 0.34 + Math.sin(time * 10 + i * 0.8) * 2 * zoom;
    if (i === 0) ctx.moveTo(waveX, waveY);
    else ctx.lineTo(waveX, waveY);
  }
  ctx.stroke();

  // ========== WARNING LIGHTS ==========
  drawWarningLight(
    ctx,
    screenPos.x - w * 0.85,
    screenPos.y - h * 0.1,
    2.5,
    time,
    zoom,
    "#00ffff",
    5
  );
  drawWarningLight(
    ctx,
    screenPos.x + w * 0.85,
    screenPos.y - h * 0.1,
    2.5,
    time + 0.3,
    zoom,
    "#00ffff",
    5
  );

  const topY = screenPos.y - baseHeight * zoom;

  if (tower.level === 4 && tower.upgrade === "A") {
    renderFocusedBeam(
      ctx,
      screenPos,
      topY,
      tower,
      zoom,
      time,
      enemies,
      selectedMap,
      canvasWidth,
      canvasHeight,
      dpr,
      cameraOffset,
      cameraZoom
    );
  } else if (tower.level === 4 && tower.upgrade === "B") {
    renderChainLightning(ctx, screenPos, topY, tower, zoom, time);
  } else {
    renderTeslaCoil(
      ctx,
      screenPos,
      topY,
      tower,
      zoom,
      time,
      enemies,
      selectedMap,
      canvasWidth,
      canvasHeight,
      dpr,
      cameraOffset,
      cameraZoom
    );
  }

  ctx.restore();
}

function renderTeslaCoil(
  ctx: CanvasRenderingContext2D,
  screenPos: Position,
  topY: number,
  tower: Tower,
  zoom: number,
  time: number,
  enemies: Enemy[],
  selectedMap: string,
  canvasWidth: number,
  canvasHeight: number,
  dpr: number,
  cameraOffset?: Position,
  cameraZoom?: number
) {
  const coilHeight = (35 + tower.level * 8) * zoom;

  // Coil base platform
  ctx.fillStyle = "#1a3a4f";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    topY + 5 * zoom,
    18 * zoom,
    9 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  ctx.fillStyle = "#2a4a5f";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    topY + 2 * zoom,
    16 * zoom,
    8 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Central coil column - Enhanced 3D cylindrical structure
  const columnGrad = ctx.createLinearGradient(
    screenPos.x - 10 * zoom,
    0,
    screenPos.x + 10 * zoom,
    0
  );
  columnGrad.addColorStop(0, "#1a3a4f");
  columnGrad.addColorStop(0.25, "#3a6a8f");
  columnGrad.addColorStop(0.5, "#4a7a9f");
  columnGrad.addColorStop(0.75, "#3a6a8f");
  columnGrad.addColorStop(1, "#1a3a4f");
  ctx.fillStyle = columnGrad;
  ctx.beginPath();
  ctx.moveTo(screenPos.x - 8 * zoom, topY);
  ctx.lineTo(screenPos.x - 5 * zoom, topY - coilHeight + 12 * zoom);
  ctx.lineTo(screenPos.x + 5 * zoom, topY - coilHeight + 12 * zoom);
  ctx.lineTo(screenPos.x + 8 * zoom, topY);
  ctx.closePath();
  ctx.fill();

  // Add vertical structural ribs for better 3D effect
  ctx.strokeStyle = "#2a5a7f";
  ctx.lineWidth = 1.5 * zoom;
  for (let rib = -1; rib <= 1; rib++) {
    const ribX = screenPos.x + rib * 4 * zoom;
    const topRibX = screenPos.x + rib * 3 * zoom;
    ctx.beginPath();
    ctx.moveTo(ribX, topY);
    ctx.lineTo(topRibX, topY - coilHeight + 12 * zoom);
    ctx.stroke();
  }

  // Tesla coil rings (copper) - Enhanced with better 3D shading
  const ringCount = 4 + tower.level;
  for (let i = 0; i < ringCount; i++) {
    const ringProgress = (i + 1) / (ringCount + 1);
    const ringY = topY - ringProgress * (coilHeight - 18 * zoom);
    const ringSize = 14 - i * (10 / ringCount);
    const energyPulse = Math.sin(time * 6 - i * 0.8) * 0.3;

    // Ring shadow (back edge)
    ctx.strokeStyle = `rgb(${100 + energyPulse * 20}, ${
      60 + energyPulse * 15
    }, ${30})`;
    ctx.lineWidth = 5 * zoom;
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      ringY + 2 * zoom,
      ringSize * zoom,
      ringSize * zoom * 0.4,
      0,
      Math.PI * 0.1,
      Math.PI * 0.9
    );
    ctx.stroke();

    if (Date.now() - tower.lastAttack < 300) {
      ctx.shadowColor = "#00ffff";
      ctx.shadowBlur = 12 * zoom;
    }

    // Ring body (copper dark)
    ctx.strokeStyle = `rgb(${140 + energyPulse * 30}, ${
      90 + energyPulse * 20
    }, ${40})`;
    ctx.lineWidth = 4 * zoom;
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      ringY + 1 * zoom,
      ringSize * zoom,
      ringSize * zoom * 0.4,
      0,
      0,
      Math.PI * 2
    );
    ctx.stroke();

    // Ring highlight (copper bright)
    ctx.strokeStyle = `rgb(${200 + energyPulse * 50}, ${
      140 + energyPulse * 30
    }, ${70})`;
    ctx.lineWidth = 3 * zoom;
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      ringY,
      ringSize * zoom,
      ringSize * zoom * 0.4,
      0,
      0,
      Math.PI * 2
    );
    ctx.stroke();

    // Animated energy flow on ring (when attacking)
    if (Date.now() - tower.lastAttack < 300) {
      const flowAngle = time * 8 + i * 0.5;
      const flowX = screenPos.x + Math.cos(flowAngle) * ringSize * zoom;
      const flowY = ringY + Math.sin(flowAngle) * ringSize * zoom * 0.4;
      ctx.fillStyle = "rgba(0, 255, 255, 0.8)";
      ctx.beginPath();
      ctx.arc(flowX, flowY, 2 * zoom, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.shadowBlur = 0;
  }

  // Energy orb at top - THIS IS WHERE LIGHTNING ORIGINATES
  const orbY = topY - coilHeight + 5 * zoom;
  const orbPulse = 1 + Math.sin(time * 6) * 0.2;
  const orbSize = (10 + tower.level * 2) * zoom;

  // Store the orb position for projectile origin calculations
  tower._orbScreenY = orbY;

  // Outer energy field
  const energyFieldGrad = ctx.createRadialGradient(
    screenPos.x,
    orbY,
    0,
    screenPos.x,
    orbY,
    orbSize * 2.5 * orbPulse
  );
  energyFieldGrad.addColorStop(0, "rgba(0, 255, 255, 0.15)");
  energyFieldGrad.addColorStop(0.4, "rgba(0, 200, 255, 0.08)");
  energyFieldGrad.addColorStop(0.7, "rgba(0, 150, 255, 0.03)");
  energyFieldGrad.addColorStop(1, "rgba(0, 100, 255, 0)");
  ctx.fillStyle = energyFieldGrad;
  ctx.beginPath();
  ctx.arc(screenPos.x, orbY, orbSize * 2.5 * orbPulse, 0, Math.PI * 2);
  ctx.fill();

  // Main orb
  ctx.shadowColor = "#00ffff";
  ctx.shadowBlur = 30 * zoom * orbPulse;
  const orbGrad = ctx.createRadialGradient(
    screenPos.x - 3 * zoom,
    orbY - 3 * zoom,
    0,
    screenPos.x,
    orbY,
    orbSize * orbPulse
  );
  orbGrad.addColorStop(0, "#ffffff");
  orbGrad.addColorStop(0.2, "#ccffff");
  orbGrad.addColorStop(0.5, "#00ffff");
  orbGrad.addColorStop(0.8, "#0088ff");
  orbGrad.addColorStop(1, "#0044aa");
  ctx.fillStyle = orbGrad;
  ctx.beginPath();
  ctx.arc(screenPos.x, orbY, orbSize * orbPulse, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Electric arcs from orb - Enhanced with jagged multi-segment lightning
  const arcCount = 5 + tower.level;
  for (let i = 0; i < arcCount; i++) {
    const arcAngle = time * 2.5 + i * ((Math.PI * 2) / arcCount);
    const arcLength = (18 + Math.random() * 12) * zoom;
    const arcEndX = screenPos.x + Math.cos(arcAngle) * arcLength;
    const arcEndY = orbY + Math.sin(arcAngle) * arcLength * 0.4;

    ctx.strokeStyle = `rgba(0, 255, 255, ${0.4 + Math.random() * 0.4})`;
    ctx.lineWidth = 1.5 * zoom;
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 6 * zoom;

    // Multi-segment jagged lightning path
    ctx.beginPath();
    ctx.moveTo(screenPos.x, orbY);
    const segments = 4 + Math.floor(Math.random() * 3);
    let px = screenPos.x,
      py = orbY;
    for (let s = 1; s <= segments; s++) {
      const t = s / segments;
      const targetX = screenPos.x + (arcEndX - screenPos.x) * t;
      const targetY = orbY + (arcEndY - orbY) * t;
      const jitter = (1 - t) * 8 * zoom;
      const sx = targetX + (Math.random() - 0.5) * jitter;
      const sy = targetY + (Math.random() - 0.5) * jitter * 0.5;
      ctx.lineTo(sx, sy);
      px = sx;
      py = sy;
    }
    ctx.stroke();

    // Branch lightning for longer arcs
    if (arcLength > 22 * zoom && Math.random() > 0.5) {
      const branchStart = 0.4 + Math.random() * 0.3;
      const branchX = screenPos.x + (arcEndX - screenPos.x) * branchStart;
      const branchY = orbY + (arcEndY - orbY) * branchStart;
      const branchAngle = arcAngle + (Math.random() - 0.5) * 1.2;
      const branchLen = arcLength * 0.4;

      ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + Math.random() * 0.2})`;
      ctx.lineWidth = 1 * zoom;
      ctx.beginPath();
      ctx.moveTo(branchX, branchY);
      ctx.lineTo(
        branchX + Math.cos(branchAngle) * branchLen,
        branchY + Math.sin(branchAngle) * branchLen * 0.4
      );
      ctx.stroke();
    }
    ctx.shadowBlur = 0;
  }

  // Ground-level electricity crackling to nearby rings
  if (Date.now() - tower.lastAttack < 300) {
    for (let g = 0; g < 3; g++) {
      const groundArc = time * 12 + g * 2;
      const gx = screenPos.x + Math.sin(groundArc) * 10 * zoom;
      const gy = topY + 3 * zoom;

      ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + Math.random() * 0.3})`;
      ctx.lineWidth = 1 * zoom;
      ctx.shadowColor = "#00ffff";
      ctx.shadowBlur = 4 * zoom;
      ctx.beginPath();
      ctx.moveTo(screenPos.x, topY);
      ctx.lineTo(gx + (Math.random() - 0.5) * 4 * zoom, gy - 5 * zoom);
      ctx.lineTo(gx, gy);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
  }
}

function renderFocusedBeam(
  ctx: CanvasRenderingContext2D,
  screenPos: Position,
  topY: number,
  tower: Tower,
  zoom: number,
  time: number,
  enemies: Enemy[],
  selectedMap: string,
  canvasWidth: number,
  canvasHeight: number,
  dpr: number,
  cameraOffset?: Position,
  cameraZoom?: number
) {
  const coilHeight = 65 * zoom;
  const timeSinceFire = Date.now() - tower.lastAttack;
  const isAttacking = timeSinceFire < 400;
  const attackPulse = isAttacking
    ? Math.sin((timeSinceFire / 400) * Math.PI)
    : 0;

  // === MASSIVE ARCANE BASE ===
  // Dark iron foundation
  ctx.fillStyle = "#0a1a2a";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    topY + 8 * zoom,
    28 * zoom,
    14 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Glowing rune circle on base
  ctx.strokeStyle = `rgba(0, 255, 255, ${
    0.3 + Math.sin(time * 2) * 0.15 + attackPulse * 0.4
  })`;
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    topY + 6 * zoom,
    24 * zoom,
    12 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.stroke();

  // Arcane runes around base
  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2 + time * 0.5;
    const runeX = screenPos.x + Math.cos(angle) * 22 * zoom;
    const runeY = topY + 6 * zoom + Math.sin(angle) * 11 * zoom;
    const runeGlow = 0.4 + Math.sin(time * 3 + i) * 0.2 + attackPulse * 0.5;

    ctx.fillStyle = `rgba(0, 255, 255, ${runeGlow})`;
    ctx.font = `${8 * zoom}px serif`;
    ctx.textAlign = "center";
    ctx.fillText(["", "", "", "", "", ""][i], runeX, runeY);
  }

  // Elevated tech platform
  ctx.fillStyle = "#1a3a4f";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    topY + 3 * zoom,
    22 * zoom,
    11 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Platform machinery details
  ctx.strokeStyle = "#2a5a7f";
  ctx.lineWidth = 1 * zoom;
  for (let i = 0; i < 5; i++) {
    const detailAngle = (i / 5) * Math.PI * 2 + time;
    const detailX = screenPos.x + Math.cos(detailAngle) * 18 * zoom;
    const detailY = topY + 3 * zoom + Math.sin(detailAngle) * 9 * zoom;
    ctx.beginPath();
    ctx.moveTo(screenPos.x, topY + 3 * zoom);
    ctx.lineTo(detailX, detailY);
    ctx.stroke();
  }

  // === SUPPORT PYLONS ===
  for (let i = -1; i <= 1; i += 2) {
    const pylonX = screenPos.x + i * 12 * zoom;

    // Pylon body
    ctx.fillStyle = "#2d5a7b";
    ctx.beginPath();
    ctx.moveTo(pylonX - 4 * zoom, topY);
    ctx.lineTo(pylonX - 2 * zoom, topY - coilHeight + 20 * zoom);
    ctx.lineTo(pylonX + 2 * zoom, topY - coilHeight + 20 * zoom);
    ctx.lineTo(pylonX + 4 * zoom, topY);
    ctx.closePath();
    ctx.fill();

    // Energy conduit on pylon
    const conduitGlow = 0.5 + Math.sin(time * 4 + i) * 0.3 + attackPulse * 0.5;
    ctx.strokeStyle = `rgba(0, 255, 255, ${conduitGlow})`;
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.moveTo(pylonX, topY - 5 * zoom);
    ctx.lineTo(pylonX, topY - coilHeight + 25 * zoom);
    ctx.stroke();

    // Pylon energy node
    ctx.fillStyle = `rgba(0, 255, 255, ${conduitGlow})`;
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 8 * zoom;
    ctx.beginPath();
    ctx.arc(pylonX, topY - coilHeight + 22 * zoom, 4 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  //support pylon amplifiers
  for (let i = 0; i < 4; i++) {
    const ampAngle = (i / 4) * Math.PI * 2 + time;
    const ampX = screenPos.x + Math.cos(ampAngle) * 16 * zoom;
    const ampY = topY - 4 * zoom + Math.sin(ampAngle) * 8 * zoom;
    ctx.fillStyle = "#2d5a7b";
    ctx.beginPath();
    ctx.ellipse(ampX, ampY, 4 * zoom, 8 * zoom, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // tesla coils on platform corners
  for (let i = 0; i < 4; i++) {
    const coilAngle = (i / 4) * Math.PI * 2 + time;
    const coilX = screenPos.x + Math.cos(coilAngle) * 16 * zoom;
    const coilY = topY - 4 * zoom + Math.sin(coilAngle) * 8 * zoom;
    ctx.fillStyle = "#2d5a7b";
    ctx.beginPath();
    ctx.ellipse(coilX, coilY, 4 * zoom, 8 * zoom, 0, 0, Math.PI * 2);
    ctx.fill();

    // add actual copper coils
    const coilTurns = 5;
    for (let j = 0; j < coilTurns; j++) {
      const turnY = coilY - 6 * zoom + (j / coilTurns) * (12 * zoom);
      const turnGlow = 0.3 + Math.sin(time * 4 + j) * 0.2 + attackPulse * 0.4;
      ctx.strokeStyle = `rgba(184, 115, 51, ${turnGlow})`;
      ctx.lineWidth = 2 * zoom;
      ctx.beginPath();
      ctx.ellipse(coilX, turnY, 3 * zoom, 1.2 * zoom, 0, 0, Math.PI * 2);
      ctx.stroke();
    }

    // lightning from the amplifieer coils hits the dish. make it very random and energetic
    const lightningGlow = 0.5 + Math.random() * 0.5 + attackPulse * 0.5;
    ctx.strokeStyle = `rgba(0, 255, 255, ${lightningGlow})`;
    ctx.lineWidth = 1.5 * zoom;
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 6 * zoom;
    ctx.beginPath();
    ctx.moveTo(coilX, coilY - 6 * zoom);
    const segments = 5 + Math.floor(Math.random() * 3);
    let px = coilX,
      py = coilY - 6 * zoom;
    for (let s = 1; s <= segments; s++) {
      const t = s / segments;
      const targetX = screenPos.x + (coilX - screenPos.x) * (1 - t) * 0.3;
      const targetY =
        topY -
        coilHeight +
        12 * zoom +
        (coilY - (topY - coilHeight + 12 * zoom)) * (1 - t) * 0.3;
      const jitter = (1 - t) * 8 * zoom;
      const sx = targetX + (Math.random() - 0.5) * jitter;
      const sy = targetY + (Math.random() - 0.5) * jitter * 0.5;
      ctx.lineTo(sx, sy);
    }
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  // ring below pylon amplifiers
  const ringGlow = 0.4 + Math.sin(time * 3) * 0.2 + attackPulse * 0.5;
  ctx.strokeStyle = `rgba(0, 255, 255, ${ringGlow})`;
  ctx.lineWidth = 2 * zoom;
  for (let i = 0; i < 4; i++) {
    const ringAngle = (i / 4) * Math.PI * 2 + time;
    const ringX = screenPos.x + Math.cos(ringAngle) * 16 * zoom;
    const ringY = topY + 12 * zoom + Math.sin(ringAngle) * 8 * zoom - 10 * zoom;
    ctx.beginPath();
    ctx.ellipse(ringX, ringY, 6 * zoom, 3 * zoom, 0, 0, Math.PI * 2);
    ctx.stroke();
  }

  // === MASSIVE FOCUSING DISH ===
  // Outer dish ring
  const dishY = topY - coilHeight + 12 * zoom;
  const dishSize = 28 + attackPulse * 4;

  ctx.fillStyle = "#1a3a4f";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    dishY,
    dishSize * zoom,
    dishSize * 0.72 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Dish metallic gradient
  const dishGrad = ctx.createRadialGradient(
    screenPos.x - 8 * zoom,
    dishY - 4 * zoom,
    0,
    screenPos.x,
    dishY,
    dishSize * zoom
  );
  dishGrad.addColorStop(0, "#5d9abe");
  dishGrad.addColorStop(0.4, "#3d7a9e");
  dishGrad.addColorStop(0.8, "#2d5a7b");
  dishGrad.addColorStop(1, "#1a3a4f");
  ctx.fillStyle = dishGrad;
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    dishY,
    (dishSize - 3) * zoom,
    (dishSize * 0.72 - 2) * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Inner dish concentric rings
  for (let ring = 0; ring < 3; ring++) {
    const ringSize = dishSize - 8 - ring * 5;
    const ringGlow = 0.2 + Math.sin(time * 3 + ring) * 0.1 + attackPulse * 0.3;
    ctx.strokeStyle = `rgba(0, 255, 255, ${ringGlow})`;
    ctx.lineWidth = 1 * zoom;
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      dishY,
      ringSize * zoom,
      ringSize * 0.72 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.stroke();
  }

  // === CENTRAL FOCUS CRYSTAL ===
  const crystalY = dishY - 5 * zoom;
  const crystalPulse = 1 + Math.sin(time * 5) * 0.1 + attackPulse * 0.3;

  // Crystal housing
  ctx.fillStyle = "#2d5a7b";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    crystalY + 8 * zoom,
    8 * zoom,
    4 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Floating crystal shards
  for (let i = 0; i < 4; i++) {
    const shardAngle = (i / 4) * Math.PI * 2 + time * 2;
    const shardDist = 15 + Math.sin(time * 3 + i * 1.5) * 3;
    const shardX = screenPos.x + Math.cos(shardAngle) * shardDist * zoom;
    const shardY = crystalY + Math.sin(shardAngle) * shardDist * 0.4 * zoom;

    ctx.fillStyle = `rgba(0, 255, 255, ${0.6 + attackPulse * 0.4})`;
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 6 * zoom;
    ctx.beginPath();
    ctx.moveTo(shardX, shardY - 5 * zoom);
    ctx.lineTo(shardX - 2 * zoom, shardY);
    ctx.lineTo(shardX, shardY + 3 * zoom);
    ctx.lineTo(shardX + 2 * zoom, shardY);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Main crystal core
  ctx.fillStyle = "#00ffff";
  ctx.shadowColor = "#00ffff";
  ctx.shadowBlur = (20 + attackPulse * 15) * zoom;
  ctx.beginPath();
  ctx.arc(screenPos.x, crystalY, 10 * crystalPulse * zoom, 0, Math.PI * 2);
  ctx.fill();

  // Inner crystal glow
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.arc(screenPos.x, crystalY, 5 * crystalPulse * zoom, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Store emitter position
  tower._orbScreenY = crystalY;

  // === CRACKLING ENERGY ARCS ===
  for (let i = 0; i < 12; i++) {
    const angle = time * 3 + i * (Math.PI / 6);
    const dist = 20 + Math.sin(time * 6 + i) * 5;
    const ex = screenPos.x + Math.cos(angle) * dist * zoom;
    const ey = dishY + Math.sin(angle) * dist * 0.5 * zoom;

    ctx.strokeStyle = `rgba(0, 255, 255, ${
      0.4 + Math.random() * 0.3 + attackPulse * 0.3
    })`;
    ctx.lineWidth = (1 + attackPulse) * zoom;
    ctx.beginPath();
    ctx.moveTo(screenPos.x, crystalY);
    // Jagged lightning path
    const midX =
      screenPos.x + (ex - screenPos.x) * 0.5 + (Math.random() - 0.5) * 8 * zoom;
    const midY =
      crystalY + (ey - crystalY) * 0.5 + (Math.random() - 0.5) * 4 * zoom;
    ctx.lineTo(midX, midY);
    ctx.lineTo(ex, ey);
    ctx.stroke();
  }

  // === BEAM CHARGING EFFECT ===
  if (isAttacking) {
    const beamPhase = timeSinceFire / 400;

    // Expanding energy rings
    for (let ring = 0; ring < 3; ring++) {
      const ringPhase = (beamPhase + ring * 0.15) % 1;
      const ringRadius = 5 + ringPhase * 25;
      const ringAlpha = (1 - ringPhase) * 0.6;

      ctx.strokeStyle = `rgba(0, 255, 255, ${ringAlpha})`;
      ctx.lineWidth = 2 * zoom * (1 - ringPhase);
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        crystalY,
        ringRadius * zoom,
        ringRadius * 0.5 * zoom,
        0,
        0,
        Math.PI * 2
      );
      ctx.stroke();
    }

    // Core flash
    ctx.fillStyle = `rgba(255, 255, 255, ${(1 - beamPhase) * 0.8})`;
    ctx.beginPath();
    ctx.arc(
      screenPos.x,
      crystalY,
      15 * (1 - beamPhase * 0.5) * zoom,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }
}

function renderChainLightning(
  ctx: CanvasRenderingContext2D,
  screenPos: Position,
  topY: number,
  tower: Tower,
  zoom: number,
  time: number
) {
  const coilHeight = 65 * zoom;
  const timeSinceFire = Date.now() - tower.lastAttack;
  const isAttacking = timeSinceFire < 400;
  const attackPulse = isAttacking
    ? Math.sin((timeSinceFire / 400) * Math.PI)
    : 0;

  // Base platform
  ctx.fillStyle = "#1a3a4f";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    topY + 5 * zoom,
    22 * zoom,
    11 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // === MASSIVE ARCANE BASE ===
  // Dark iron foundation
  ctx.fillStyle = "#0a1a2a";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    topY + 8 * zoom,
    28 * zoom,
    14 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Glowing tech modules that pulse the base
  ctx.strokeStyle = `rgba(0, 255, 255, ${
    0.3 + Math.sin(time * 2) * 0.15 + attackPulse * 0.4
  })`;
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    topY + 6 * zoom,
    24 * zoom,
    12 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.stroke();

  // Elevated tech platform
  ctx.fillStyle = "#1a3a4f";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    topY + 3 * zoom,
    22 * zoom,
    11 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // machinery on foundation platform (not a spinning thing)
  ctx.strokeStyle = "#2a5a7f";
  ctx.lineWidth = 1 * zoom;
  for (let i = 0; i < 5; i++) {
    const detailAngle = (i / 5) * Math.PI * 2 + time;
    const detailX = screenPos.x + Math.cos(detailAngle) * 18 * zoom;
    const detailY = topY + 3 * zoom + Math.sin(detailAngle) * 9 * zoom;
    ctx.beginPath();
    ctx.moveTo(screenPos.x, topY + 3 * zoom);
    ctx.lineTo(detailX, detailY);
    ctx.stroke();
  }

  // Central pillar
  ctx.fillStyle = "#2d5a7b";
  ctx.beginPath();
  ctx.moveTo(screenPos.x - 6 * zoom, topY);
  ctx.lineTo(screenPos.x - 4 * zoom, topY - coilHeight + 20 * zoom);
  ctx.lineTo(screenPos.x + 4 * zoom, topY - coilHeight + 20 * zoom);
  ctx.lineTo(screenPos.x + 6 * zoom, topY);
  ctx.closePath();
  ctx.fill();

  // Multiple smaller coils around the main one
  const coilPositions = [
    { x: -16, y: 0, size: 0.7 },
    { x: 16, y: 0, size: 0.7 },
    { x: 0, y: -10, size: 0.8 },
    { x: 0, y: 10, size: 0.6 },
  ];

  for (const pos of coilPositions) {
    const cx = screenPos.x + pos.x * zoom;
    const cy = topY + pos.y * zoom;
    const coilSize = pos.size;

    // Mini coil base
    ctx.fillStyle = "#1a3a4f";
    ctx.beginPath();
    ctx.ellipse(
      cx,
      cy,
      8 * zoom * coilSize,
      4 * zoom * coilSize,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // big amplifier/vents on top of the main circle
    ctx.fillStyle = "#3a6a8f";
    ctx.beginPath();
    ctx.ellipse(
      cx,
      cy - 2 * zoom * coilSize,
      10 * zoom * coilSize,
      5 * zoom * coilSize,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // tech circles under pylons
    ctx.fillStyle = "#2a4a5f";
    ctx.beginPath();
    ctx.ellipse(
      cx,
      cy - 1 * zoom * coilSize,
      6 * zoom * coilSize,
      3 * zoom * coilSize,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Mini coil pillar
    ctx.fillStyle = "#2d5a7b";
    ctx.fillRect(
      cx - 3 * zoom * coilSize,
      cy - 20 * zoom * coilSize,
      6 * zoom * coilSize,
      20 * zoom * coilSize
    );

    // add copper coils to pylons
    const coilTurns = 4;
    for (let j = 0; j < coilTurns; j++) {
      const turnY =
        cy - 10 * zoom * coilSize + (j / coilTurns) * (12 * zoom * coilSize);
      const turnGlow = 0.3 + Math.sin(time * 4 + j) * 0.2 + attackPulse * 0.4;
      ctx.strokeStyle = `rgba(184, 115, 51, ${turnGlow})`;
      ctx.lineWidth = 2 * zoom * coilSize;
      ctx.beginPath();
      ctx.ellipse(
        cx,
        turnY,
        5 * zoom * coilSize,
        2 * zoom * coilSize,
        0,
        0,
        Math.PI * 2
      );
      ctx.stroke();
    }

    // Mini orb using attackPulse
    const pulse = 0.8 + Math.sin(time * 6 + pos.x) * 0.2 + attackPulse * 0.3;
    ctx.fillStyle = "rgba(0, 255, 255, 0.8)";
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 10 * zoom;
    ctx.beginPath();
    ctx.arc(
      cx,
      cy - 25 * zoom * coilSize,
      6 * zoom * pulse * coilSize,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Central main orb
  // flash when using attackpulse
  const mainOrbY = topY - coilHeight + 4 * zoom - attackPulse * 5 * zoom;
  const mainOrbPulse = 0.9 + Math.sin(time * 5) * 0.2 + attackPulse * 0.3;
  ctx.fillStyle = "rgba(0, 255, 255, 0.9)";
  ctx.shadowColor = "#00ffff";
  ctx.shadowBlur = 20 * zoom * mainOrbPulse;
  ctx.beginPath();
  ctx.arc(screenPos.x, mainOrbY, 12 * zoom * mainOrbPulse, 0, Math.PI * 2);
  ctx.fill();

  // white flash in orb
  if (attackPulse > 0.1) {
    ctx.fillStyle = `rgba(255, 255, 255, ${attackPulse})`;
    ctx.beginPath();
    ctx.arc(screenPos.x, mainOrbY, 8 * zoom * mainOrbPulse, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.shadowBlur = 0;

  // orb random lightning flashes
  if (Math.random() < 0.1) {
    ctx.strokeStyle = "rgba(0, 255, 255, 0.8)";
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.moveTo(screenPos.x, mainOrbY);
    const flashX = screenPos.x + (Math.random() - 0.5) * 80 * zoom;
    const flashY = mainOrbY + (Math.random() - 0.5) * 20 * zoom;
    ctx.lineTo(flashX, flashY);
    ctx.stroke();
  }

  // Store orb position
  tower._orbScreenY = mainOrbY;

  // Connecting arcs between coils
  // using attackPulse
  ctx.strokeStyle = "rgba(0, 255, 255, 0.6)";
  for (let i = 0; i < coilPositions.length; i++) {
    const pos = coilPositions[i];
    const cx = screenPos.x + pos.x * zoom;
    const cy = topY + pos.y * zoom - 25 * zoom * pos.size;

    // Draw arcs to center
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    const midX =
      screenPos.x +
      (cx - screenPos.x) * 0.5 +
      (Math.random() - 0.5) * 10 * zoom;
    const midY =
      mainOrbY + (cy - mainOrbY) * 0.5 + (Math.random() - 0.5) * 5 * zoom;
    ctx.lineTo(midX, midY);
    ctx.lineTo(screenPos.x, mainOrbY);
    ctx.stroke();
  }
}

// ARCH TOWER
function renderArchTower(
  ctx: CanvasRenderingContext2D,
  screenPos: Position,
  tower: Tower,
  zoom: number,
  time: number,
  colors: { base: string; dark: string; light: string; accent: string }
) {
  ctx.save();
  // Shift the entire building up slightly
  screenPos = { x: screenPos.x, y: screenPos.y - 8 * zoom };
  const baseWidth = 38 + tower.level * 5;
  const baseDepth = 30 + tower.level * 4;
  const baseHeight = 16 + tower.level * 6;
  const w = baseWidth * zoom * 0.5;
  const d = baseDepth * zoom * 0.25;

  const isShockwave = tower.level === 4 && tower.upgrade === "A";
  const isSymphony = tower.level === 4 && tower.upgrade === "B";

  let mainColor = "rgba(50, 200, 100,";
  // change color from rgba(50, 200, 100) to ice blue if symphony and red if shockwave
  if (isShockwave) {
    mainColor = "rgba(255, 100, 100,";
  } else if (isSymphony) {
    mainColor = "rgba(100, 200, 255,";
  }

  // Dynamic attack animation - everything moves and pulses
  const timeSinceFire = Date.now() - tower.lastAttack;
  let attackPulse = 0;
  let archVibrate = 0;
  let pillarSpread = 0;
  let pillarBounce = 0;
  let foundationShift = 0;
  let archLift = 0;
  let portalExpand = 0;

  if (timeSinceFire < 600) {
    const attackPhase = timeSinceFire / 600;
    attackPulse = (1 - attackPhase) * 0.6;

    // Arch vibrates rapidly
    archVibrate =
      Math.sin(attackPhase * Math.PI * 12) * (1 - attackPhase) * 4 * zoom;

    // Pillars spread outward then return
    if (attackPhase < 0.3) {
      pillarSpread = (attackPhase / 0.3) * 6 * zoom;
      pillarBounce = Math.sin(attackPhase * Math.PI * 10) * 3 * zoom;
    } else {
      pillarSpread = 6 * zoom * (1 - (attackPhase - 0.3) / 0.7);
      pillarBounce =
        Math.sin(attackPhase * Math.PI * 6) * (1 - attackPhase) * 2 * zoom;
    }

    // Foundation shifts slightly
    foundationShift =
      Math.sin(attackPhase * Math.PI * 8) * (1 - attackPhase) * 2 * zoom;

    // Arch lifts up during attack
    if (attackPhase < 0.2) {
      archLift = (attackPhase / 0.2) * 5 * zoom;
    } else {
      archLift = 5 * zoom * (1 - (attackPhase - 0.2) / 0.8);
    }

    // Portal expands during attack
    portalExpand = Math.sin(attackPhase * Math.PI) * 8 * zoom;
  }

  // Ambient floating animation
  const floatOffset = Math.sin(time * 2) * 2 * zoom;
  const pulseSize = 1 + Math.sin(time * 3) * 0.02;

  // === EXTENDED BUILDING BASE - Gothic collegiate structure ===
  // Lower sub-building with animated components
  const subBuildingWidth = baseWidth + 20;
  const subBuildingHeight = 18;
  const subBounce =
    isShockwave || isSymphony
      ? Math.sin(time * 6) * 2 * zoom
      : Math.sin(time * 3) * 1 * zoom;

  // Lower foundation block
  drawIsometricPrism(
    ctx,
    screenPos.x + foundationShift * 0.3,
    screenPos.y + 16 * zoom,
    subBuildingWidth,
    baseDepth + 28,
    12,
    {
      top: "#786858",
      left: "#685848",
      right: "#584838",
      leftBack: "#887868",
      rightBack: "#786858",
    },
    zoom
  );

  // Sub-building main structure (moves during attack)
  const subShift =
    timeSinceFire < 600
      ? Math.sin((timeSinceFire / 600) * Math.PI * 6) *
        2 *
        zoom *
        (1 - timeSinceFire / 600)
      : 0;
  drawIsometricPrism(
    ctx,
    screenPos.x + foundationShift * 0.4 + subShift,
    screenPos.y + 2 * zoom + subBounce,
    subBuildingWidth - 6,
    baseDepth + 22,
    subBuildingHeight,
    {
      top: "#a89878",
      left: "#988868",
      right: "#887858",
      leftBack: "#b8a888",
      rightBack: "#a89878",
    },
    zoom
  );

  // Gothic windows on sub-building (glow during attack)
  const windowGlowBase = 0.3 + Math.sin(time * 2) * 0.15 + attackPulse * 0.5;
  for (let side = -1; side <= 1; side += 2) {
    for (let row = 0; row < 2; row++) {
      const winX = screenPos.x + side * 16 * zoom + subShift * 0.5;
      const winY = screenPos.y + 2 + subBounce - row * 8 * zoom;

      // Gothic pointed arch window
      ctx.fillStyle = `${mainColor} ${windowGlowBase})`;
      ctx.beginPath();
      ctx.moveTo(winX - 3 * zoom, winY + 4 * zoom);
      ctx.lineTo(winX - 3 * zoom, winY);
      ctx.quadraticCurveTo(winX, winY - 4 * zoom, winX + 3 * zoom, winY);
      ctx.lineTo(winX + 3 * zoom, winY + 4 * zoom);
      ctx.closePath();
      ctx.fill();
    }
  }

  // Mechanical resonance chambers on sides (animate during attack)
  const chamberPulse = 0.5 + attackPulse;
  for (let side = -1; side <= 1; side += 2) {
    const chamberX =
      screenPos.x +
      side * (subBuildingWidth * 0.4) * zoom +
      subShift * side * 0.3;
    const chamberY = screenPos.y + 8 * zoom + subBounce;
    const chamberRotate =
      timeSinceFire < 600
        ? Math.sin(timeSinceFire / 100) * 0.2 * (1 - timeSinceFire / 600)
        : 0;

    ctx.save();
    ctx.translate(chamberX, chamberY);
    ctx.rotate(chamberRotate * side);

    // Resonance drum
    ctx.fillStyle = "#5a4a3a";
    ctx.beginPath();
    ctx.ellipse(0, 0, 6 * zoom, 4 * zoom, 0.3 * side, 0, Math.PI * 2);
    ctx.fill();

    // Glowing membrane
    ctx.fillStyle = `${mainColor} ${chamberPulse})`;
    ctx.beginPath();
    ctx.ellipse(
      0,
      0,
      4 * zoom * (1 + attackPulse * 0.3),
      2.5 * zoom * (1 + attackPulse * 0.3),
      0.3 * side,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Energy rings during attack
    if (timeSinceFire < 400) {
      const ringPhase = timeSinceFire / 400;
      ctx.strokeStyle = `${mainColor} ${(1 - ringPhase) * 0.6})`;
      ctx.lineWidth = 1.5 * zoom;
      ctx.beginPath();
      ctx.ellipse(
        0,
        0,
        (6 + ringPhase * 8) * zoom,
        (4 + ringPhase * 5) * zoom,
        0.3 * side,
        0,
        Math.PI * 2
      );
      ctx.stroke();
    }
    ctx.restore();
  }

  // Energy conduit pipes connecting to pillars (pulse during attack)
  const pipeGlow = 0.3 + attackPulse * 0.6;
  ctx.strokeStyle = `${mainColor} ${pipeGlow})`;
  ctx.lineWidth = 2 * zoom;
  for (let side = -1; side <= 1; side += 2) {
    const pipeStartX = screenPos.x + side * 28 * zoom;
    const pipeEndX = screenPos.x + side * (baseWidth * 0.35) * zoom;
    ctx.beginPath();
    ctx.moveTo(pipeStartX + subShift * 0.3, screenPos.y + 9 * zoom + subBounce);
    ctx.quadraticCurveTo(
      screenPos.x + side * 30 * zoom,
      screenPos.y - 5 * zoom,
      pipeEndX - pillarSpread * side * 0.3,
      screenPos.y - 10 * zoom
    );
    ctx.stroke();

    // Pipe energy nodes
    const nodeY = screenPos.y - 2 * zoom;
    ctx.fillStyle = `${mainColor} ${pipeGlow + 0.2})`;
    ctx.beginPath();
    ctx.arc(
      screenPos.x + side * 22 * zoom,
      nodeY,
      2 * zoom * (1 + attackPulse * 0.5),
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  // Tan foundation platform with green tech accents (shifts during attack)
  drawIsometricPrism(
    ctx,
    screenPos.x + foundationShift * 0.5,
    screenPos.y - 18 * zoom,
    //make this platform expand with the pillars
    baseWidth + 12 + pillarSpread * 2,
    baseDepth + 18 + pillarSpread * 2,
    6,
    {
      top: "#a89880",
      left: "#988870",
      right: "#887860",
      leftBack: "#b8a890",
      rightBack: "#a89880",
    },
    zoom
  );

  // Green tech panel lines on foundation (flipped)
  const panelGlow = 0.4 + Math.sin(time * 3) * 0.2 + attackPulse;
  ctx.strokeStyle = `${mainColor} ${panelGlow})`;
  ctx.lineWidth = 1 * zoom;

  for (let i = 1; i <= 2; i++) {
    const lineY = screenPos.y - 16 * zoom - i * 4 * zoom;
    ctx.beginPath();
    ctx.moveTo(screenPos.x - w * 0.2, lineY + d * 0.3);
    ctx.lineTo(screenPos.x - w * 0.9, lineY - d * 0.2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(screenPos.x + w * 0.9, lineY - d * 0.2);
    ctx.lineTo(screenPos.x + w * 0.2, lineY + d * 0.3);
    ctx.stroke();
  }

  // Tan pillars with green tech details - dynamic movement
  const pillarWidth = 14 + tower.level * 2;
  const pillarHeight = 35 + tower.level * 8;
  // Pillars spread outward and bounce during attack
  const pillarX =
    screenPos.x - baseWidth * zoom * 0.35 - archVibrate * 0.3 - pillarSpread;
  const pillarXR =
    screenPos.x + baseWidth * zoom * 0.35 + archVibrate * 0.3 + pillarSpread;
  const pw = pillarWidth * zoom * 0.5;
  const pd = pillarWidth * zoom * 0.25;

  // Left pillar - tan stone (bounces during attack)
  drawIsometricPrism(
    ctx,
    pillarX + pillarBounce * 0.5,
    screenPos.y - 24 * zoom - pillarBounce,
    pillarWidth * pulseSize,
    pillarWidth * pulseSize,
    pillarHeight,
    {
      top: "#c8b8a0",
      left: "#b8a890",
      right: "#a89880",
      leftBack: "#d8c8b0",
      rightBack: "#c8b8a0",
    },
    zoom
  );

  // Gothic stone block lines on left pillar
  ctx.strokeStyle = "#8a7a6a";
  ctx.lineWidth = 1 * zoom;
  for (let row = 0; row < 5; row++) {
    const blockY =
      screenPos.y - 28 - pillarBounce - row * pillarHeight * zoom * 0.18;
    ctx.beginPath();
    ctx.moveTo(pillarX + pillarBounce * 0.5 - pw * 0.9, blockY - pd * 0.3);
    ctx.lineTo(pillarX + pillarBounce * 0.5 + pw * 0.9, blockY + pd * 0.3);
    ctx.stroke();
  }

  // Pillar capital (decorative top) on left pillar
  const capitalY = screenPos.y - 24 - pillarHeight * zoom - pillarBounce;
  ctx.fillStyle = "#d8c8b0";
  ctx.beginPath();
  ctx.moveTo(pillarX + pillarBounce * 0.5 - pw * 1.3, capitalY + 4 * zoom);
  ctx.lineTo(pillarX + pillarBounce * 0.5 - pw * 0.9, capitalY - 2 * zoom);
  ctx.lineTo(pillarX + pillarBounce * 0.5 + pw * 0.9, capitalY - 2 * zoom);
  ctx.lineTo(pillarX + pillarBounce * 0.5 + pw * 1.3, capitalY + 4 * zoom);
  ctx.closePath();
  ctx.fill();

  // Right pillar - tan stone (bounces opposite direction)
  drawIsometricPrism(
    ctx,
    pillarXR - pillarBounce * 0.5,
    screenPos.y - 24 * zoom - pillarBounce,
    pillarWidth * pulseSize,
    pillarWidth * pulseSize,
    pillarHeight,
    {
      top: "#c8b8a0",
      left: "#b8a890",
      right: "#a89880",
      leftBack: "#d8c8b0",
      rightBack: "#c8b8a0",
    },
    zoom
  );

  // Gothic stone block lines on right pillar
  for (let row = 0; row < 5; row++) {
    const blockY =
      screenPos.y - 28 - pillarBounce - row * pillarHeight * zoom * 0.18;
    ctx.beginPath();
    ctx.moveTo(pillarXR - pillarBounce * 0.5 - pw * 0.9, blockY - pd * 0.3);
    ctx.lineTo(pillarXR - pillarBounce * 0.5 + pw * 0.9, blockY + pd * 0.3);
    ctx.stroke();
  }

  // Pillar capital on right pillar
  ctx.fillStyle = "#d8c8b0";
  ctx.beginPath();
  ctx.moveTo(pillarXR - pillarBounce * 0.5 - pw * 1.3, capitalY + 4 * zoom);
  ctx.lineTo(pillarXR - pillarBounce * 0.5 - pw * 0.9, capitalY - 2 * zoom);
  ctx.lineTo(pillarXR - pillarBounce * 0.5 + pw * 0.9, capitalY - 2 * zoom);
  ctx.lineTo(pillarXR - pillarBounce * 0.5 + pw * 1.3, capitalY + 4 * zoom);
  ctx.closePath();
  ctx.fill();

  // Green glowing strips on pillars (more intense during attack)
  for (let p of [pillarX + pillarBounce * 0.5, pillarXR - pillarBounce * 0.5]) {
    for (let i = 0; i < tower.level + 1; i++) {
      const stripY =
        screenPos.y -
        20 * zoom -
        pillarHeight * zoom * (0.2 + i * 0.25) -
        pillarBounce;
      const stripGlow =
        0.4 + Math.sin(time * 4 + i * 0.5) * 0.3 + attackPulse * 1.5;

      ctx.fillStyle = `${mainColor} ${stripGlow})`;
      ctx.beginPath();
      ctx.ellipse(
        p - pw * 0.5,
        stripY + pd * 0.2,
        3 * zoom,
        1.5 * zoom,
        0.4,
        0,
        Math.PI * 2
      );
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(
        p + pw * 0.5,
        stripY + pd * 0.2,
        3 * zoom,
        1.5 * zoom,
        -0.4,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }
  }

  // Arch position with lift animation
  const archTopY =
    screenPos.y -
    24 * zoom -
    pillarHeight * zoom -
    6 * zoom +
    archVibrate * 0.5 -
    archLift -
    pillarBounce;
  const archCenterY = archTopY + 8 * zoom;

  // Tan arch structure with green energy conduits (vibrates during attack)
  ctx.strokeStyle = "#a89880";
  ctx.lineWidth = (14 + attackPulse * 4) * zoom;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(pillarX + pillarBounce * 0.5, archTopY + 8 * zoom);
  ctx.quadraticCurveTo(
    screenPos.x + archVibrate,
    archTopY - 28 * zoom - archLift,
    pillarXR - pillarBounce * 0.5,
    archTopY + 8 * zoom
  );
  ctx.stroke();

  ctx.strokeStyle = "#c8b8a0";
  ctx.lineWidth = (10 + attackPulse * 2) * zoom;
  ctx.beginPath();
  ctx.moveTo(pillarX + pillarBounce * 0.5, archTopY + 6 * zoom);
  ctx.quadraticCurveTo(
    screenPos.x + archVibrate,
    archTopY - 18 * zoom - archLift,
    pillarXR - pillarBounce * 0.5,
    archTopY + 6 * zoom
  );
  ctx.quadraticCurveTo(
    screenPos.x + archVibrate,
    archTopY - 18 * zoom - archLift,
    pillarXR - pillarBounce * 0.5,
    archTopY + 6 * zoom
  );
  ctx.stroke();

  // Green energy conduit along arch (pulses brighter during attack)
  const conduitGlow = 0.5 + Math.sin(time * 5) * 0.3 + attackPulse * 1.5;
  ctx.strokeStyle = `rgba(50, 200, 100, ${conduitGlow})`;
  ctx.lineWidth = (2 + attackPulse * 3) * zoom;
  ctx.beginPath();
  ctx.moveTo(pillarX + pillarBounce * 0.5, archTopY + 4 * zoom);
  ctx.quadraticCurveTo(
    screenPos.x + archVibrate,
    archTopY - 16 * zoom - archLift,
    pillarXR - pillarBounce * 0.5,
    archTopY + 4 * zoom
  );
  ctx.stroke();

  // Tan keystone with green energy core (moves with arch)
  const keystoneY = archTopY - archLift;
  ctx.fillStyle = "#d8c8b0";
  ctx.beginPath();
  ctx.moveTo(screenPos.x + archVibrate - 8 * zoom, keystoneY - 10 * zoom);
  ctx.lineTo(screenPos.x + archVibrate, keystoneY - 22 * zoom);
  ctx.lineTo(screenPos.x + archVibrate + 8 * zoom, keystoneY - 10 * zoom);
  ctx.lineTo(screenPos.x + archVibrate + 6 * zoom, keystoneY - 4 * zoom);
  ctx.lineTo(screenPos.x + archVibrate - 6 * zoom, keystoneY - 4 * zoom);
  ctx.closePath();
  ctx.fill();

  // Green keystone energy core
  const coreGrad = ctx.createRadialGradient(
    screenPos.x + archVibrate,
    keystoneY - 12 * zoom,
    0,
    screenPos.x + archVibrate,
    keystoneY - 12 * zoom,
    (5 + attackPulse * 3) * zoom
  );
  const glowColor = isShockwave
    ? "255, 100, 100"
    : isSymphony
    ? "100, 200, 255"
    : "50, 200, 100";
  coreGrad.addColorStop(0, `rgba(${glowColor}, ${conduitGlow})`);
  coreGrad.addColorStop(0.5, `rgba(${glowColor}, ${conduitGlow * 0.5})`);
  coreGrad.addColorStop(1, `rgba(${glowColor}, 0)`);
  ctx.fillStyle = coreGrad;
  ctx.beginPath();
  ctx.arc(
    screenPos.x + archVibrate,
    keystoneY - 12 * zoom,
    (5 + attackPulse * 3) * zoom,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Inner portal glow - green tinted (expands during attack)
  const glowIntensity = 0.5 + Math.sin(time * 3) * 0.3 + attackPulse;
  const portalSizeX = 22 * zoom + portalExpand;
  const portalSizeY = 30 * zoom + portalExpand * 1.2;

  const portalGrad = ctx.createRadialGradient(
    screenPos.x,
    archCenterY,
    0,
    screenPos.x,
    archCenterY,
    portalSizeY
  );
  portalGrad.addColorStop(0, `rgba(${glowColor}, ${glowIntensity * 0.5})`);
  portalGrad.addColorStop(0.5, `rgba(${glowColor}, ${glowIntensity * 0.25})`);
  portalGrad.addColorStop(1, `rgba(${glowColor}, 0)`);
  ctx.fillStyle = portalGrad;
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    archCenterY,
    portalSizeX,
    portalSizeY,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // EPIC SWIRLING VORTEX EFFECT
  const vortexSpeed = time * 3;
  for (let spiral = 0; spiral < 3; spiral++) {
    const spiralOffset = (spiral / 3) * Math.PI * 2;
    ctx.strokeStyle = `rgba(${glowColor}, ${
      0.3 + Math.sin(time * 4 + spiral) * 0.15 + attackPulse * 0.3
    })`;
    ctx.lineWidth = (2 - spiral * 0.5) * zoom;
    ctx.beginPath();

    for (let i = 0; i <= 20; i++) {
      const t = i / 20;
      const angle = vortexSpeed + spiralOffset + t * Math.PI * 3;
      const radius = t * portalSizeX * 0.9;
      const x = screenPos.x + Math.cos(angle) * radius;
      const y =
        archCenterY + Math.sin(angle) * radius * (portalSizeY / portalSizeX);

      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
  }

  // Inner swirl particles
  for (let p = 0; p < 8; p++) {
    const particleAngle = vortexSpeed * 1.5 + (p / 8) * Math.PI * 2;
    const particleRadius = portalSizeX * (0.3 + Math.sin(time * 5 + p) * 0.2);
    const px = screenPos.x + Math.cos(particleAngle) * particleRadius;
    const py =
      archCenterY +
      Math.sin(particleAngle) * particleRadius * (portalSizeY / portalSizeX);

    ctx.fillStyle = `rgba(${glowColor}, ${0.5 + Math.sin(time * 6 + p) * 0.3})`;
    ctx.shadowColor = `rgb(${glowColor})`;
    ctx.shadowBlur = 4 * zoom;
    ctx.beginPath();
    ctx.arc(px, py, (2 + Math.sin(time * 8 + p) * 1) * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Central energy core in portal
  const coreSize = (6 + Math.sin(time * 4) * 2 + attackPulse * 4) * zoom;
  const coreGrad2 = ctx.createRadialGradient(
    screenPos.x,
    archCenterY,
    0,
    screenPos.x,
    archCenterY,
    coreSize * 2
  );
  coreGrad2.addColorStop(0, `rgba(255, 255, 255, ${0.8 + attackPulse * 0.2})`);
  coreGrad2.addColorStop(0.3, `rgba(${glowColor}, ${0.6 + attackPulse * 0.3})`);
  coreGrad2.addColorStop(1, `rgba(${glowColor}, 0)`);
  ctx.fillStyle = coreGrad2;
  ctx.beginPath();
  ctx.arc(screenPos.x, archCenterY, coreSize * 2, 0, Math.PI * 2);
  ctx.fill();

  // Holographic scanlines in portal
  ctx.strokeStyle = `rgba(${glowColor}, ${glowIntensity * 0.3})`;
  ctx.lineWidth = 1 * zoom;
  for (let sl = 0; sl < 8; sl++) {
    const sly = archCenterY - 20 * zoom + sl * 5 * zoom;
    const slw = 18 - Math.abs(sl - 4) * 3;
    ctx.beginPath();
    ctx.moveTo(screenPos.x - slw * zoom, sly);
    ctx.lineTo(screenPos.x + slw * zoom, sly);
    ctx.stroke();
  }

  // Sound/energy waves - intensified during attack
  const waveCount = tower.level + 2;
  for (let i = 0; i < waveCount; i++) {
    const wavePhase = (time * 2 + i * 0.3) % 1;
    const waveRadius = 10 + wavePhase * 50;
    const waveAlpha =
      0.6 * (1 - wavePhase) * (glowIntensity + attackPulse * 0.5);

    ctx.strokeStyle = `rgba(${glowColor}, ${waveAlpha})`;
    ctx.lineWidth = (3 - wavePhase * 2) * zoom;
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      archCenterY - 5 * zoom,
      waveRadius * zoom * 0.8,
      waveRadius * zoom * 0.4,
      0,
      0,
      Math.PI * 2
    );
    ctx.stroke();
  }

  // Attack burst effect at portal center
  if (timeSinceFire < 300) {
    const burstPhase = timeSinceFire / 300;
    const burstAlpha = (1 - burstPhase) * 0.8;
    const burstSize = 15 + burstPhase * 20;

    ctx.fillStyle = `rgba(${glowColor}, ${burstAlpha})`;
    ctx.shadowColor = `rgb(${glowColor})`;
    ctx.shadowBlur = 15 * zoom;
    ctx.beginPath();
    ctx.arc(screenPos.x, archCenterY, burstSize * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Expanding ring
    ctx.strokeStyle = `rgba(${glowColor}, ${burstAlpha * 0.5})`;
    ctx.lineWidth = 3 * zoom * (1 - burstPhase);
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      archCenterY - 5 * zoom,
      (20 + burstPhase * 40) * zoom,
      (10 + burstPhase * 20) * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.stroke();
  }

  // Floating music notes around the arch (ambient)
  const particleCount = 6 + tower.level;
  for (let i = 0; i < particleCount; i++) {
    const notePhase = (time * 1.2 + i * 0.4) % 3;
    const noteAngle = (i / particleCount) * Math.PI * 2 + time * 0.6;
    const noteRadius = 22 + Math.sin(notePhase * Math.PI) * 12;
    const noteX = screenPos.x + Math.cos(noteAngle) * noteRadius * zoom * 0.9;
    const noteY =
      archCenterY -
      8 * zoom +
      Math.sin(noteAngle) * noteRadius * zoom * 0.45 -
      notePhase * 10 * zoom;
    const noteAlpha = Math.max(0, 1 - notePhase / 3) * 0.7;

    if (noteAlpha > 0.1) {
      // Draw music notes
      ctx.fillStyle = `rgba(${glowColor}, ${noteAlpha})`;
      ctx.shadowColor = `rgb(${glowColor})`;
      ctx.shadowBlur = 4 * zoom;
      ctx.font = `${(10 + Math.sin(time * 4 + i) * 2) * zoom}px Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      const symbols = ["", "", "", "", ""];
      ctx.fillText(symbols[i % 5], noteX, noteY);
      ctx.shadowBlur = 0;

      // Note trail
      ctx.strokeStyle = `rgba(${glowColor}, ${noteAlpha * 0.3})`;
      ctx.lineWidth = 1 * zoom;
      ctx.beginPath();
      ctx.moveTo(noteX, noteY);
      ctx.lineTo(
        noteX + Math.cos(noteAngle + Math.PI) * 10 * zoom,
        noteY + Math.sin(noteAngle + Math.PI) * 5 * zoom
      );
      ctx.stroke();
    }
  }

  // === SHOCKWAVE EMITTER (Level 4 Upgrade A) - EPIC DARK FANTASY ===
  if (isShockwave) {
    // Massive seismic generators on pillars
    for (let side = -1; side <= 1; side += 2) {
      const genX = screenPos.x + side * (baseWidth * 0.5) * zoom;
      const genY = screenPos.y - 25 * zoom;

      // Seismic core housing
      ctx.fillStyle = "#3a1515";
      ctx.beginPath();
      ctx.ellipse(genX, genY, 12 * zoom, 8 * zoom, 0, 0, Math.PI * 2);
      ctx.fill();

      // Pulsing seismic core
      const seismicPulse = 0.5 + Math.sin(time * 8) * 0.3 + attackPulse * 0.5;
      ctx.fillStyle = `rgba(255, 80, 80, ${seismicPulse})`;
      ctx.shadowColor = "#ff3333";
      ctx.shadowBlur = (12 + attackPulse * 15) * zoom;
      ctx.beginPath();
      ctx.arc(genX, genY, (6 + attackPulse * 3) * zoom, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Seismic runes
      ctx.fillStyle = `rgba(255, 100, 100, ${seismicPulse})`;
      ctx.font = `${10 * zoom}px serif`;
      ctx.textAlign = "center";
      ctx.fillText("", genX, genY + 2 * zoom);
    }

    // Ground cracks emanating from base
    ctx.strokeStyle = `rgba(255, 80, 50, ${0.4 + attackPulse * 0.5})`;
    ctx.lineWidth = 2 * zoom;
    for (let i = 0; i < 6; i++) {
      const crackAngle = (i / 6) * Math.PI * 2 + time * 0.2;
      const crackLen = (20 + Math.sin(time * 3 + i) * 8) * zoom;
      ctx.beginPath();
      ctx.moveTo(screenPos.x, screenPos.y + 12 * zoom);
      const midX =
        screenPos.x +
        Math.cos(crackAngle) * crackLen * 0.5 +
        (Math.random() - 0.5) * 5 * zoom;
      const midY =
        screenPos.y + 12 * zoom + Math.sin(crackAngle) * crackLen * 0.25;
      ctx.lineTo(midX, midY);
      ctx.lineTo(
        screenPos.x + Math.cos(crackAngle) * crackLen,
        screenPos.y + 12 * zoom + Math.sin(crackAngle) * crackLen * 0.5
      );
      ctx.stroke();
    }

    // Floating debris during attack
    if (attackPulse > 0.1) {
      for (let i = 0; i < 8; i++) {
        const debrisAngle = (i / 8) * Math.PI * 2 + time * 2;
        const debrisHeight = attackPulse * 25 * zoom * Math.sin(time * 5 + i);
        const debrisX = screenPos.x + Math.cos(debrisAngle) * 30 * zoom;
        const debrisY = screenPos.y + 5 * zoom - debrisHeight;

        ctx.fillStyle = `rgba(139, 90, 60, ${attackPulse * 0.8})`;
        ctx.beginPath();
        ctx.moveTo(debrisX, debrisY);
        ctx.lineTo(debrisX - 3 * zoom, debrisY + 4 * zoom);
        ctx.lineTo(debrisX + 3 * zoom, debrisY + 4 * zoom);
        ctx.closePath();
        ctx.fill();
      }
    }

    // Massive shockwave rings during attack
    if (timeSinceFire < 500) {
      const shockPhase = timeSinceFire / 500;
      for (let ring = 0; ring < 3; ring++) {
        const ringDelay = ring * 0.1;
        const ringPhase = Math.max(0, shockPhase - ringDelay);
        if (ringPhase > 0 && ringPhase < 1) {
          const ringRadius = 30 + ringPhase * 60;
          const ringAlpha = (1 - ringPhase) * 0.7;

          ctx.strokeStyle = `rgba(255, 100, 80, ${ringAlpha})`;
          ctx.lineWidth = (4 - ring) * zoom * (1 - ringPhase);
          ctx.beginPath();
          ctx.ellipse(
            screenPos.x,
            screenPos.y + 8 * zoom,
            ringRadius * zoom,
            ringRadius * 0.4 * zoom,
            0,
            0,
            Math.PI * 2
          );
          ctx.stroke();
        }
      }
    }

    // Red energy vortex in portal
    for (let v = 0; v < 12; v++) {
      const vortexAngle = time * 3 + (v / 12) * Math.PI * 2;
      const vortexRadius = 15 + Math.sin(time * 4 + v) * 5;
      const vortexX = screenPos.x + Math.cos(vortexAngle) * vortexRadius * zoom;
      const vortexY =
        archCenterY + Math.sin(vortexAngle) * vortexRadius * 0.4 * zoom;

      ctx.fillStyle = `rgba(255, 80, 80, ${
        0.3 + Math.sin(time * 6 + v) * 0.15
      })`;
      ctx.beginPath();
      ctx.arc(vortexX, vortexY, 3 * zoom, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // === SYMPHONY HALL (Level 4 Upgrade B) - EPIC DARK FANTASY ===
  if (isSymphony) {
    // Crystalline sound amplifiers on pillars
    for (let side = -1; side <= 1; side += 2) {
      const ampX = screenPos.x + side * (baseWidth * 0.45) * zoom;
      const ampY = screenPos.y - 30 * zoom;

      // Crystal housing
      ctx.fillStyle = "#1a2a4a";
      ctx.beginPath();
      ctx.moveTo(ampX, ampY - 15 * zoom);
      ctx.lineTo(ampX - 8 * zoom, ampY);
      ctx.lineTo(ampX - 5 * zoom, ampY + 10 * zoom);
      ctx.lineTo(ampX + 5 * zoom, ampY + 10 * zoom);
      ctx.lineTo(ampX + 8 * zoom, ampY);
      ctx.closePath();
      ctx.fill();

      // Glowing sound crystal
      const crystalGlow =
        0.5 + Math.sin(time * 5 + side) * 0.3 + attackPulse * 0.5;
      ctx.fillStyle = `rgba(100, 200, 255, ${crystalGlow})`;
      ctx.shadowColor = "#66ccff";
      ctx.shadowBlur = (10 + attackPulse * 12) * zoom;
      ctx.beginPath();
      ctx.moveTo(ampX, ampY - 12 * zoom);
      ctx.lineTo(ampX - 5 * zoom, ampY);
      ctx.lineTo(ampX, ampY + 6 * zoom);
      ctx.lineTo(ampX + 5 * zoom, ampY);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    // Floating orchestral instruments (ethereal)
    const instruments = ["", "", "", ""];
    for (let i = 0; i < 4; i++) {
      const instPhase = (time * 0.8 + i * 0.7) % 4;
      const instAngle = (i / 4) * Math.PI * 2 + time * 0.4;
      const instRadius = 35 + Math.sin(instPhase * Math.PI * 0.5) * 10;
      const instX = screenPos.x + Math.cos(instAngle) * instRadius * zoom;
      const instY =
        archCenterY -
        15 * zoom +
        Math.sin(instAngle) * instRadius * 0.3 * zoom -
        instPhase * 5 * zoom;
      const instAlpha = Math.max(0, 1 - instPhase / 4) * 0.6;

      if (instAlpha > 0.1) {
        ctx.globalAlpha = instAlpha;
        ctx.font = `${14 * zoom}px Arial`;
        ctx.textAlign = "center";
        ctx.fillText(instruments[i], instX, instY);
        ctx.globalAlpha = 1;
      }
    }

    // Harmonic wave patterns
    ctx.strokeStyle = `rgba(100, 200, 255, ${0.3 + attackPulse * 0.4})`;
    ctx.lineWidth = 1.5 * zoom;
    for (let wave = 0; wave < 3; wave++) {
      ctx.beginPath();
      for (let i = 0; i <= 20; i++) {
        const t = i / 20;
        const waveX = screenPos.x - 30 * zoom + t * 60 * zoom;
        const waveY =
          archCenterY -
          5 * zoom +
          Math.sin(t * Math.PI * 4 + time * 5 + wave) * 8 * zoom;
        if (i === 0) ctx.moveTo(waveX, waveY);
        else ctx.lineTo(waveX, waveY);
      }
      ctx.stroke();
    }

    // Resonance aura
    const auraGlow = 0.2 + Math.sin(time * 3) * 0.1 + attackPulse * 0.3;
    const auraGrad = ctx.createRadialGradient(
      screenPos.x,
      archCenterY,
      0,
      screenPos.x,
      archCenterY,
      50 * zoom
    );
    auraGrad.addColorStop(0, `rgba(100, 200, 255, ${auraGlow * 0.5})`);
    auraGrad.addColorStop(0.5, `rgba(100, 200, 255, ${auraGlow * 0.2})`);
    auraGrad.addColorStop(1, `rgba(100, 200, 255, 0)`);
    ctx.fillStyle = auraGrad;
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      archCenterY,
      50 * zoom,
      35 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Sound beam during attack
    if (timeSinceFire < 400) {
      const beamPhase = timeSinceFire / 400;
      const beamAlpha = (1 - beamPhase) * 0.6;

      // Central beam
      ctx.fillStyle = `rgba(150, 220, 255, ${beamAlpha})`;
      ctx.shadowColor = "#99ddff";
      ctx.shadowBlur = 20 * zoom;
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        archCenterY,
        (5 + beamPhase * 15) * zoom,
        (10 + beamPhase * 30) * zoom,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();
      ctx.shadowBlur = 0;

      // Concentric sound rings
      for (let ring = 0; ring < 5; ring++) {
        const ringPhase = (beamPhase + ring * 0.08) % 1;
        const ringRadius = 10 + ringPhase * 40;
        const ringAlpha = (1 - ringPhase) * beamAlpha * 0.5;

        ctx.strokeStyle = `rgba(100, 200, 255, ${ringAlpha})`;
        ctx.lineWidth = 2 * zoom * (1 - ringPhase);
        ctx.beginPath();
        ctx.ellipse(
          screenPos.x,
          archCenterY,
          ringRadius * zoom,
          ringRadius * 0.5 * zoom,
          0,
          0,
          Math.PI * 2
        );
        ctx.stroke();
      }
    }

    // Blue energy swirls
    for (let s = 0; s < 8; s++) {
      const swirlAngle = time * 2 + (s / 8) * Math.PI * 2;
      const swirlRadius = 18 + Math.sin(time * 3 + s * 0.8) * 6;
      const swirlX = screenPos.x + Math.cos(swirlAngle) * swirlRadius * zoom;
      const swirlY =
        archCenterY + Math.sin(swirlAngle) * swirlRadius * 0.4 * zoom;

      ctx.fillStyle = `rgba(100, 200, 255, ${
        0.4 + Math.sin(time * 5 + s) * 0.2
      })`;
      ctx.beginPath();
      ctx.arc(swirlX, swirlY, 2.5 * zoom, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.restore();
}

// CLUB TOWER - Epic Resource Generator with mechanical gold production
function renderClubTower(
  ctx: CanvasRenderingContext2D,
  screenPos: Position,
  tower: Tower,
  zoom: number,
  time: number,
  colors: { base: string; dark: string; light: string; accent: string }
) {
  ctx.save();
  const baseWidth = 34 + tower.level * 5;
  const baseHeight = 25 + tower.level * 8;
  const w = baseWidth * zoom * 0.5;
  const d = baseWidth * zoom * 0.25;
  const h = baseHeight * zoom;

  // Sci-fi foundation with gold accents
  drawIsometricPrism(
    ctx,
    screenPos.x,
    screenPos.y + 8 * zoom,
    baseWidth + 10,
    baseWidth + 10,
    6,
    {
      top: "#2a4a3a",
      left: "#1a3a2a",
      right: "#0a2a1a",
      leftBack: "#3a5a4a",
      rightBack: "#2a4a3a",
    },
    zoom
  );

  // Foundation gold trim edge
  const foundGlow = 0.4 + Math.sin(time * 2) * 0.2;
  ctx.strokeStyle = `rgba(201, 162, 39, ${foundGlow})`;
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(
    screenPos.x - (baseWidth + 10) * zoom * 0.5,
    screenPos.y + 2 * zoom
  );
  ctx.lineTo(
    screenPos.x,
    screenPos.y + (baseWidth + 10) * zoom * 0.25 + 2 * zoom
  );
  ctx.lineTo(
    screenPos.x + (baseWidth + 10) * zoom * 0.5,
    screenPos.y + 2 * zoom
  );
  ctx.stroke();

  // Main tower body - dark green tech with gold trim
  drawIsometricPrism(
    ctx,
    screenPos.x,
    screenPos.y,
    baseWidth,
    baseWidth,
    baseHeight,
    {
      top: "#3a6a4a",
      left: "#2a5a3a",
      right: "#1a4a2a",
      leftBack: "#4a7a5a",
      rightBack: "#3a6a4a",
    },
    zoom
  );

  // Structural panel lines for better 3D effect
  ctx.strokeStyle = "#1a4a2a";
  ctx.lineWidth = 1 * zoom;
  // Left face vertical panels
  for (let panel = 0; panel < 3; panel++) {
    const panelX = screenPos.x - w * (0.2 + panel * 0.3);
    ctx.beginPath();
    ctx.moveTo(panelX, screenPos.y);
    ctx.lineTo(panelX - d * 0.5, screenPos.y - baseHeight * zoom + d * 0.5);
    ctx.stroke();
  }
  // Right face vertical panels
  for (let panel = 0; panel < 3; panel++) {
    const panelX = screenPos.x + w * (0.2 + panel * 0.3);
    ctx.beginPath();
    ctx.moveTo(panelX, screenPos.y);
    ctx.lineTo(panelX + d * 0.5, screenPos.y - baseHeight * zoom + d * 0.5);
    ctx.stroke();
  }

  // Gold corner accents
  ctx.fillStyle = "#c9a227";
  for (let side of [-1, 1]) {
    // Corner strips
    ctx.beginPath();
    ctx.moveTo(screenPos.x + side * w * 0.95, screenPos.y);
    ctx.lineTo(screenPos.x + side * w * 1.0, screenPos.y - 2 * zoom);
    ctx.lineTo(
      screenPos.x + side * w * 1.0,
      screenPos.y - baseHeight * zoom * 0.9
    );
    ctx.lineTo(
      screenPos.x + side * w * 0.95,
      screenPos.y - baseHeight * zoom * 0.9 + 2 * zoom
    );
    ctx.closePath();
    ctx.fill();
  }

  // Horizontal gold band
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 2 * zoom;
  const bandY = screenPos.y - baseHeight * zoom * 0.4;
  ctx.beginPath();
  ctx.moveTo(screenPos.x - w * 0.9, bandY + d * 0.35);
  ctx.lineTo(screenPos.x, bandY + d * 0.5);
  ctx.lineTo(screenPos.x + w * 0.9, bandY + d * 0.35);
  ctx.stroke();

  const topY = screenPos.y - baseHeight * zoom;

  // ========== ROTATING GOLD GEARS ==========
  const gearRotation = time * 1.2;

  // Large main gear (gold production mechanism)
  drawGear(
    ctx,
    screenPos.x - w * 0.5,
    screenPos.y - h * 0.5,
    14 + tower.level * 2,
    9 + tower.level,
    10 + tower.level * 2,
    gearRotation,
    {
      outer: "#8b7355",
      inner: "#6b5335",
      teeth: "#a08060",
      highlight: "#c9a227",
    },
    zoom
  );

  // Smaller meshing gear
  drawGear(
    ctx,
    screenPos.x - w * 0.2,
    screenPos.y - h * 0.65,
    10 + tower.level,
    6,
    8 + tower.level,
    -gearRotation * 1.4,
    {
      outer: "#7a6245",
      inner: "#5a4225",
      teeth: "#9a8260",
      highlight: "#c9a227",
    },
    zoom
  );

  // Right side gear
  if (tower.level >= 2) {
    drawGear(
      ctx,
      screenPos.x + w * 0.45,
      screenPos.y - h * 0.45,
      12 + tower.level,
      8,
      9 + tower.level,
      gearRotation * 0.9,
      {
        outer: "#7a6245",
        inner: "#5a4225",
        teeth: "#9a8260",
        highlight: "#c9a227",
      },
      zoom
    );
  }

  // ========== GOLD COIN CONVEYOR ==========
  if (tower.level >= 2) {
    // Conveyor track
    ctx.strokeStyle = "#3a3a42";
    ctx.lineWidth = 6 * zoom;
    ctx.beginPath();
    ctx.moveTo(screenPos.x - w * 0.7, screenPos.y + 4 * zoom);
    ctx.lineTo(screenPos.x + w * 0.1, screenPos.y - h * 0.3);
    ctx.stroke();

    // Animated gold coins on conveyor
    for (let c = 0; c < 3; c++) {
      const coinPhase = (time * 0.6 + c * 0.33) % 1;
      const coinX = screenPos.x - w * 0.7 + w * 0.8 * coinPhase;
      const coinY = screenPos.y + 4 * zoom - (h * 0.3 + 4) * coinPhase;

      ctx.fillStyle = "#c9a227";
      ctx.shadowColor = "#ffaa00";
      ctx.shadowBlur = 4 * zoom;
      ctx.beginPath();
      ctx.ellipse(coinX, coinY, 4 * zoom, 2 * zoom, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }

  // ========== GOLD STORAGE VAULT ==========
  // Vault door on front face
  ctx.fillStyle = "#4a4a52";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    screenPos.y - h * 0.25,
    8 * zoom,
    10 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Vault spokes
  ctx.strokeStyle = "#6a6a72";
  ctx.lineWidth = 2 * zoom;
  for (let spoke = 0; spoke < 6; spoke++) {
    const spokeAngle = (spoke / 6) * Math.PI * 2 + time * 0.5;
    ctx.beginPath();
    ctx.moveTo(screenPos.x, screenPos.y - h * 0.25);
    ctx.lineTo(
      screenPos.x + Math.cos(spokeAngle) * 6 * zoom,
      screenPos.y - h * 0.25 + Math.sin(spokeAngle) * 8 * zoom
    );
    ctx.stroke();
  }

  // Vault center (glowing gold)
  const vaultGlow = 0.6 + Math.sin(time * 3) * 0.3;
  ctx.fillStyle = `rgba(255, 215, 0, ${vaultGlow})`;
  ctx.shadowColor = "#c9a227";
  ctx.shadowBlur = 8 * zoom;
  ctx.beginPath();
  ctx.arc(screenPos.x, screenPos.y - h * 0.25, 3 * zoom, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Tech panel lines (flipped orientation)
  const panelGlow = 0.4 + Math.sin(time * 3) * 0.2;
  ctx.strokeStyle = `rgba(0, 255, 100, ${panelGlow})`;
  ctx.lineWidth = 1 * zoom;

  for (let i = 1; i <= tower.level + 1; i++) {
    const lineY = screenPos.y - (h * i) / (tower.level + 2);
    ctx.beginPath();
    ctx.moveTo(screenPos.x - w * 0.2, lineY + d * 0.3);
    ctx.lineTo(screenPos.x - w * 0.85, lineY - d * 0.2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(screenPos.x + w * 0.85, lineY - d * 0.2);
    ctx.lineTo(screenPos.x + w * 0.2, lineY + d * 0.3);
    ctx.stroke();
  }

  // ========== MONEY TUBES (flowing gold particles) ==========
  drawEnergyTube(
    ctx,
    screenPos.x - w * 0.6,
    screenPos.y + 6 * zoom,
    screenPos.x - w * 0.4,
    screenPos.y - h * 0.7,
    2.5,
    time,
    zoom,
    "rgb(255, 215, 0)"
  );

  if (tower.level >= 2) {
    drawEnergyTube(
      ctx,
      screenPos.x + w * 0.5,
      screenPos.y + 2 * zoom,
      screenPos.x + w * 0.35,
      screenPos.y - h * 0.65,
      2.5,
      time + 0.4,
      zoom,
      "rgb(255, 200, 50)"
    );
  }

  // Glowing resource vents with enhanced glow
  for (let i = 0; i < tower.level; i++) {
    const ventY = screenPos.y - h * 0.3 - i * 12 * zoom;
    const ventGlow = 0.5 + Math.sin(time * 4 + i * 0.5) * 0.3;

    ctx.shadowColor = "#00ff66";
    ctx.shadowBlur = 6 * zoom;
    ctx.fillStyle = `rgba(0, 255, 100, ${ventGlow})`;
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x - w * 0.6,
      ventY + d * 0.2,
      4 * zoom,
      2 * zoom,
      0.4,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x + w * 0.6,
      ventY + d * 0.2,
      4 * zoom,
      2 * zoom,
      -0.4,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // ========== ENHANCED ROOF WITH GOLD DOME ==========
  // Base roof structure
  ctx.fillStyle = "#1a3a2a";
  ctx.beginPath();
  ctx.moveTo(screenPos.x, topY - 18 * zoom);
  ctx.lineTo(screenPos.x - baseWidth * zoom * 0.45, topY + 2 * zoom);
  ctx.lineTo(screenPos.x, topY + baseWidth * zoom * 0.22);
  ctx.lineTo(screenPos.x + baseWidth * zoom * 0.45, topY + 2 * zoom);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = "#2a4a3a";
  ctx.beginPath();
  ctx.moveTo(screenPos.x, topY - 18 * zoom);
  ctx.lineTo(screenPos.x + baseWidth * zoom * 0.45, topY + 2 * zoom);
  ctx.lineTo(screenPos.x + baseWidth * zoom * 0.45, topY + 6 * zoom);
  ctx.lineTo(screenPos.x, topY + baseWidth * zoom * 0.22 + 4 * zoom);
  ctx.closePath();
  ctx.fill();

  // Roof tile pattern (forms a v shape)
  ctx.strokeStyle = "#0a2a1a";
  ctx.lineWidth = 1 * zoom;
  for (let tile = 0; tile < 8; tile++) {
    const tileY = topY - 16 * zoom + (tile / 8) * 20 * zoom;
    ctx.beginPath();
    ctx.moveTo(screenPos.x - (baseWidth * 0.45 - tile * 2) * zoom, tileY);
    ctx.lineTo(screenPos.x, tileY + (tile * 2 * zoom) / 3);
    ctx.lineTo(screenPos.x + (baseWidth * 0.45 - tile * 2) * zoom, tileY);
    ctx.stroke();
  }

  // Gold dome top with enhanced 3D shading
  const domeGrad = ctx.createRadialGradient(
    screenPos.x - 3 * zoom,
    topY - 22 * zoom,
    0,
    screenPos.x,
    topY - 15 * zoom,
    14 * zoom
  );
  domeGrad.addColorStop(0, "#fffadc");
  domeGrad.addColorStop(0.2, "#ffe44d");
  domeGrad.addColorStop(0.5, "#c9a227");
  domeGrad.addColorStop(0.8, "#b8860b");
  domeGrad.addColorStop(1, "#8b6914");
  ctx.fillStyle = domeGrad;
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    topY - 15 * zoom,
    12 * zoom,
    7 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Dome highlight arc
  ctx.strokeStyle = "#ffe88a";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    topY - 15 * zoom,
    10 * zoom,
    5 * zoom,
    0,
    Math.PI * 1.2,
    Math.PI * 1.8
  );
  ctx.stroke();

  // Dome finial (gold spike on top)
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.moveTo(screenPos.x, topY - 30 * zoom);
  ctx.lineTo(screenPos.x - 3 * zoom, topY - 20 * zoom);
  ctx.lineTo(screenPos.x + 3 * zoom, topY - 20 * zoom);
  ctx.closePath();
  ctx.fill();

  // Finial glow
  const finialGlow = 0.6 + Math.sin(time * 4) * 0.3;
  ctx.fillStyle = `rgba(255, 215, 0, ${finialGlow})`;
  ctx.shadowColor = "#ffd700";
  ctx.shadowBlur = 8 * zoom;
  ctx.beginPath();
  ctx.arc(screenPos.x, topY - 30 * zoom, 2 * zoom, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Data screens as windows (enhanced)
  const screenGlow = 0.6 + Math.sin(time * 2) * 0.2;
  ctx.fillStyle = "#0a1a10";
  ctx.fillRect(
    screenPos.x - 12 * zoom,
    screenPos.y - baseHeight * zoom * 0.6,
    10 * zoom,
    12 * zoom
  );
  ctx.fillRect(
    screenPos.x + 2 * zoom,
    screenPos.y - baseHeight * zoom * 0.6,
    10 * zoom,
    12 * zoom
  );

  ctx.fillStyle = `rgba(0, 255, 100, ${screenGlow})`;
  ctx.fillRect(
    screenPos.x - 11 * zoom,
    screenPos.y - baseHeight * zoom * 0.6 + 1 * zoom,
    8 * zoom,
    10 * zoom
  );
  ctx.fillRect(
    screenPos.x + 3 * zoom,
    screenPos.y - baseHeight * zoom * 0.6 + 1 * zoom,
    8 * zoom,
    10 * zoom
  );

  // Stock ticker on screens
  ctx.fillStyle = "#0a2a1a";
  for (let i = 0; i < 3; i++) {
    const barY =
      screenPos.y - baseHeight * zoom * 0.6 + 3 * zoom + i * 3 * zoom;
    const barW = 3 + Math.sin(time * 8 + i) * 2;
    ctx.fillRect(screenPos.x - 10 * zoom, barY, barW * zoom, 2 * zoom);
    ctx.fillRect(screenPos.x + 4 * zoom, barY, (barW + 1) * zoom, 2 * zoom);
  }

  // ========== WARNING LIGHTS ==========
  drawWarningLight(
    ctx,
    screenPos.x - w * 0.8,
    screenPos.y - h * 0.1,
    2.5,
    time,
    zoom,
    "#00ff66",
    4
  );
  if (tower.level >= 2) {
    drawWarningLight(
      ctx,
      screenPos.x + w * 0.8,
      screenPos.y - h * 0.15,
      2.5,
      time + 0.5,
      zoom,
      "#c9a227",
      3
    );
  }

  // ========== HOLOGRAPHIC CREDIT DISPLAY (enhanced) ==========
  const coinY = topY - 32 * zoom + Math.sin(time * 3) * 5 * zoom;

  // Multiple rotating rings
  for (let ring = 0; ring < 2 + tower.level; ring++) {
    const ringAlpha = 0.3 - ring * 0.08;
    const ringSize = 18 + ring * 4;
    ctx.strokeStyle = `rgba(255, 215, 0, ${
      ringAlpha + Math.sin(time * 4 + ring) * 0.1
    })`;
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      coinY,
      ringSize * zoom,
      ringSize * 0.5 * zoom,
      time * 0.5 + ring * 0.3,
      0,
      Math.PI * 2
    );
    ctx.stroke();
  }

  // Holographic credit symbol
  const coinRotation = time * 4;
  ctx.save();
  ctx.translate(screenPos.x, coinY);
  ctx.scale(Math.cos(coinRotation), 1);

  // Outer glow
  const creditGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 14 * zoom);
  creditGrad.addColorStop(0, `rgba(255, 255, 200, 0.9)`);
  creditGrad.addColorStop(0.3, `rgba(255, 215, 0, 0.7)`);
  creditGrad.addColorStop(0.6, `rgba(218, 165, 32, 0.4)`);
  creditGrad.addColorStop(1, `rgba(184, 134, 11, 0)`);
  ctx.fillStyle = creditGrad;
  ctx.shadowColor = "#c9a227";
  ctx.shadowBlur = 20 * zoom;
  ctx.beginPath();
  ctx.arc(0, 0, 14 * zoom, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Credit symbol (Princeton P with paw)
  ctx.fillStyle = "#4a3a1a";
  ctx.font = `bold ${16 * zoom}px Arial`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("$", 0, 0);
  ctx.restore();

  // ========== GOLD PARTICLE FOUNTAIN ==========
  for (let i = 0; i < tower.level + 3; i++) {
    const pPhase = (time * 2.5 + i * 0.25) % 1;
    const pY = coinY + 10 * zoom - pPhase * h * 0.6;
    const pX = screenPos.x + Math.sin(time * 4 + i * 2.5) * 12 * zoom;
    const pAlpha = Math.sin(pPhase * Math.PI) * 0.7;
    const pSize = 2 + Math.sin(time * 6 + i) * 1;

    ctx.fillStyle = `rgba(255, 215, 0, ${pAlpha})`;
    ctx.shadowColor = "#c9a227";
    ctx.shadowBlur = 4 * zoom;
    ctx.beginPath();
    ctx.arc(pX, pY, pSize * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Level 3+ upgrade visuals
  if (tower.level >= 3) {
    if (tower.upgrade === "A") {
      // Investment Fund - holographic stock chart (enhanced)
      ctx.strokeStyle = "#00ff66";
      ctx.lineWidth = 3 * zoom;
      ctx.shadowColor = "#00ff66";
      ctx.shadowBlur = 8 * zoom;
      ctx.beginPath();
      ctx.moveTo(screenPos.x - 20 * zoom, topY - 40 * zoom);
      ctx.lineTo(screenPos.x - 8 * zoom, topY - 55 * zoom);
      ctx.lineTo(screenPos.x + 4 * zoom, topY - 48 * zoom);
      ctx.lineTo(screenPos.x + 20 * zoom, topY - 65 * zoom);
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Arrow head
      ctx.fillStyle = "#00ff66";
      ctx.beginPath();
      ctx.moveTo(screenPos.x + 20 * zoom, topY - 65 * zoom);
      ctx.lineTo(screenPos.x + 14 * zoom, topY - 62 * zoom);
      ctx.lineTo(screenPos.x + 16 * zoom, topY - 56 * zoom);
      ctx.closePath();
      ctx.fill();

      // Data points with glow
      ctx.shadowColor = "#00ff66";
      ctx.shadowBlur = 6 * zoom;
      ctx.fillStyle = `rgba(0, 255, 100, 0.9)`;
      ctx.beginPath();
      ctx.arc(
        screenPos.x - 6 * zoom,
        topY - 48 * zoom,
        3 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();
      ctx.beginPath();
      ctx.arc(
        screenPos.x + 6 * zoom,
        topY - 41 * zoom,
        3 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();
    } else if (tower.upgrade === "B") {
      // Recruitment Center - personnel hologram
      ctx.fillStyle = "#0a2a1a";
      ctx.fillRect(
        screenPos.x - 22 * zoom,
        topY - 48 * zoom,
        16 * zoom,
        16 * zoom
      );

      // Personnel icon
      ctx.fillStyle = `rgba(0, 255, 100, ${0.6 + Math.sin(time * 3) * 0.2})`;
      ctx.beginPath();
      ctx.arc(
        screenPos.x - 14 * zoom,
        topY - 42 * zoom,
        4 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();
      ctx.fillRect(
        screenPos.x - 18 * zoom,
        topY - 38 * zoom,
        8 * zoom,
        6 * zoom
      );

      // Status bar
      ctx.fillStyle = "#0a2a1a";
      ctx.fillRect(
        screenPos.x + 6 * zoom,
        topY - 50 * zoom,
        16 * zoom,
        18 * zoom
      );
      ctx.fillStyle = "#00ff66";
      ctx.fillRect(
        screenPos.x + 8 * zoom,
        topY - 48 * zoom,
        12 * zoom * (0.5 + Math.sin(time * 2) * 0.3),
        4 * zoom
      );
      ctx.fillRect(
        screenPos.x + 8 * zoom,
        topY - 42 * zoom,
        12 * zoom * (0.7 + Math.sin(time * 2.5) * 0.2),
        4 * zoom
      );
    }
  }

  ctx.restore();
}

// STATION TOWER - Sci-Fi Princeton Dinky Transport Hub
function renderStationTower(
  ctx: CanvasRenderingContext2D,
  screenPos: Position,
  tower: Tower,
  zoom: number,
  time: number,
  colors: { base: string; dark: string; light: string; accent: string }
) {
  ctx.save();
  // Shift the entire building up slightly
  screenPos = { x: screenPos.x, y: screenPos.y - 10 * zoom };

  // Base dimensions - scaled by level
  const baseW = 56 + tower.level * 6;
  const baseD = 44 + tower.level * 5;

  // Isometric conversion factors
  const isoW = baseW * zoom * 0.5;
  const isoD = baseD * zoom * 0.25;

  // ========== FOUNDATION (proper isometric diamond aligned with grid) ==========
  // Helper function for isometric diamond
  const drawIsoDiamond = (
    cx: number,
    cy: number,
    w: number,
    d: number,
    h: number,
    topColor: string,
    leftColor: string,
    rightColor: string
  ) => {
    const hw = w * zoom * 0.5;
    const hd = d * zoom * 0.25;
    const hh = h * zoom;

    // Top face (diamond)
    ctx.fillStyle = topColor;
    ctx.beginPath();
    ctx.moveTo(cx, cy - hh - hd); // Top
    ctx.lineTo(cx + hw, cy - hh); // Right
    ctx.lineTo(cx, cy - hh + hd); // Bottom
    ctx.lineTo(cx - hw, cy - hh); // Left
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.3)";
    ctx.lineWidth = 1;
    ctx.stroke();

    // Left face
    ctx.fillStyle = leftColor;
    ctx.beginPath();
    ctx.moveTo(cx - hw, cy - hh); // Top-left
    ctx.lineTo(cx, cy - hh + hd); // Top-right
    ctx.lineTo(cx, cy + hd); // Bottom-right
    ctx.lineTo(cx - hw, cy); // Bottom-left
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.4)";
    ctx.lineWidth = 1;
    ctx.stroke();

    // Right face
    ctx.fillStyle = rightColor;
    ctx.beginPath();
    ctx.moveTo(cx + hw, cy - hh); // Top-right
    ctx.lineTo(cx + hw, cy); // Bottom-right
    ctx.lineTo(cx, cy + hd); // Bottom
    ctx.lineTo(cx, cy - hh + hd); // Top
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.3)";
    ctx.lineWidth = 1;
    ctx.stroke();
  };

  // ========== LEVEL-SPECIFIC THEMED BASE ==========
  if (tower.level === 1) {
    // BARRACKS BASE - Wooden military camp platform
    // Bottom dirt layer
    drawIsoDiamond(
      screenPos.x,
      screenPos.y + 14 * zoom,
      baseW + 18,
      baseD + 28,
      8,
      "#4a3a2a",
      "#3a2a1a",
      "#2a1a0a"
    );
    // Wooden plank platform
    drawIsoDiamond(
      screenPos.x,
      screenPos.y + 6 * zoom,
      baseW + 10,
      baseD + 18,
      6,
      "#6b5030",
      "#5a4020",
      "#4a3010"
    );
    // Top wooden deck
    drawIsoDiamond(
      screenPos.x,
      screenPos.y,
      baseW + 2,
      baseD + 8,
      4,
      "#8b7355",
      "#7a6244",
      "#695133"
    );

    // Wood grain lines on top
    ctx.strokeStyle = "#5a4020";
    ctx.lineWidth = 0.8 * zoom;
    for (let i = -2; i <= 2; i++) {
      ctx.beginPath();
      ctx.moveTo(
        screenPos.x - isoW + 10 * zoom,
        screenPos.y + i * 3 * zoom - 4 * zoom
      );
      ctx.lineTo(
        screenPos.x + isoW - 10 * zoom,
        screenPos.y + i * 3 * zoom - 4 * zoom
      );
      ctx.stroke();
    }

    // Small weapon rack (left side)
    const rackX = screenPos.x - isoW * 0.6 - 12 * zoom;
    const rackY = screenPos.y + 22 * zoom;
    ctx.fillStyle = "#5a4020";
    ctx.fillRect(rackX - 2 * zoom, rackY - 12 * zoom, 4 * zoom, 12 * zoom);
    ctx.fillRect(rackX - 4 * zoom, rackY - 12 * zoom, 8 * zoom, 2 * zoom);
    // Spears on rack
    ctx.strokeStyle = "#888888";
    ctx.lineWidth = 1.2 * zoom;
    ctx.beginPath();
    ctx.moveTo(rackX - 2 * zoom, rackY - 10 * zoom);
    ctx.lineTo(rackX - 2 * zoom, rackY - 20 * zoom);
    ctx.moveTo(rackX + 2 * zoom, rackY - 10 * zoom);
    ctx.lineTo(rackX + 2 * zoom, rackY - 20 * zoom);
    ctx.stroke();
    ctx.fillStyle = "#aaaaaa";
    ctx.beginPath();
    ctx.moveTo(rackX - 2 * zoom, rackY - 22 * zoom);
    ctx.lineTo(rackX - 3.5 * zoom, rackY - 19 * zoom);
    ctx.lineTo(rackX - 0.5 * zoom, rackY - 19 * zoom);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(rackX + 2 * zoom, rackY - 22 * zoom);
    ctx.lineTo(rackX + 0.5 * zoom, rackY - 19 * zoom);
    ctx.lineTo(rackX + 3.5 * zoom, rackY - 19 * zoom);
    ctx.closePath();
    ctx.fill();

    // Supply crate (right side)
    const crateX = screenPos.x + isoW * 0.5;
    const crateY = screenPos.y + 2 * zoom;
    drawIsometricPrism(
      ctx,
      crateX,
      crateY,
      8,
      7,
      6,
      { top: "#7a6040", left: "#5a4020", right: "#4a3010" },
      zoom
    );
    ctx.strokeStyle = "#3a2010";
    ctx.lineWidth = 0.8 * zoom;
    ctx.strokeRect(crateX - 3 * zoom, crateY - 8 * zoom, 6 * zoom, 4 * zoom);

    // Barrel
    ctx.fillStyle = "#6b5030";
    ctx.beginPath();
    ctx.ellipse(
      crateX + 8 * zoom,
      crateY - 2 * zoom,
      3 * zoom,
      2 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.fillStyle = "#5a4020";
    ctx.fillRect(crateX + 5 * zoom, crateY - 8 * zoom, 6 * zoom, 6 * zoom);
  } else if (tower.level === 2) {
    // GARRISON BASE - Stone military platform
    // Foundation stone
    drawIsoDiamond(
      screenPos.x,
      screenPos.y + 17 * zoom,
      baseW + 20,
      baseD + 34,
      10,
      "#4a4a52",
      "#3a3a42",
      "#2a2a32"
    );
    // Cobblestone layer
    drawIsoDiamond(
      screenPos.x,
      screenPos.y + 7 * zoom,
      baseW + 12,
      baseD + 24,
      7,
      "#5a5a62",
      "#4a4a52",
      "#3a3a42"
    );
    // Top stone platform
    drawIsoDiamond(
      screenPos.x,
      screenPos.y,
      baseW + 4,
      baseD + 14,
      5,
      "#6a6a72",
      "#5a5a62",
      "#4a4a52"
    );

    // Cobblestone pattern
    ctx.fillStyle = "#5a5a62";
    for (let i = -2; i <= 2; i++) {
      for (let j = -1; j <= 1; j++) {
        const sx = screenPos.x + i * 8 * zoom + (j % 2) * 4 * zoom;
        const sy = screenPos.y + j * 4 * zoom - 4 * zoom;
        ctx.beginPath();
        ctx.ellipse(sx, sy, 3 * zoom, 1.5 * zoom, 0, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Armor stand (left)
    const armorX = screenPos.x - isoW * 0.6;
    const armorY = screenPos.y + 4 * zoom;
    ctx.fillStyle = "#4a4a52";
    ctx.fillRect(armorX - 1.5 * zoom, armorY - 14 * zoom, 3 * zoom, 14 * zoom);
    // Armor body
    ctx.fillStyle = "#6a6a72";
    ctx.beginPath();
    ctx.moveTo(armorX, armorY - 18 * zoom);
    ctx.lineTo(armorX - 5 * zoom, armorY - 12 * zoom);
    ctx.lineTo(armorX - 4 * zoom, armorY - 6 * zoom);
    ctx.lineTo(armorX + 4 * zoom, armorY - 6 * zoom);
    ctx.lineTo(armorX + 5 * zoom, armorY - 12 * zoom);
    ctx.closePath();
    ctx.fill();
    // Helmet
    ctx.fillStyle = "#7a7a82";
    ctx.beginPath();
    ctx.arc(armorX, armorY - 20 * zoom, 3 * zoom, 0, Math.PI * 2);
    ctx.fill();
    // Orange plume
    ctx.fillStyle = "#e06000";
    ctx.beginPath();
    ctx.ellipse(
      armorX,
      armorY - 24 * zoom,
      1.5 * zoom,
      3 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Shield rack (right)
    const shieldX = screenPos.x + isoW * 0.5;
    const shieldY = screenPos.y + 4 * zoom;
    ctx.fillStyle = "#4a4a52";
    ctx.fillRect(shieldX - 2 * zoom, shieldY - 10 * zoom, 4 * zoom, 10 * zoom);
    // Shields
    ctx.fillStyle = "#e06000";
    ctx.beginPath();
    ctx.moveTo(shieldX - 6 * zoom, shieldY - 16 * zoom);
    ctx.lineTo(shieldX - 10 * zoom, shieldY - 10 * zoom);
    ctx.lineTo(shieldX - 6 * zoom, shieldY - 4 * zoom);
    ctx.lineTo(shieldX - 2 * zoom, shieldY - 10 * zoom);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "#1a1a1a";
    ctx.lineWidth = 1 * zoom;
    ctx.stroke();

    // Supply crates
    drawIsometricPrism(
      ctx,
      shieldX + 8 * zoom,
      shieldY,
      7,
      6,
      5,
      { top: "#5a5a62", left: "#4a4a52", right: "#3a3a42" },
      zoom
    );
  } else if (tower.level === 3) {
    // FORTRESS BASE - Heavy stone fortress platform
    // Deep foundation
    drawIsoDiamond(
      screenPos.x,
      screenPos.y + 19 * zoom,
      baseW + 24,
      baseD + 38,
      12,
      "#3a3a42",
      "#2a2a32",
      "#1a1a22"
    );
    // Stone wall layer
    drawIsoDiamond(
      screenPos.x,
      screenPos.y + 8 * zoom,
      baseW + 14,
      baseD + 25,
      8,
      "#5a5a62",
      "#4a4a52",
      "#3a3a42"
    );
    // Top fortress platform
    drawIsoDiamond(
      screenPos.x,
      screenPos.y,
      baseW + 6,
      baseD + 16,
      6,
      "#6a6a72",
      "#5a5a62",
      "#4a4a52"
    );

    // Stone brick pattern
    ctx.strokeStyle = "#4a4a52";
    ctx.lineWidth = 0.6 * zoom;
    for (let i = -2; i <= 2; i++) {
      const offset = i % 2 === 0 ? 0 : 5 * zoom;
      ctx.beginPath();
      ctx.moveTo(
        screenPos.x - isoW + offset,
        screenPos.y + i * 3 * zoom - 4 * zoom
      );
      ctx.lineTo(
        screenPos.x + isoW - offset,
        screenPos.y + i * 3 * zoom - 4 * zoom
      );
      ctx.stroke();
    }

    // Mini battlements on corners
    for (const side of [-1, 1]) {
      drawIsometricPrism(
        ctx,
        screenPos.x + side * isoW * 0.7,
        screenPos.y + side * 2 * zoom,
        5,
        4,
        6,
        { top: "#7a7a82", left: "#5a5a62", right: "#4a4a52" },
        zoom
      );
    }

    // Catapult/Ballista (left side)
    const siegeX = screenPos.x - isoW * 0.55;
    const siegeY = screenPos.y + 6 * zoom;
    // Base frame
    ctx.fillStyle = "#4a3a2a";
    drawIsometricPrism(
      ctx,
      siegeX,
      siegeY,
      10,
      8,
      4,
      { top: "#5a4a3a", left: "#4a3a2a", right: "#3a2a1a" },
      zoom
    );
    // Arm
    ctx.strokeStyle = "#5a4a3a";
    ctx.lineWidth = 2.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(siegeX, siegeY - 4 * zoom);
    ctx.lineTo(siegeX - 4 * zoom, siegeY - 14 * zoom);
    ctx.stroke();
    // Counterweight
    ctx.fillStyle = "#4a4a52";
    ctx.beginPath();
    ctx.arc(siegeX + 3 * zoom, siegeY - 6 * zoom, 3 * zoom, 0, Math.PI * 2);
    ctx.fill();

    // Weapon rack with heavy weapons
    const hwX = screenPos.x + isoW * 0.5;
    const hwY = screenPos.y + 4 * zoom;
    ctx.fillStyle = "#4a4a52";
    ctx.fillRect(hwX - 2 * zoom, hwY - 16 * zoom, 4 * zoom, 16 * zoom);
    // Halberds
    ctx.strokeStyle = "#5a4a3a";
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(hwX - 4 * zoom, hwY - 14 * zoom);
    ctx.lineTo(hwX - 4 * zoom, hwY - 26 * zoom);
    ctx.moveTo(hwX + 4 * zoom, hwY - 14 * zoom);
    ctx.lineTo(hwX + 4 * zoom, hwY - 26 * zoom);
    ctx.stroke();
    // Axe heads
    ctx.fillStyle = "#8a8a92";
    for (const ox of [-4, 4]) {
      ctx.beginPath();
      ctx.moveTo(hwX + ox * zoom, hwY - 26 * zoom);
      ctx.lineTo(hwX + ox * zoom - 3 * zoom, hwY - 22 * zoom);
      ctx.lineTo(hwX + ox * zoom + 3 * zoom, hwY - 22 * zoom);
      ctx.closePath();
      ctx.fill();
    }
  } else if (tower.level === 4 && tower.upgrade === "A") {
    // ROYAL STABLE BASE - Marble Greek platform with gold accents
    // Foundation marble
    drawIsoDiamond(
      screenPos.x,
      screenPos.y + 16 * zoom,
      baseW + 26,
      baseD + 42,
      10,
      "#d0ccc4",
      "#c0bcb4",
      "#b0aca4"
    );
    // Middle marble tier
    drawIsoDiamond(
      screenPos.x,
      screenPos.y + 7 * zoom,
      baseW + 16,
      baseD + 28,
      8,
      "#e0dcd4",
      "#d0ccc4",
      "#c0bcb4"
    );
    // Top marble platform
    drawIsoDiamond(
      screenPos.x,
      screenPos.y,
      baseW + 8,
      baseD + 18,
      6,
      "#f0ece4",
      "#e0dcd4",
      "#d0ccc4"
    );

    // Gold edge trim
    ctx.strokeStyle = "#c9a227";
    ctx.lineWidth = 2 * zoom;
    ctx.shadowColor = "#c9a227";
    ctx.shadowBlur = 4 * zoom;
    ctx.beginPath();
    ctx.moveTo(screenPos.x - isoW - 4 * zoom, screenPos.y - 6 * zoom);
    ctx.lineTo(screenPos.x, screenPos.y + isoD - 2 * zoom);
    ctx.lineTo(screenPos.x + isoW + 4 * zoom, screenPos.y - 6 * zoom);
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Greek meander pattern on edge
    ctx.strokeStyle = "#b8860b";
    ctx.lineWidth = 1 * zoom;
    for (let i = -3; i <= 3; i++) {
      const px = screenPos.x + i * 8 * zoom;
      const py = screenPos.y + Math.abs(i) * 0.5 * zoom - 2 * zoom;
      ctx.beginPath();
      ctx.rect(px - 2 * zoom, py - 2 * zoom, 4 * zoom, 4 * zoom);
      ctx.stroke();
    }

    // Hay storage area (left)
    const hayX = screenPos.x - isoW * 0.6;
    const hayY = screenPos.y + 6 * zoom;
    ctx.fillStyle = "#c4a84a";
    ctx.beginPath();
    ctx.ellipse(hayX, hayY - 2 * zoom, 6 * zoom, 3 * zoom, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#b49830";
    ctx.beginPath();
    ctx.ellipse(
      hayX + 4 * zoom,
      hayY - 6 * zoom,
      5 * zoom,
      2.5 * zoom,
      0.3,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Water trough
    const troughX = screenPos.x + isoW * 0.45;
    const troughY = screenPos.y + 4 * zoom;
    drawIsometricPrism(
      ctx,
      troughX,
      troughY,
      10,
      6,
      4,
      { top: "#8a8a92", left: "#7a7a82", right: "#6a6a72" },
      zoom
    );
    // Water surface
    ctx.fillStyle = `rgba(100, 150, 200, ${0.6 + Math.sin(time * 2) * 0.1})`;
    ctx.beginPath();
    ctx.ellipse(
      troughX,
      troughY - 4 * zoom,
      4 * zoom,
      1.5 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Golden urn
    ctx.fillStyle = "#c9a227";
    ctx.beginPath();
    ctx.ellipse(
      troughX + 10 * zoom,
      troughY - 6 * zoom,
      3 * zoom,
      5 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.fillStyle = "#b8860b";
    ctx.beginPath();
    ctx.ellipse(
      troughX + 10 * zoom,
      troughY - 10 * zoom,
      2 * zoom,
      1.5 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
  } else {
    // ROYAL CASTLE BASE - Grand royal platform with gold and royal insignia
    // Deep royal foundation
    drawIsoDiamond(
      screenPos.x,
      screenPos.y + 19 * zoom,
      baseW + 26,
      baseD + 42,
      12,
      "#3a3a42",
      "#2a2a32",
      "#1a1a22"
    );
    // Royal stone tier
    drawIsoDiamond(
      screenPos.x,
      screenPos.y + 8 * zoom,
      baseW + 16,
      baseD + 30,
      9,
      "#5a5a62",
      "#4a4a52",
      "#3a3a42"
    );
    // Top royal platform
    drawIsoDiamond(
      screenPos.x,
      screenPos.y,
      baseW + 8,
      baseD + 18,
      6,
      "#6a6a72",
      "#5a5a62",
      "#4a4a52"
    );

    // Gold edge trim
    ctx.strokeStyle = "#c9a227";
    ctx.lineWidth = 2.5 * zoom;
    ctx.shadowColor = "#c9a227";
    ctx.shadowBlur = 6 * zoom;
    ctx.beginPath();
    ctx.moveTo(screenPos.x - isoW - 4 * zoom, screenPos.y - 6 * zoom);
    ctx.lineTo(screenPos.x, screenPos.y + isoD - 2 * zoom);
    ctx.lineTo(screenPos.x + isoW + 4 * zoom, screenPos.y - 6 * zoom);
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Royal carpet pattern
    ctx.fillStyle = "#8b0000";
    ctx.beginPath();
    ctx.moveTo(screenPos.x - 8 * zoom, screenPos.y - 4 * zoom);
    ctx.lineTo(screenPos.x, screenPos.y + 4 * zoom);
    ctx.lineTo(screenPos.x + 8 * zoom, screenPos.y - 4 * zoom);
    ctx.lineTo(screenPos.x, screenPos.y - 8 * zoom);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "#c9a227";
    ctx.lineWidth = 1 * zoom;
    ctx.stroke();

    // Royal guard post (left)
    const guardX = screenPos.x - isoW * 0.6;
    const guardY = screenPos.y + 6 * zoom;
    drawIsometricPrism(
      ctx,
      guardX,
      guardY,
      8,
      6,
      16,
      { top: "#5a5a62", left: "#4a4a52", right: "#3a3a42" },
      zoom
    );
    // Guard silhouette
    ctx.fillStyle = "#3a3a42";
    ctx.beginPath();
    ctx.arc(guardX, guardY - 20 * zoom, 3 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillRect(guardX - 2 * zoom, guardY - 17 * zoom, 4 * zoom, 8 * zoom);
    // Spear
    ctx.strokeStyle = "#888888";
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(guardX + 4 * zoom, guardY - 12 * zoom);
    ctx.lineTo(guardX + 4 * zoom, guardY - 28 * zoom);
    ctx.stroke();

    // Royal banner stand (right)
    const bannerX = screenPos.x + isoW * 0.5;
    const bannerY = screenPos.y + 4 * zoom;
    ctx.fillStyle = "#5a4a3a";
    ctx.fillRect(
      bannerX - 1.5 * zoom,
      bannerY - 24 * zoom,
      3 * zoom,
      24 * zoom
    );
    // Banner
    const bannerWave = Math.sin(time * 3) * 2;
    ctx.fillStyle = "#e06000";
    ctx.beginPath();
    ctx.moveTo(bannerX + 1.5 * zoom, bannerY - 24 * zoom);
    ctx.quadraticCurveTo(
      bannerX + 10 * zoom + bannerWave,
      bannerY - 20 * zoom,
      bannerX + 14 * zoom + bannerWave * 0.5,
      bannerY - 18 * zoom
    );
    ctx.lineTo(bannerX + 1.5 * zoom, bannerY - 12 * zoom);
    ctx.closePath();
    ctx.fill();
    // Crown on banner
    ctx.fillStyle = "#c9a227";
    ctx.beginPath();
    ctx.moveTo(bannerX + 5 * zoom + bannerWave * 0.3, bannerY - 20 * zoom);
    ctx.lineTo(bannerX + 6 * zoom + bannerWave * 0.3, bannerY - 22 * zoom);
    ctx.lineTo(bannerX + 8 * zoom + bannerWave * 0.4, bannerY - 20 * zoom);
    ctx.lineTo(bannerX + 10 * zoom + bannerWave * 0.5, bannerY - 22 * zoom);
    ctx.lineTo(bannerX + 11 * zoom + bannerWave * 0.5, bannerY - 20 * zoom);
    ctx.closePath();
    ctx.fill();

    // Treasure chest
    drawIsometricPrism(
      ctx,
      bannerX + 8 * zoom,
      bannerY,
      8,
      6,
      5,
      { top: "#8b4513", left: "#6b3503", right: "#5b2503" },
      zoom
    );
    ctx.fillStyle = "#c9a227";
    ctx.fillRect(bannerX + 5 * zoom, bannerY - 6 * zoom, 6 * zoom, 2 * zoom);
  }

  // Glowing edge on top platform
  const edgeGlow = 0.5 + Math.sin(time * 2) * 0.2;
  ctx.strokeStyle = `rgba(255, 108, 0, ${edgeGlow})`;
  ctx.lineWidth = 2 * zoom;
  ctx.shadowColor = "#e06000";
  ctx.shadowBlur = 8 * zoom;
  ctx.beginPath();
  ctx.moveTo(screenPos.x - isoW, screenPos.y - 4 * zoom);
  ctx.lineTo(screenPos.x, screenPos.y + isoD - 4 * zoom);
  ctx.lineTo(screenPos.x + isoW, screenPos.y - 4 * zoom);
  ctx.stroke();
  ctx.shadowBlur = 0;

  // ========== TRAIN TRACKS WITH SLEEPERS AND SEPARATED RAILS ==========
  const trackLen = baseW * 0.9 * zoom;
  const trackW = 24 * zoom;

  // Helper to draw along isometric track axis
  const trackIso = (baseX: number, baseY: number, offset: number) => ({
    x: baseX + offset * zoom,
    y: baseY - offset * zoom * 0.5,
  });

  // Common track bed (gravel ballast)
  const bedColor =
    tower.level >= 4
      ? "#3a3a42"
      : tower.level >= 3
      ? "#4a4a52"
      : tower.level >= 2
      ? "#3a3a42"
      : "#5a4a3a";
  ctx.fillStyle = bedColor;
  ctx.beginPath();
  ctx.moveTo(
    screenPos.x - trackLen * 0.5,
    screenPos.y + trackLen * 0.25 - 3 * zoom
  );
  ctx.lineTo(screenPos.x, screenPos.y - trackW * 0.12 - 3 * zoom);
  ctx.lineTo(
    screenPos.x + trackLen * 0.5,
    screenPos.y - trackLen * 0.25 - 3 * zoom
  );
  ctx.lineTo(screenPos.x, screenPos.y + trackW * 0.12 - 3 * zoom);
  ctx.closePath();
  ctx.fill();

  // Sleepers (wooden ties across the tracks)
  const numSleepers = 9;
  const sleeperColor =
    tower.level >= 4
      ? "#4a4a52"
      : tower.level >= 3
      ? "#5a5a62"
      : tower.level >= 2
      ? "#5a5a5a"
      : "#6b5030";
  const sleeperDark =
    tower.level >= 4
      ? "#3a3a42"
      : tower.level >= 3
      ? "#4a4a52"
      : tower.level >= 2
      ? "#4a4a4a"
      : "#5a4020";

  for (let i = 0; i < numSleepers; i++) {
    const t = i / (numSleepers - 1) - 0.5;
    const sleeperCenter = trackIso(
      screenPos.x,
      screenPos.y - 5 * zoom,
      ((t * trackLen) / zoom) * 0.85
    );

    // Sleeper is perpendicular to track - draw as small isometric rectangle
    const sw = 12; // sleeper width (perpendicular to track)
    const sd = 3; // sleeper depth (along track)
    const sh = 2; // sleeper height

    // Top face
    ctx.fillStyle = sleeperColor;
    ctx.beginPath();
    ctx.moveTo(
      sleeperCenter.x - sw * zoom * 0.25,
      sleeperCenter.y - sw * zoom * 0.125
    );
    ctx.lineTo(
      sleeperCenter.x + sd * zoom * 0.5,
      sleeperCenter.y - sd * zoom * 0.25 - sw * zoom * 0.125
    );
    ctx.lineTo(
      sleeperCenter.x + sw * zoom * 0.25 + sd * zoom * 0.5,
      sleeperCenter.y - sd * zoom * 0.25 + sw * zoom * 0.125
    );
    ctx.lineTo(
      sleeperCenter.x + sw * zoom * 0.25,
      sleeperCenter.y + sw * zoom * 0.125
    );
    ctx.closePath();
    ctx.fill();

    // Front face
    ctx.fillStyle = sleeperDark;
    ctx.beginPath();
    ctx.moveTo(
      sleeperCenter.x + sw * zoom * 0.25,
      sleeperCenter.y + sw * zoom * 0.125
    );
    ctx.lineTo(
      sleeperCenter.x + sw * zoom * 0.25 + sd * zoom * 0.5,
      sleeperCenter.y - sd * zoom * 0.25 + sw * zoom * 0.125
    );
    ctx.lineTo(
      sleeperCenter.x + sw * zoom * 0.25 + sd * zoom * 0.5,
      sleeperCenter.y - sd * zoom * 0.25 + sw * zoom * 0.125 + sh * zoom
    );
    ctx.lineTo(
      sleeperCenter.x + sw * zoom * 0.25,
      sleeperCenter.y + sw * zoom * 0.125 + sh * zoom
    );
    ctx.closePath();
    ctx.fill();
  }

  // Rails - two separate rails with proper 3D shape
  const railOffsets = [-4, 4]; // Distance from center line
  const railColor =
    tower.level >= 4
      ? tower.upgrade === "A"
        ? "#c9a227"
        : "#7a7a82"
      : "#6a6a6a";
  const railHighlight =
    tower.level >= 4
      ? tower.upgrade === "A"
        ? "#ffe44d"
        : "#9a9aa2"
      : "#8a8a8a";
  const railDark =
    tower.level >= 4
      ? tower.upgrade === "A"
        ? "#b8860b"
        : "#5a5a62"
      : "#4a4a4a";

  for (const railOff of railOffsets) {
    // Rail runs along the track
    const railStart = trackIso(
      screenPos.x,
      screenPos.y - 6 * zoom,
      (-trackLen / zoom) * 0.42
    );
    const railEnd = trackIso(
      screenPos.x,
      screenPos.y - 6 * zoom,
      (trackLen / zoom) * 0.42
    );

    // Offset perpendicular to track
    const perpX = railOff * zoom * 0.25;
    const perpY = railOff * zoom * 0.125;

    // Rail top surface (bright)
    ctx.strokeStyle = railHighlight;
    ctx.lineWidth = 2.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(railStart.x + perpX, railStart.y + perpY);
    ctx.lineTo(railEnd.x + perpX, railEnd.y + perpY);
    ctx.stroke();

    // Rail side (dark)
    ctx.strokeStyle = railDark;
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(railStart.x + perpX, railStart.y + perpY + 1.5 * zoom);
    ctx.lineTo(railEnd.x + perpX, railEnd.y + perpY + 1.5 * zoom);
    ctx.stroke();

    // Rail base flange
    ctx.strokeStyle = railColor;
    ctx.lineWidth = 3.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(railStart.x + perpX, railStart.y + perpY + 2.5 * zoom);
    ctx.lineTo(railEnd.x + perpX, railEnd.y + perpY + 2.5 * zoom);
    ctx.stroke();
  }

  // Rail spikes/fasteners on sleepers
  for (let i = 0; i < numSleepers; i++) {
    const t = i / (numSleepers - 1) - 0.5;
    const sleeperCenter = trackIso(
      screenPos.x,
      screenPos.y - 5 * zoom,
      ((t * trackLen) / zoom) * 0.85
    );

    for (const railOff of railOffsets) {
      const perpX = railOff * zoom * 0.25;
      const perpY = railOff * zoom * 0.125;

      // Spike
      ctx.fillStyle =
        tower.level >= 4 && tower.upgrade === "A" ? "#c9a227" : "#e06000";
      ctx.beginPath();
      ctx.arc(
        sleeperCenter.x + perpX,
        sleeperCenter.y + perpY,
        1.2 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }
  }

  // Level-specific track decorations
  if (tower.level >= 3) {
    // Glowing runes between rails for fortress/royal
    const runeGlow = 0.4 + Math.sin(time * 2) * 0.2;
    ctx.fillStyle = `rgba(255, 108, 0, ${runeGlow})`;
    ctx.shadowColor = "#e06000";
    ctx.shadowBlur = 6 * zoom;
    for (let i = 1; i < numSleepers - 1; i += 2) {
      const t = i / (numSleepers - 1) - 0.5;
      const runePos = trackIso(
        screenPos.x,
        screenPos.y - 5 * zoom,
        ((t * trackLen) / zoom) * 0.85
      );
      ctx.beginPath();
      ctx.arc(runePos.x, runePos.y, 1.5 * zoom, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.shadowBlur = 0;
  }

  if (tower.level === 4 && tower.upgrade === "B") {
    // Maglev glow effect for royal armored
    const maglevGlow = 0.5 + Math.sin(time * 4) * 0.3;
    ctx.strokeStyle = `rgba(255, 108, 0, ${maglevGlow})`;
    ctx.shadowColor = "#e06000";
    ctx.shadowBlur = 10 * zoom;
    ctx.lineWidth = 2 * zoom;
    const glowStart = trackIso(
      screenPos.x,
      screenPos.y - 4 * zoom,
      (-trackLen / zoom) * 0.4
    );
    const glowEnd = trackIso(
      screenPos.x,
      screenPos.y - 4 * zoom,
      (trackLen / zoom) * 0.4
    );
    ctx.beginPath();
    ctx.moveTo(glowStart.x, glowStart.y);
    ctx.lineTo(glowEnd.x, glowEnd.y);
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  // ========== STATION BUILDING (proper isometric alignment) ==========
  const stationX = screenPos.x - 16 * zoom;
  const stationY = screenPos.y - 8 * zoom;

  // Helper: Draw proper isometric sloped roof
  const drawSlopedRoof = (
    cx: number,
    cy: number,
    w: number,
    d: number,
    h: number,
    leftColor: string,
    rightColor: string,
    frontColor: string
  ) => {
    const hw = w * zoom * 0.5;
    const hd = d * zoom * 0.25;
    const rh = h * zoom;

    // Left slope
    ctx.fillStyle = leftColor;
    ctx.beginPath();
    ctx.moveTo(cx, cy - rh);
    ctx.lineTo(cx - hw, cy);
    ctx.lineTo(cx - hw, cy + hd);
    ctx.lineTo(cx, cy - rh + hd * 0.5);
    ctx.closePath();
    ctx.fill();

    // Right slope
    ctx.fillStyle = rightColor;
    ctx.beginPath();
    ctx.moveTo(cx, cy - rh);
    ctx.lineTo(cx + hw, cy);
    ctx.lineTo(cx + hw, cy + hd);
    ctx.lineTo(cx, cy - rh + hd * 0.5);
    ctx.closePath();
    ctx.fill();

    // Front gable
    ctx.fillStyle = frontColor;
    ctx.beginPath();
    ctx.moveTo(cx, cy - rh + hd * 0.5);
    ctx.lineTo(cx - hw, cy + hd);
    ctx.lineTo(cx + hw, cy + hd);
    ctx.closePath();
    ctx.fill();
  };

  // Helper: Draw working clock face
  const drawClockFace = (
    cx: number,
    cy: number,
    radius: number,
    showNumerals: boolean = false
  ) => {
    // Clock backing
    ctx.fillStyle = "#fffff8";
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.fill();

    // Gold border
    ctx.strokeStyle = "#daa520";
    ctx.lineWidth = 2 * zoom;
    ctx.stroke();

    // Hour markers
    ctx.fillStyle = "#1a1a1a";
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2 - Math.PI / 2;
      const markerR = radius * 0.85;
      ctx.beginPath();
      ctx.arc(
        cx + Math.cos(angle) * markerR,
        cy + Math.sin(angle) * markerR,
        radius * 0.06,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }

    // Animated hands
    const hourAngle = ((time * 0.03) % (Math.PI * 2)) - Math.PI / 2;
    const minAngle = ((time * 0.2) % (Math.PI * 2)) - Math.PI / 2;

    // Hour hand
    ctx.strokeStyle = "#1a1a1a";
    ctx.lineWidth = 2.5 * zoom;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(
      cx + Math.cos(hourAngle) * radius * 0.5,
      cy + Math.sin(hourAngle) * radius * 0.5
    );
    ctx.stroke();

    // Minute hand
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(
      cx + Math.cos(minAngle) * radius * 0.75,
      cy + Math.sin(minAngle) * radius * 0.75
    );
    ctx.stroke();

    // Center cap
    ctx.fillStyle = "#daa520";
    ctx.beginPath();
    ctx.arc(cx, cy, radius * 0.12, 0, Math.PI * 2);
    ctx.fill();
  };

  if (tower.level === 1) {
    // ========== LEVEL 1: BARRACKS - Steampunk Wooden Training Facility ==========
    const bX = stationX;
    const bY = stationY;

    // === ENHANCED FOUNDATION with exposed machinery ===
    // Stone foundation base
    drawIsometricPrism(
      ctx,
      bX,
      bY + 6 * zoom,
      36,
      30,
      6,
      { top: "#5a5a5a", left: "#4a4a4a", right: "#3a3a3a" },
      zoom
    );

    // Foundation details - stone blocks
    ctx.strokeStyle = "#2a2a2a";
    ctx.lineWidth = 0.8 * zoom;
    for (let i = 0; i < 4; i++) {
      const fy = bY + 4 * zoom - i * 1.5 * zoom;
      ctx.beginPath();
      ctx.moveTo(bX - 16 * zoom, fy + 4 * zoom);
      ctx.lineTo(bX - 4 * zoom, fy + 7 * zoom);
      ctx.stroke();
    }

    // Exposed pipes on foundation (left side)
    ctx.strokeStyle = "#6b5030";
    ctx.lineWidth = 3 * zoom;
    ctx.beginPath();
    ctx.moveTo(bX - 18 * zoom, bY + 4 * zoom);
    ctx.lineTo(bX - 18 * zoom, bY - 5 * zoom);
    ctx.quadraticCurveTo(
      bX - 18 * zoom,
      bY - 10 * zoom,
      bX - 14 * zoom,
      bY - 10 * zoom
    );
    ctx.stroke();
    // Pipe joints
    ctx.fillStyle = "#8a7355";
    ctx.beginPath();
    ctx.arc(bX - 18 * zoom, bY + 4 * zoom, 2 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(bX - 18 * zoom, bY - 5 * zoom, 2 * zoom, 0, Math.PI * 2);
    ctx.fill();

    // Foundation vent grate
    ctx.fillStyle = "#2a2a2a";
    ctx.fillRect(bX + 8 * zoom, bY + 2 * zoom, 6 * zoom, 4 * zoom);
    ctx.strokeStyle = "#4a4a4a";
    ctx.lineWidth = 1 * zoom;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(bX + 9 * zoom + i * 2 * zoom, bY + 2 * zoom);
      ctx.lineTo(bX + 9 * zoom + i * 2 * zoom, bY + 6 * zoom);
      ctx.stroke();
    }
    // Vent steam
    const ventSteam = 0.3 + Math.sin(time * 3) * 0.2;
    ctx.fillStyle = `rgba(200, 200, 200, ${ventSteam})`;
    ctx.beginPath();
    ctx.arc(
      bX + 11 * zoom,
      bY - 1 * zoom + Math.sin(time * 2) * 2,
      3 * zoom,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Main wooden building
    drawIsometricPrism(
      ctx,
      bX,
      bY,
      32,
      26,
      28,
      { top: "#9b8365", left: "#7b6345", right: "#5b4325" },
      zoom
    );

    // Horizontal log/plank details on left face
    ctx.strokeStyle = "#4a3215";
    ctx.lineWidth = 1.2 * zoom;
    for (let i = 0; i < 5; i++) {
      const ly = bY - 4 * zoom - i * 5 * zoom;
      ctx.beginPath();
      ctx.moveTo(bX - 14 * zoom, ly + 3.5 * zoom);
      ctx.lineTo(bX - 2 * zoom, ly + 6.5 * zoom);
      ctx.stroke();
    }

    // Vertical timber frame details on right face
    ctx.strokeStyle = "#4a3215";
    for (let i = 0; i < 3; i++) {
      const lx = bX + 4 * zoom + i * 5 * zoom;
      ctx.beginPath();
      ctx.moveTo(lx, bY - 2 * zoom);
      ctx.lineTo(lx, bY - 26 * zoom);
      ctx.stroke();
    }

    // === HIGH-TECH ELEMENT: Power conduit on wall ===
    ctx.strokeStyle = "#8b7355";
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.moveTo(bX + 16 * zoom, bY - 5 * zoom);
    ctx.lineTo(bX + 16 * zoom, bY - 20 * zoom);
    ctx.stroke();
    // Conduit glow nodes
    const nodeGlow = 0.5 + Math.sin(time * 4) * 0.3;
    ctx.fillStyle = `rgba(255, 108, 0, ${nodeGlow})`;
    ctx.shadowColor = "#e06000";
    ctx.shadowBlur = 4 * zoom;
    ctx.beginPath();
    ctx.arc(bX + 16 * zoom, bY - 8 * zoom, 1.5 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(bX + 16 * zoom, bY - 16 * zoom, 1.5 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Proper sloped thatched roof
    const roofY = bY - 28 * zoom;
    drawSlopedRoof(bX, roofY, 36, 30, 16, "#6a5a3a", "#5a4a2a", "#7a6a4a");

    // Roof texture lines (thatch effect)
    ctx.strokeStyle = "#4a3a1a";
    ctx.lineWidth = 0.8 * zoom;
    for (let i = 0; i < 4; i++) {
      ctx.beginPath();
      ctx.moveTo(
        bX - 16 * zoom + i * 4 * zoom,
        roofY - 4 * zoom - i * 3 * zoom
      );
      ctx.lineTo(bX - 16 * zoom + i * 4 * zoom, roofY + 4 * zoom - i * zoom);
      ctx.stroke();
    }

    // Large double door (left face)
    ctx.fillStyle = "#4a3215";
    ctx.beginPath();
    ctx.moveTo(bX - 12 * zoom, bY - 2 * zoom);
    ctx.lineTo(bX - 12 * zoom, bY - 18 * zoom);
    ctx.lineTo(bX - 3 * zoom, bY - 16 * zoom);
    ctx.lineTo(bX - 3 * zoom, bY);
    ctx.closePath();
    ctx.fill();
    // Door frame
    ctx.strokeStyle = "#3a2205";
    ctx.lineWidth = 1.5 * zoom;
    ctx.stroke();
    // Door split line
    ctx.beginPath();
    ctx.moveTo(bX - 7.5 * zoom, bY - 1 * zoom);
    ctx.lineTo(bX - 7.5 * zoom, bY - 17 * zoom);
    ctx.stroke();
    // Door handles (brass)
    ctx.fillStyle = "#c9a227";
    ctx.beginPath();
    ctx.arc(bX - 9 * zoom, bY - 9 * zoom, 1.2 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(bX - 6 * zoom, bY - 8.5 * zoom, 1.2 * zoom, 0, Math.PI * 2);
    ctx.fill();

    // Window with warm glow (right face)
    ctx.fillStyle = "#3a2a1a";
    ctx.fillRect(bX + 5 * zoom, bY - 20 * zoom, 8 * zoom, 10 * zoom);
    const winGlow1 = 0.5 + Math.sin(time * 2) * 0.2;
    ctx.fillStyle = `rgba(255, 200, 100, ${winGlow1})`;
    ctx.fillRect(bX + 6 * zoom, bY - 19 * zoom, 6 * zoom, 8 * zoom);
    // Window cross frame
    ctx.strokeStyle = "#3a2a1a";
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(bX + 9 * zoom, bY - 19 * zoom);
    ctx.lineTo(bX + 9 * zoom, bY - 11 * zoom);
    ctx.moveTo(bX + 6 * zoom, bY - 15 * zoom);
    ctx.lineTo(bX + 12 * zoom, bY - 15 * zoom);
    ctx.stroke();

    // Stone chimney with smoke stack
    drawIsometricPrism(
      ctx,
      bX + 6 * zoom,
      roofY - 8 * zoom,
      5,
      4,
      14,
      { top: "#6a6a6a", left: "#5a5a5a", right: "#4a4a4a" },
      zoom
    );
    // Chimney cap
    drawIsometricPrism(
      ctx,
      bX + 6 * zoom,
      roofY - 22 * zoom,
      7,
      5,
      2,
      { top: "#5a5a5a", left: "#4a4a4a", right: "#3a3a3a" },
      zoom
    );
    // Smoke
    const smokeAlpha1 = 0.25 + Math.sin(time * 2) * 0.1;
    ctx.fillStyle = `rgba(180, 180, 180, ${smokeAlpha1})`;
    const smokeOff1 = Math.sin(time * 1.5) * 3;
    ctx.beginPath();
    ctx.arc(
      bX + 6 * zoom + smokeOff1,
      roofY - 28 * zoom,
      3 * zoom,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.beginPath();
    ctx.arc(
      bX + 11 * zoom + smokeOff1 * 0.7,
      roofY - 34 * zoom,
      2.5 * zoom,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // === HIGH-TECH: Small gear on side ===
    const gearX1 = bX - 16 * zoom;
    const gearY1 = bY - 6 * zoom;
    ctx.fillStyle = "#8b7355";
    ctx.beginPath();
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2 + time * 0.5;
      const r = i % 2 === 0 ? 3 * zoom : 2.2 * zoom;
      const x = gearX1 + Math.cos(angle) * r;
      const y = gearY1 + Math.sin(angle) * r * 0.5;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#5a4a3a";
    ctx.beginPath();
    ctx.ellipse(gearX1, gearY1, 1.2 * zoom, 0.6 * zoom, 0, 0, Math.PI * 2);
    ctx.fill();

    // Wooden sign with metal bracket
    ctx.fillStyle = "#5a4a3a";
    ctx.fillRect(bX - 18 * zoom, roofY + 6 * zoom, 24 * zoom, 10 * zoom);
    ctx.strokeStyle = "#3a2a1a";
    ctx.lineWidth = 1.5 * zoom;
    ctx.strokeRect(bX - 18 * zoom, roofY + 6 * zoom, 24 * zoom, 10 * zoom);
    // Metal corners
    ctx.fillStyle = "#8b7355";
    ctx.fillRect(bX - 18 * zoom, roofY + 6 * zoom, 3 * zoom, 3 * zoom);
    ctx.fillRect(bX + 3 * zoom, roofY + 6 * zoom, 3 * zoom, 3 * zoom);
    ctx.fillStyle = "#e06000";
    ctx.font = `bold ${5 * zoom}px serif`;
    ctx.textAlign = "center";
    ctx.fillText("BARRACKS", bX - 6 * zoom, roofY + 13 * zoom);

    // === Lantern on post ===
    const lanternX = bX + 18 * zoom;
    const lanternY = bY - 15 * zoom;
    ctx.fillStyle = "#5a4a3a";
    ctx.fillRect(lanternX - 1 * zoom, lanternY, 2 * zoom, 15 * zoom);
    drawIsometricPrism(
      ctx,
      lanternX,
      lanternY,
      4,
      4,
      6,
      { top: "#6a5a4a", left: "#5a4a3a", right: "#4a3a2a" },
      zoom
    );
    const lanternGlow = 0.6 + Math.sin(time * 3) * 0.2;
    ctx.fillStyle = `rgba(255, 200, 100, ${lanternGlow})`;
    ctx.shadowColor = "#ffcc66";
    ctx.shadowBlur = 8 * zoom;
    ctx.beginPath();
    ctx.arc(lanternX, lanternY - 3 * zoom, 2 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  } else if (tower.level === 2) {
    // ========== LEVEL 2: GARRISON - Industrial Stone Military Outpost ==========
    const bX = stationX;
    const bY = stationY;

    // === ENHANCED FOUNDATION with machinery ===
    // Heavy stone foundation
    drawIsometricPrism(
      ctx,
      bX,
      bY + 8 * zoom,
      40,
      34,
      8,
      { top: "#5a5a62", left: "#4a4a52", right: "#3a3a42" },
      zoom
    );

    // Foundation rivets
    ctx.fillStyle = "#6a6a72";
    for (let i = 0; i < 5; i++) {
      ctx.beginPath();
      ctx.arc(
        bX - 14 * zoom + i * 6 * zoom,
        bY + 6 * zoom - i * 0.5 * zoom,
        1.2 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }

    // Exposed steam pipes on foundation
    ctx.strokeStyle = "#6a6a72";
    ctx.lineWidth = 3.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(bX - 20 * zoom, bY + 6 * zoom);
    ctx.lineTo(bX - 20 * zoom, bY - 8 * zoom);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(bX - 20 * zoom, bY - 8 * zoom);
    ctx.quadraticCurveTo(
      bX - 20 * zoom,
      bY - 14 * zoom,
      bX - 14 * zoom,
      bY - 14 * zoom
    );
    ctx.stroke();
    // Pipe valve wheel
    ctx.strokeStyle = "#8a8a92";
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.arc(bX - 20 * zoom, bY - 2 * zoom, 3 * zoom, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fillStyle = "#e06000";
    ctx.beginPath();
    ctx.arc(bX - 20 * zoom, bY - 2 * zoom, 1 * zoom, 0, Math.PI * 2);
    ctx.fill();

    // Foundation exhaust port
    ctx.fillStyle = "#2a2a32";
    ctx.beginPath();
    ctx.ellipse(
      bX + 14 * zoom,
      bY + 5 * zoom,
      4 * zoom,
      2 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
    // Exhaust glow
    const exhaustGlow = 0.4 + Math.sin(time * 5) * 0.2;
    ctx.fillStyle = `rgba(255, 108, 0, ${exhaustGlow})`;
    ctx.shadowColor = "#e06000";
    ctx.shadowBlur = 6 * zoom;
    ctx.beginPath();
    ctx.ellipse(
      bX + 14 * zoom,
      bY + 5 * zoom,
      2.5 * zoom,
      1.2 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.shadowBlur = 0;

    // Clock tower (attached to main building)
    const towerX = bX + 14 * zoom;
    const towerY = bY - 6 * zoom;
    drawIsometricPrism(
      ctx,
      towerX,
      towerY,
      14,
      12,
      44,
      { top: "#6a6a72", left: "#5a5a62", right: "#4a4a52" },
      zoom
    );

    // Tower stone texture
    ctx.strokeStyle = "#3a3a42";
    ctx.lineWidth = 0.6 * zoom;
    for (let i = 0; i < 8; i++) {
      const ty = towerY - 4 * zoom - i * 5 * zoom;
      ctx.beginPath();
      ctx.moveTo(towerX - 6 * zoom, ty + 1.5 * zoom);
      ctx.lineTo(towerX, ty + 3 * zoom);
      ctx.stroke();
    }

    // Tower roof (pyramid with spire)
    const tRoofY = towerY - 44 * zoom;
    ctx.fillStyle = "#4a4a52";
    ctx.beginPath();
    ctx.moveTo(towerX, tRoofY - 16 * zoom);
    ctx.lineTo(towerX - 8 * zoom, tRoofY);
    ctx.lineTo(towerX, tRoofY + 4 * zoom);
    ctx.lineTo(towerX + 8 * zoom, tRoofY);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#3a3a42";
    ctx.beginPath();
    ctx.moveTo(towerX, tRoofY - 16 * zoom);
    ctx.lineTo(towerX + 8 * zoom, tRoofY);
    ctx.lineTo(towerX, tRoofY + 4 * zoom);
    ctx.closePath();
    ctx.fill();

    // Gold finial
    ctx.fillStyle = "#c9a227";
    ctx.shadowColor = "#c9a227";
    ctx.shadowBlur = 6 * zoom;
    ctx.beginPath();
    ctx.arc(towerX, tRoofY - 18 * zoom, 2.5 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Clock face on tower
    drawClockFace(towerX + 1 * zoom, towerY - 35 * zoom, 6 * zoom);

    // Main stone building
    drawIsometricPrism(
      ctx,
      bX,
      bY,
      34,
      28,
      32,
      { top: "#7a7a82", left: "#5a5a62", right: "#4a4a52" },
      zoom
    );

    // Stone brick texture - left face
    ctx.strokeStyle = "#3a3a42";
    ctx.lineWidth = 0.8 * zoom;
    for (let row = 0; row < 6; row++) {
      const ly = bY - 3 * zoom - row * 5 * zoom;
      const offset = (row % 2) * 5 * zoom;
      for (let col = 0; col < 3; col++) {
        ctx.beginPath();
        ctx.moveTo(bX - 15 * zoom + offset + col * 6 * zoom, ly + 3 * zoom);
        ctx.lineTo(bX - 10 * zoom + offset + col * 6 * zoom, ly + 5 * zoom);
        ctx.stroke();
      }
    }

    // === HIGH-TECH: Power conduits on walls ===
    ctx.strokeStyle = "#5a5a62";
    ctx.lineWidth = 2.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(bX + 17 * zoom, bY - 4 * zoom);
    ctx.lineTo(bX + 17 * zoom, bY - 28 * zoom);
    ctx.stroke();
    // Power nodes with glow
    const powerGlow = 0.6 + Math.sin(time * 3) * 0.3;
    ctx.fillStyle = `rgba(255, 108, 0, ${powerGlow})`;
    ctx.shadowColor = "#e06000";
    ctx.shadowBlur = 6 * zoom;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.arc(
        bX + 17 * zoom,
        bY - 8 * zoom - i * 8 * zoom,
        2 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }
    ctx.shadowBlur = 0;

    // Crenellated battlements on top
    const crenY = bY - 32 * zoom;
    for (let i = 0; i < 5; i++) {
      if (i % 2 === 0) {
        drawIsometricPrism(
          ctx,
          bX - 12 * zoom + i * 6 * zoom,
          crenY,
          5,
          4,
          5,
          { top: "#8a8a92", left: "#6a6a72", right: "#5a5a62" },
          zoom
        );
      }
    }

    // Arched stone doorway
    ctx.fillStyle = "#2a2a32";
    ctx.beginPath();
    ctx.moveTo(bX - 12 * zoom, bY - 2 * zoom);
    ctx.lineTo(bX - 12 * zoom, bY - 14 * zoom);
    ctx.arc(bX - 8 * zoom, bY - 14 * zoom, 4 * zoom, Math.PI, 0);
    ctx.lineTo(bX - 4 * zoom, bY - 2 * zoom);
    ctx.closePath();
    ctx.fill();
    // Arch stones
    ctx.strokeStyle = "#5a5a62";
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.arc(bX - 8 * zoom, bY - 14 * zoom, 4 * zoom, Math.PI, 0);
    ctx.stroke();
    // Door reinforcement
    ctx.strokeStyle = "#8a8a92";
    ctx.lineWidth = 1 * zoom;
    ctx.beginPath();
    ctx.moveTo(bX - 11 * zoom, bY - 8 * zoom);
    ctx.lineTo(bX - 5 * zoom, bY - 7 * zoom);
    ctx.stroke();

    // Arrow slit windows with inner glow
    ctx.fillStyle = "#1a1a22";
    ctx.fillRect(bX + 5 * zoom, bY - 22 * zoom, 2 * zoom, 10 * zoom);
    ctx.fillRect(bX + 10 * zoom, bY - 24 * zoom, 2 * zoom, 10 * zoom);
    const slitGlow = 0.3 + Math.sin(time * 2) * 0.15;
    ctx.fillStyle = `rgba(255, 150, 50, ${slitGlow})`;
    ctx.fillRect(bX + 5.3 * zoom, bY - 21 * zoom, 1.4 * zoom, 8 * zoom);
    ctx.fillRect(bX + 10.3 * zoom, bY - 23 * zoom, 1.4 * zoom, 8 * zoom);

    // === HIGH-TECH: Rotating radar/beacon on tower ===
    const beaconAngle = time * 2;
    ctx.strokeStyle = "#8a8a92";
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.moveTo(towerX, tRoofY - 12 * zoom);
    ctx.lineTo(
      towerX + Math.cos(beaconAngle) * 5 * zoom,
      tRoofY - 12 * zoom + Math.sin(beaconAngle) * 2.5 * zoom
    );
    ctx.stroke();

    // Garrison banner
    ctx.fillStyle = "#e06000";
    const bannerWave2 = Math.sin(time * 3) * 2;
    ctx.beginPath();
    ctx.moveTo(bX - 18 * zoom, crenY - 2 * zoom);
    ctx.lineTo(bX - 18 * zoom, crenY - 16 * zoom);
    ctx.quadraticCurveTo(
      bX - 10 * zoom + bannerWave2,
      crenY - 14 * zoom,
      bX - 4 * zoom + bannerWave2 * 0.5,
      crenY - 12 * zoom
    );
    ctx.lineTo(bX - 4 * zoom, crenY - 2 * zoom);
    ctx.closePath();
    ctx.fill();
    // Banner pole
    ctx.strokeStyle = "#4a4a52";
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.moveTo(bX - 18 * zoom, crenY + 2 * zoom);
    ctx.lineTo(bX - 18 * zoom, crenY - 18 * zoom);
    ctx.stroke();

    // === Mechanical gears on side ===
    const gearX = bX - 17 * zoom;
    const gearY = bY - 20 * zoom;
    // Large gear
    ctx.fillStyle = "#6a6a72";
    ctx.beginPath();
    for (let i = 0; i < 10; i++) {
      const angle = (i / 10) * Math.PI * 2 + time * 0.3;
      const r = i % 2 === 0 ? 4 * zoom : 3 * zoom;
      const x = gearX + Math.cos(angle) * r;
      const y = gearY + Math.sin(angle) * r * 0.5;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
    // Small interlocking gear
    ctx.beginPath();
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2 - time * 0.4;
      const r = i % 2 === 0 ? 2.5 * zoom : 1.8 * zoom;
      const x = gearX + 5 * zoom + Math.cos(angle) * r;
      const y = gearY + 2.5 * zoom + Math.sin(angle) * r * 0.5;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
    // Gear centers
    ctx.fillStyle = "#3a3a42";
    ctx.beginPath();
    ctx.ellipse(gearX, gearY, 1.5 * zoom, 0.75 * zoom, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(
      gearX + 5 * zoom,
      gearY + 2.5 * zoom,
      1 * zoom,
      0.5 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Sign plate with industrial frame
    ctx.fillStyle = "#5a5a62";
    ctx.fillRect(bX - 16 * zoom, bY + 6 * zoom, 26 * zoom, 9 * zoom);
    ctx.strokeStyle = "#8a8a92";
    ctx.lineWidth = 2 * zoom;
    ctx.strokeRect(bX - 16 * zoom, bY + 6 * zoom, 26 * zoom, 9 * zoom);
    // Corner bolts
    ctx.fillStyle = "#6a6a72";
    ctx.beginPath();
    ctx.arc(bX - 14 * zoom, bY + 8 * zoom, 1.5 * zoom, 0, Math.PI * 2);
    ctx.arc(bX + 8 * zoom, bY + 8 * zoom, 1.5 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#e06000";
    ctx.font = `bold ${4.5 * zoom}px serif`;
    ctx.textAlign = "center";
    ctx.fillText("GARRISON", bX - 3 * zoom, bY + 12.5 * zoom);
  } else if (tower.level === 3) {
    // ========== LEVEL 3: FORTRESS - Industrial Castle ==========
    const bX = stationX;
    const bY = stationY;

    // === FOUNDATION - Industrial fortress base (extends lower) ===
    drawIsometricPrism(
      ctx,
      bX,
      bY + 2 * zoom,
      42,
      40,
      4,
      { top: "#5a5a62", left: "#4a4a52", right: "#3a3a42" },
      zoom
    );

    // Foundation armor plating
    ctx.strokeStyle = "#3a3a42";
    ctx.lineWidth = 1.5 * zoom;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(bX - 18 * zoom, bY + 12 * zoom - i * 3 * zoom);
      ctx.lineTo(bX - 6 * zoom, bY + 16 * zoom - i * 3 * zoom);
      ctx.stroke();
    }

    // Heavy machinery in foundation - gear system
    const fGearX = bX + 14 * zoom;
    const fGearY = bY + 9 * zoom;
    ctx.fillStyle = "#5a5a62";
    ctx.beginPath();
    for (let i = 0; i < 10; i++) {
      const angle = (i / 10) * Math.PI * 2 + time * 0.2;
      const r = i % 2 === 0 ? 4 * zoom : 3 * zoom;
      const x = fGearX + Math.cos(angle) * r;
      const y = fGearY + Math.sin(angle) * r * 0.5;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#3a3a42";
    ctx.beginPath();
    ctx.ellipse(fGearX, fGearY, 1.5 * zoom, 0.75 * zoom, 0, 0, Math.PI * 2);
    ctx.fill();

    // Steam exhaust vents
    ctx.fillStyle = "#3a3a42";
    ctx.beginPath();
    ctx.ellipse(
      bX - 14 * zoom,
      bY + 12 * zoom,
      2.5 * zoom,
      1.2 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
    const fSteam = 0.35 + Math.sin(time * 4) * 0.2;
    ctx.fillStyle = `rgba(200, 200, 200, ${fSteam})`;
    ctx.beginPath();
    ctx.arc(
      bX - 14 * zoom + Math.sin(time * 2) * 2,
      bY + 5 * zoom,
      3.5 * zoom,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Power conduit running along foundation
    ctx.strokeStyle = "#5a5a62";
    ctx.lineWidth = 2.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(bX - 18 * zoom, bY + 10 * zoom);
    ctx.lineTo(bX + 18 * zoom, bY + 6 * zoom);
    ctx.stroke();
    // Conduit energy nodes
    const cGlow = 0.4 + Math.sin(time * 3) * 0.2;
    ctx.fillStyle = `rgba(255, 108, 0, ${cGlow})`;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.arc(
        bX - 12 * zoom + i * 10 * zoom,
        bY + 9 * zoom - i * 0.8 * zoom,
        1.5 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }

    // Right clock tower (taller) with machinery
    const rtX = bX + 18 * zoom;
    const rtY = bY - 6 * zoom;
    drawIsometricPrism(
      ctx,
      rtX,
      rtY,
      12,
      10,
      48,
      { top: "#5a5a62", left: "#4a4a52", right: "#3a3a42" },
      zoom
    );

    // Main keep (central building)
    drawIsometricPrism(
      ctx,
      bX,
      bY - 1 * zoom,
      32,
      30,
      32,
      { top: "#6a6a72", left: "#5a5a62", right: "#4a4a52" },
      zoom
    );

    // Stone block texture
    ctx.strokeStyle = "#3a3a42";
    ctx.lineWidth = 0.6 * zoom;
    for (let row = 0; row < 6; row++) {
      const ly = bY - 4 * zoom - row * 5 * zoom;
      const offset = (row % 2) * 4 * zoom;
      ctx.beginPath();
      ctx.moveTo(bX - 14 * zoom + offset, ly + 4 * zoom);
      ctx.lineTo(bX - 6 * zoom + offset, ly + 6 * zoom);
      ctx.stroke();
    }

    // Heavy battlements on main keep
    const keepTop = bY - 32.5 * zoom;
    for (let i = 0; i < 5; i++) {
      if (i % 2 === 0) {
        drawIsometricPrism(
          ctx,
          bX - 8 * zoom + i * 4.5 * zoom,
          keepTop,
          5,
          4,
          5,
          { top: "#7a7a82", left: "#5a5a62", right: "#4a4a52" },
          zoom
        );
      }
    }

    // Left corner tower
    const ltX = bX - 16 * zoom;
    const ltY = bY + 4 * zoom;
    drawIsometricPrism(
      ctx,
      ltX,
      ltY,
      10,
      8,
      42,
      { top: "#5a5a62", left: "#4a4a52", right: "#3a3a42" },
      zoom
    );
    // Tower armor bands
    ctx.strokeStyle = "#6a6a72";
    ctx.lineWidth = 1.5 * zoom;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(ltX - 4 * zoom, ltY - 10 * zoom - i * 12 * zoom);
      ctx.lineTo(ltX + 4 * zoom, ltY - 8 * zoom - i * 12 * zoom);
      ctx.stroke();
    }
    // Tower top conical roof
    const ltRoofY = ltY - 42 * zoom;
    ctx.fillStyle = "#4a4a52";
    ctx.beginPath();
    ctx.moveTo(ltX, ltRoofY - 12 * zoom);
    ctx.lineTo(ltX - 6 * zoom, ltRoofY);
    ctx.lineTo(ltX, ltRoofY + 3 * zoom);
    ctx.lineTo(ltX + 6 * zoom, ltRoofY);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#3a3a42";
    ctx.beginPath();
    ctx.moveTo(ltX, ltRoofY - 12 * zoom);
    ctx.lineTo(ltX + 6 * zoom, ltRoofY);
    ctx.lineTo(ltX, ltRoofY + 3 * zoom);
    ctx.closePath();
    ctx.fill();
    // Flag on left tower
    ctx.fillStyle = "#e06000";
    const flagWave = Math.sin(time * 4) * 2;
    ctx.beginPath();
    ctx.moveTo(ltX, ltRoofY - 14 * zoom);
    ctx.lineTo(ltX, ltRoofY - 24 * zoom);
    ctx.quadraticCurveTo(
      ltX + 7 * zoom + flagWave,
      ltRoofY - 22 * zoom,
      ltX + 10 * zoom + flagWave,
      ltRoofY - 20 * zoom
    );
    ctx.lineTo(ltX, ltRoofY - 18 * zoom);
    ctx.closePath();
    ctx.fill();

    // Tower gears
    const tGearX = rtX - 3 * zoom;
    const tGearY = rtY - 18 * zoom;
    ctx.fillStyle = "#7a7a82";
    ctx.beginPath();
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2 + time * 0.5;
      const r = i % 2 === 0 ? 3.5 * zoom : 2.5 * zoom;
      const x = tGearX + Math.cos(angle) * r;
      const y = tGearY + Math.sin(angle) * r * 0.5;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();

    // Tower spire
    const rtRoofY = rtY - 48 * zoom;
    ctx.fillStyle = "#4a4a52";
    ctx.beginPath();
    ctx.moveTo(rtX, rtRoofY - 16 * zoom);
    ctx.lineTo(rtX - 7 * zoom, rtRoofY);
    ctx.lineTo(rtX, rtRoofY + 3 * zoom);
    ctx.lineTo(rtX + 7 * zoom, rtRoofY);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#3a3a42";
    ctx.beginPath();
    ctx.moveTo(rtX, rtRoofY - 16 * zoom);
    ctx.lineTo(rtX + 7 * zoom, rtRoofY);
    ctx.lineTo(rtX, rtRoofY + 3 * zoom);
    ctx.closePath();
    ctx.fill();
    // Bronze finial
    ctx.fillStyle = "#a88217";
    ctx.beginPath();
    ctx.arc(rtX, rtRoofY - 18 * zoom, 2 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillRect(rtX - 1 * zoom, rtRoofY - 24 * zoom, 2 * zoom, 8 * zoom);

    // Clock on right tower
    drawClockFace(rtX + 1 * zoom, rtY - 36 * zoom, 6 * zoom, true);

    // Grand portcullis entrance
    ctx.fillStyle = "#1a1a22";
    ctx.beginPath();
    ctx.moveTo(bX - 7 * zoom, bY - 2 * zoom);
    ctx.lineTo(bX - 7 * zoom, bY - 16 * zoom);
    ctx.arc(bX - 2 * zoom, bY - 16 * zoom, 5 * zoom, Math.PI, 0);
    ctx.lineTo(bX + 3 * zoom, bY - 2 * zoom);
    ctx.closePath();
    ctx.fill();
    // Portcullis bars
    ctx.strokeStyle = "#6a6a72";
    ctx.lineWidth = 1.5 * zoom;
    for (let i = 0; i < 4; i++) {
      ctx.beginPath();
      ctx.moveTo(bX - 7 * zoom + i * 3 * zoom, bY - 2 * zoom);
      ctx.lineTo(bX - 7 * zoom + i * 3 * zoom, bY - 16 * zoom + i * 0.6 * zoom);
      ctx.stroke();
    }
    // Horizontal bar
    ctx.beginPath();
    ctx.moveTo(bX - 8 * zoom, bY - 8 * zoom);
    ctx.lineTo(bX + 2 * zoom, bY - 6 * zoom);
    ctx.stroke();

    // Rose window above entrance (glowing)
    const roseGlow = 0.4 + Math.sin(time * 2) * 0.2;
    ctx.fillStyle = `rgba(255, 108, 0, ${roseGlow})`;
    ctx.beginPath();
    ctx.arc(bX - 3 * zoom, bY - 26 * zoom, 4 * zoom, 0, Math.PI * 2);
    ctx.fill();
    // Rose window frame
    ctx.strokeStyle = "#5a5a62";
    ctx.lineWidth = 1.5 * zoom;
    ctx.stroke();

    // Fortress banner
    ctx.fillStyle = "#4a4a52";
    ctx.fillRect(bX - 14 * zoom, bY + 12 * zoom, 28 * zoom, 10 * zoom);
    ctx.strokeStyle = "#6a6a72";
    ctx.lineWidth = 2 * zoom;
    ctx.strokeRect(bX - 14 * zoom, bY + 12 * zoom, 28 * zoom, 10 * zoom);
    ctx.fillStyle = "#e06000";
    ctx.font = `bold ${4.5 * zoom}px serif`;
    ctx.textAlign = "center";
    ctx.fillText("FORTRESS", bX, bY + 19 * zoom);
  } else if (tower.level === 4 && tower.upgrade === "A") {
    // ========== LEVEL 4A: CENTAUR STABLES - Grand Archer's Training Grounds ==========
    const bX = stationX;
    const bY = stationY;

    // === ENHANCED FOUNDATION - Stone with brass pipes (extends lower) ===
    drawIsometricPrism(
      ctx,
      bX,
      bY + 16 * zoom,
      44,
      38,
      12,
      { top: "#8a7a6a", left: "#7a6a5a", right: "#6a5a4a" },
      zoom
    );

    // Foundation brass trim with rivets
    ctx.strokeStyle = "#b89227";
    ctx.lineWidth = 2.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(bX - 20 * zoom, bY + 12 * zoom);
    ctx.lineTo(bX + 4 * zoom, bY + 16 * zoom);
    ctx.stroke();
    // Decorative rivets
    ctx.fillStyle = "#c9a227";
    for (let i = 0; i < 4; i++) {
      ctx.beginPath();
      ctx.arc(
        bX - 16 * zoom + i * 6 * zoom,
        bY + 13 * zoom - i * 0.5 * zoom,
        1.2 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }

    // Steam pipes running along foundation
    ctx.strokeStyle = "#8b7355";
    ctx.lineWidth = 3.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(bX - 22 * zoom, bY + 10 * zoom);
    ctx.lineTo(bX - 22 * zoom, bY - 12 * zoom);
    ctx.quadraticCurveTo(
      bX - 22 * zoom,
      bY - 18 * zoom,
      bX - 16 * zoom,
      bY - 18 * zoom
    );
    ctx.stroke();
    // Pipe joints
    ctx.fillStyle = "#b89227";
    ctx.beginPath();
    ctx.arc(bX - 22 * zoom, bY + 10 * zoom, 2.5 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(bX - 22 * zoom, bY - 12 * zoom, 2.5 * zoom, 0, Math.PI * 2);
    ctx.fill();

    // Large animated gear cluster
    const fGearX = bX + 18 * zoom;
    const fGearY = bY + 8 * zoom;
    ctx.fillStyle = "#b89227";
    ctx.beginPath();
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2 + time * 0.25;
      const r = i % 2 === 0 ? 5 * zoom : 3.8 * zoom;
      const gx = fGearX + Math.cos(angle) * r;
      const gy = fGearY + Math.sin(angle) * r * 0.5;
      if (i === 0) ctx.moveTo(gx, gy);
      else ctx.lineTo(gx, gy);
    }
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#6a5a4a";
    ctx.beginPath();
    ctx.ellipse(fGearX, fGearY, 2 * zoom, 1 * zoom, 0, 0, Math.PI * 2);
    ctx.fill();

    // Interlocking gears
    const fGear2X = fGearX - 7 * zoom;
    const fGear2Y = fGearY + 3 * zoom;
    ctx.fillStyle = "#a88217";
    ctx.beginPath();
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2 - time * 0.35;
      const r = i % 2 === 0 ? 3.5 * zoom : 2.5 * zoom;
      const gx = fGear2X + Math.cos(angle) * r;
      const gy = fGear2Y + Math.sin(angle) * r * 0.5;
      if (i === 0) ctx.moveTo(gx, gy);
      else ctx.lineTo(gx, gy);
    }
    ctx.closePath();
    ctx.fill();

    // Steam vents with animated puffs
    ctx.fillStyle = "#5a4a3a";
    ctx.beginPath();
    ctx.ellipse(
      bX - 14 * zoom,
      bY + 12 * zoom,
      3 * zoom,
      1.5 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
    const steamPuff = 0.4 + Math.sin(time * 3) * 0.2;
    ctx.fillStyle = `rgba(200, 200, 200, ${steamPuff})`;
    ctx.beginPath();
    ctx.arc(
      bX - 14 * zoom + Math.sin(time * 2) * 2,
      bY + 4 * zoom,
      4 * zoom,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.fillStyle = `rgba(180, 180, 180, ${steamPuff * 0.6})`;
    ctx.beginPath();
    ctx.arc(
      bX - 13 * zoom + Math.sin(time * 2.5) * 2,
      bY - 2 * zoom,
      3 * zoom,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // === ARCHERY TARGET (Left side - on platform) ===
    const targetX = bX - 18 * zoom;
    const targetY = bY + 2 * zoom;
    // Target stand
    ctx.fillStyle = "#5a4020";
    ctx.fillRect(targetX - 1 * zoom, targetY - 6 * zoom, 2 * zoom, 12 * zoom);
    ctx.fillRect(targetX - 4 * zoom, targetY + 4 * zoom, 8 * zoom, 2 * zoom);
    // Target rings
    ctx.fillStyle = "#f0f0e0";
    ctx.beginPath();
    ctx.ellipse(
      targetX,
      targetY - 10 * zoom,
      6 * zoom,
      3 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.fillStyle = "#c03030";
    ctx.beginPath();
    ctx.ellipse(
      targetX,
      targetY - 10 * zoom,
      4.5 * zoom,
      2.2 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.fillStyle = "#f0f0e0";
    ctx.beginPath();
    ctx.ellipse(
      targetX,
      targetY - 10 * zoom,
      3 * zoom,
      1.5 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.fillStyle = "#c03030";
    ctx.beginPath();
    ctx.ellipse(
      targetX,
      targetY - 10 * zoom,
      1.5 * zoom,
      0.75 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
    // Arrow in target
    ctx.strokeStyle = "#5a3a1a";
    ctx.lineWidth = 1.2 * zoom;
    ctx.beginPath();
    ctx.moveTo(targetX + 1.5 * zoom, targetY - 10.5 * zoom);
    ctx.lineTo(targetX + 5 * zoom, targetY - 9 * zoom);
    ctx.stroke();

    // === LEFT HORSE STABLE ===
    const lwX = bX - 16 * zoom;
    const lwY = bY + 6 * zoom;
    drawIsometricPrism(
      ctx,
      lwX,
      lwY,
      14,
      12,
      22,
      { top: "#9b7b5b", left: "#8b6b4b", right: "#7b5b3b" },
      zoom
    );
    // Stable roof
    drawSlopedRoof(
      lwX,
      lwY - 22 * zoom,
      18,
      15,
      10,
      "#6a5030",
      "#5a4020",
      "#7a6040"
    );
    // Stable door
    ctx.fillStyle = "#4a3015";
    ctx.fillRect(lwX - 5 * zoom, lwY - 14 * zoom, 8 * zoom, 14 * zoom);
    ctx.strokeStyle = "#3a2005";
    ctx.lineWidth = 1.5 * zoom;
    ctx.strokeRect(lwX - 4.5 * zoom, lwY - 13.5 * zoom, 7 * zoom, 6 * zoom);
    // Horse head
    ctx.fillStyle = "#c9a868";
    ctx.beginPath();
    ctx.ellipse(
      lwX - 1 * zoom,
      lwY - 10 * zoom,
      3 * zoom,
      2.5 * zoom,
      -0.3,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.fillStyle = "#2a1a0a";
    ctx.beginPath();
    ctx.arc(lwX + 0.5 * zoom, lwY - 10.5 * zoom, 0.8 * zoom, 0, Math.PI * 2);
    ctx.fill();
    // Brass horseshoe
    ctx.strokeStyle = "#c9a227";
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.arc(
      lwX - 1 * zoom,
      lwY - 18 * zoom,
      3 * zoom,
      0.3 * Math.PI,
      0.7 * Math.PI,
      true
    );
    ctx.stroke();
    // Orange pennant on stable
    const lwFlagWave = Math.sin(time * 4) * 2;
    ctx.fillStyle = "#ff6600";
    ctx.beginPath();
    ctx.moveTo(lwX + 2 * zoom, lwY - 30 * zoom);
    ctx.lineTo(lwX + 2 * zoom, lwY - 38 * zoom);
    ctx.quadraticCurveTo(
      lwX + 8 * zoom + lwFlagWave,
      lwY - 36 * zoom,
      lwX + 10 * zoom + lwFlagWave,
      lwY - 34 * zoom
    );
    ctx.lineTo(lwX + 2 * zoom, lwY - 34 * zoom);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#b89227";
    ctx.fillRect(lwX + 1 * zoom, lwY - 40 * zoom, 2 * zoom, 12 * zoom);

    // === RIGHT HORSE STABLE ===
    const rwX = bX + 18 * zoom;
    const rwY = bY + 6 * zoom;
    drawIsometricPrism(
      ctx,
      rwX,
      rwY,
      14,
      12,
      22,
      { top: "#9b7b5b", left: "#8b6b4b", right: "#7b5b3b" },
      zoom
    );
    drawSlopedRoof(
      rwX,
      rwY - 22 * zoom,
      18,
      15,
      10,
      "#6a5030",
      "#5a4020",
      "#7a6040"
    );
    ctx.fillStyle = "#4a3015";
    ctx.fillRect(rwX - 2 * zoom, rwY - 14 * zoom, 8 * zoom, 14 * zoom);
    // Horse head
    ctx.fillStyle = "#8b6b4b";
    ctx.beginPath();
    ctx.ellipse(
      rwX + 2 * zoom,
      rwY - 10 * zoom,
      3 * zoom,
      2.5 * zoom,
      0.3,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.fillStyle = "#2a1a0a";
    ctx.beginPath();
    ctx.arc(rwX + 3.5 * zoom, rwY - 10.5 * zoom, 0.8 * zoom, 0, Math.PI * 2);
    ctx.fill();
    // Orange pennant
    ctx.fillStyle = "#ff6600";
    ctx.beginPath();
    ctx.moveTo(rwX - 2 * zoom, rwY - 30 * zoom);
    ctx.lineTo(rwX - 2 * zoom, rwY - 38 * zoom);
    ctx.quadraticCurveTo(
      rwX + 4 * zoom + lwFlagWave,
      rwY - 36 * zoom,
      rwX + 6 * zoom + lwFlagWave,
      rwY - 34 * zoom
    );
    ctx.lineTo(rwX - 2 * zoom, rwY - 34 * zoom);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#b89227";
    ctx.fillRect(rwX - 3 * zoom, rwY - 40 * zoom, 2 * zoom, 12 * zoom);

    // === MAIN BUILDING - Gilded Archery Hall ===
    drawIsometricPrism(
      ctx,
      bX,
      bY,
      30,
      24,
      34,
      { top: "#a08060", left: "#907050", right: "#806040" },
      zoom
    );

    // Vertical wood planks
    ctx.strokeStyle = "#5a4020";
    ctx.lineWidth = 1 * zoom;
    for (let i = 0; i < 4; i++) {
      ctx.beginPath();
      ctx.moveTo(bX - 12 * zoom + i * 4 * zoom, bY - 2 * zoom);
      ctx.lineTo(bX - 12 * zoom + i * 4 * zoom, bY - 32 * zoom);
      ctx.stroke();
    }

    // Brass bands
    ctx.strokeStyle = "#b89227";
    ctx.lineWidth = 2.5 * zoom;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(bX - 13 * zoom, bY - 8 * zoom - i * 10 * zoom);
      ctx.lineTo(bX + 2 * zoom, bY - 5 * zoom - i * 10 * zoom);
      ctx.stroke();
    }

    // Decorative bow emblem on wall
    ctx.strokeStyle = "#c9a227";
    ctx.lineWidth = 2.5 * zoom;
    ctx.beginPath();
    ctx.arc(
      bX - 5 * zoom,
      bY - 22 * zoom,
      5 * zoom,
      -Math.PI * 0.6,
      Math.PI * 0.6
    );
    ctx.stroke();

    // Main barn roof
    const roofY = bY - 34 * zoom;
    ctx.fillStyle = "#5a4020";
    ctx.beginPath();
    ctx.moveTo(bX, roofY - 18 * zoom);
    ctx.lineTo(bX - 18 * zoom, roofY);
    ctx.lineTo(bX, roofY + 10 * zoom);
    ctx.lineTo(bX + 18 * zoom, roofY);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#4a3010";
    ctx.beginPath();
    ctx.moveTo(bX, roofY - 18 * zoom);
    ctx.lineTo(bX + 18 * zoom, roofY);
    ctx.lineTo(bX, roofY + 10 * zoom);
    ctx.closePath();
    ctx.fill();

    // Brass weathervane centaur on roof
    ctx.fillStyle = "#c9a227";
    const vaneX = bX;
    const vaneY = roofY - 20 * zoom;
    ctx.fillRect(vaneX - 1 * zoom, vaneY, 2 * zoom, 6 * zoom);
    ctx.beginPath();
    ctx.ellipse(vaneX, vaneY - 4 * zoom, 5 * zoom, 3 * zoom, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(vaneX + 2 * zoom, vaneY - 6 * zoom);
    ctx.lineTo(vaneX + 1 * zoom, vaneY - 11 * zoom);
    ctx.lineTo(vaneX + 3 * zoom, vaneY - 10 * zoom);
    ctx.closePath();
    ctx.fill();

    // Main entrance
    ctx.fillStyle = "#3a2010";
    ctx.beginPath();
    ctx.moveTo(bX - 6 * zoom, bY - 2 * zoom);
    ctx.lineTo(bX - 6 * zoom, bY - 18 * zoom);
    ctx.arc(bX - 2 * zoom, bY - 18 * zoom, 4 * zoom, Math.PI, 0);
    ctx.lineTo(bX + 2 * zoom, bY - 2 * zoom);
    ctx.closePath();
    ctx.fill();
    // Interior glow
    const interiorGlow = 0.4 + Math.sin(time * 2) * 0.15;
    ctx.fillStyle = `rgba(255, 180, 100, ${interiorGlow})`;
    ctx.beginPath();
    ctx.ellipse(
      bX - 2 * zoom,
      bY - 10 * zoom,
      3 * zoom,
      6 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
    // Brass arch trim
    ctx.strokeStyle = "#b89227";
    ctx.lineWidth = 2.5 * zoom;
    ctx.beginPath();
    ctx.arc(bX - 2 * zoom, bY - 18 * zoom, 4.5 * zoom, Math.PI, 0);
    ctx.stroke();

    // Pressure gauge on wall
    const gaugeX = bX + 12 * zoom;
    const gaugeY = bY - 18 * zoom;
    ctx.fillStyle = "#b89227";
    ctx.beginPath();
    ctx.arc(gaugeX, gaugeY, 4 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#f0f0e8";
    ctx.beginPath();
    ctx.arc(gaugeX, gaugeY, 3 * zoom, 0, Math.PI * 2);
    ctx.fill();
    const needleAngle = Math.PI + Math.sin(time * 2) * 0.4 + Math.PI * 0.6;
    ctx.strokeStyle = "#cc0000";
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(gaugeX, gaugeY);
    ctx.lineTo(
      gaugeX + Math.cos(needleAngle) * 2.5 * zoom,
      gaugeY + Math.sin(needleAngle) * 2.5 * zoom
    );
    ctx.stroke();

    // Hay bale
    ctx.fillStyle = "#d4a017";
    ctx.beginPath();
    ctx.ellipse(
      bX + 14 * zoom,
      bY + 8 * zoom,
      5 * zoom,
      3.5 * zoom,
      0.2,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.strokeStyle = "#a08010";
    ctx.lineWidth = 1 * zoom;
    ctx.stroke();

    // Sign with brass frame
    ctx.fillStyle = "#5a4a3a";
    ctx.fillRect(bX - 14 * zoom, bY + 12 * zoom, 28 * zoom, 10 * zoom);
    ctx.strokeStyle = "#b89227";
    ctx.lineWidth = 2 * zoom;
    ctx.strokeRect(bX - 14 * zoom, bY + 12 * zoom, 28 * zoom, 10 * zoom);
    ctx.fillStyle = "#c9a227";
    ctx.font = `bold ${4.5 * zoom}px serif`;
    ctx.textAlign = "center";
    ctx.fillText("STABLES", bX, bY + 19 * zoom);
  } else {
    // ========== LEVEL 4B: ROYAL CAVALRY FORTRESS - Orange Royal Military Stronghold ==========
    const bX = stationX;
    const bY = stationY;

    // === FOUNDATION - Royal armored base with orange trim (extends lower) ===
    drawIsometricPrism(
      ctx,
      bX,
      bY + 16 * zoom,
      46,
      40,
      12,
      { top: "#5a5a62", left: "#4a4a52", right: "#3a3a42" },
      zoom
    );

    // Orange trim bands on foundation
    ctx.strokeStyle = "#e06000";
    ctx.lineWidth = 2.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(bX - 21 * zoom, bY + 12 * zoom);
    ctx.lineTo(bX + 4 * zoom, bY + 16 * zoom);
    ctx.stroke();
    // Bronze rivets (less intense than gold)
    ctx.fillStyle = "#c9a227";
    for (let i = 0; i < 5; i++) {
      ctx.beginPath();
      ctx.arc(
        bX - 17 * zoom + i * 5 * zoom,
        bY + 13 * zoom - i * 0.5 * zoom,
        1.5 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }

    // === SPEAR RACK (Left side - on platform) ===
    const spearRackX = bX - 20 * zoom;
    const spearRackY = bY + 6 * zoom;
    ctx.fillStyle = "#5a4020";
    ctx.fillRect(
      spearRackX - 2 * zoom,
      spearRackY - 16 * zoom,
      4 * zoom,
      20 * zoom
    );
    ctx.fillRect(
      spearRackX - 5 * zoom,
      spearRackY - 16 * zoom,
      10 * zoom,
      3 * zoom
    );
    // Spears on rack
    for (let i = 0; i < 3; i++) {
      const sx = spearRackX - 3 * zoom + i * 3 * zoom;
      ctx.strokeStyle = "#6a5030";
      ctx.lineWidth = 2 * zoom;
      ctx.beginPath();
      ctx.moveTo(sx, spearRackY - 14 * zoom);
      ctx.lineTo(sx, spearRackY - 30 * zoom);
      ctx.stroke();
      // Spear tips
      ctx.fillStyle = "#c0c0c0";
      ctx.beginPath();
      ctx.moveTo(sx, spearRackY - 33 * zoom);
      ctx.lineTo(sx - 2 * zoom, spearRackY - 28 * zoom);
      ctx.lineTo(sx + 2 * zoom, spearRackY - 28 * zoom);
      ctx.closePath();
      ctx.fill();
    }

    // === LEFT HORSE STABLE ===
    const lwX = bX - 16 * zoom;
    const lwY = bY + 6 * zoom;
    drawIsometricPrism(
      ctx,
      lwX,
      lwY,
      14,
      12,
      24,
      { top: "#6a5a4a", left: "#5a4a3a", right: "#4a3a2a" },
      zoom
    );
    drawSlopedRoof(
      lwX,
      lwY - 24 * zoom,
      18,
      15,
      12,
      "#4a4a52",
      "#3a3a42",
      "#5a5a62"
    );
    // Stable door
    ctx.fillStyle = "#3a2a1a";
    ctx.fillRect(lwX - 5 * zoom, lwY - 16 * zoom, 8 * zoom, 16 * zoom);
    ctx.strokeStyle = "#e06000";
    ctx.lineWidth = 1.5 * zoom;
    ctx.strokeRect(lwX - 4.5 * zoom, lwY - 15.5 * zoom, 7 * zoom, 7 * zoom);
    // War horse head
    ctx.fillStyle = "#3a2a1a";
    ctx.beginPath();
    ctx.ellipse(
      lwX - 1 * zoom,
      lwY - 11 * zoom,
      3.5 * zoom,
      2.8 * zoom,
      -0.3,
      0,
      Math.PI * 2
    );
    ctx.fill();
    // Orange eye (subtle)
    ctx.fillStyle = "#e07000";
    ctx.beginPath();
    ctx.arc(lwX + 0.5 * zoom, lwY - 11.5 * zoom, 0.8 * zoom, 0, Math.PI * 2);
    ctx.fill();
    // Bronze horseshoe
    ctx.strokeStyle = "#b89227";
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.arc(
      lwX - 1 * zoom,
      lwY - 20 * zoom,
      3 * zoom,
      0.3 * Math.PI,
      0.7 * Math.PI,
      true
    );
    ctx.stroke();
    // Orange pennant
    const lwFlagWave = Math.sin(time * 4) * 2;
    ctx.fillStyle = "#e06000";
    ctx.beginPath();
    ctx.moveTo(lwX + 2 * zoom, lwY - 34 * zoom);
    ctx.lineTo(lwX + 2 * zoom, lwY - 44 * zoom);
    ctx.quadraticCurveTo(
      lwX + 8 * zoom + lwFlagWave,
      lwY - 42 * zoom,
      lwX + 10 * zoom + lwFlagWave,
      lwY - 40 * zoom
    );
    ctx.lineTo(lwX + 2 * zoom, lwY - 38 * zoom);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#b89227";
    ctx.fillRect(lwX + 1 * zoom, lwY - 46 * zoom, 2 * zoom, 14 * zoom);

    // === RIGHT HORSE STABLE ===
    const rwX = bX + 20 * zoom;
    const rwY = bY + 6 * zoom;
    drawIsometricPrism(
      ctx,
      rwX,
      rwY,
      14,
      12,
      24,
      { top: "#6a5a4a", left: "#5a4a3a", right: "#4a3a2a" },
      zoom
    );
    drawSlopedRoof(
      rwX,
      rwY - 24 * zoom,
      18,
      15,
      12,
      "#4a4a52",
      "#3a3a42",
      "#5a5a62"
    );
    ctx.fillStyle = "#3a2a1a";
    ctx.fillRect(rwX - 2 * zoom, rwY - 16 * zoom, 8 * zoom, 16 * zoom);
    // White horse
    ctx.fillStyle = "#b0b0b0";
    ctx.beginPath();
    ctx.ellipse(
      rwX + 2 * zoom,
      rwY - 11 * zoom,
      3.5 * zoom,
      2.8 * zoom,
      0.3,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.fillStyle = "#e07000";
    ctx.beginPath();
    ctx.arc(rwX + 4 * zoom, rwY - 11.5 * zoom, 0.8 * zoom, 0, Math.PI * 2);
    ctx.fill();
    // Orange pennant
    ctx.fillStyle = "#e06000";
    ctx.beginPath();
    ctx.moveTo(rwX - 2 * zoom, rwY - 34 * zoom);
    ctx.lineTo(rwX - 2 * zoom, rwY - 44 * zoom);
    ctx.quadraticCurveTo(
      rwX + 4 * zoom + lwFlagWave,
      rwY - 42 * zoom,
      rwX + 6 * zoom + lwFlagWave,
      rwY - 40 * zoom
    );
    ctx.lineTo(rwX - 2 * zoom, rwY - 38 * zoom);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#b89227";
    ctx.fillRect(rwX - 3 * zoom, rwY - 46 * zoom, 2 * zoom, 14 * zoom);

    // Heavy machinery - gear cluster (bronze, not gold)
    const fGearX = bX + 14 * zoom;
    const fGearY = bY + 9 * zoom;
    ctx.fillStyle = "#a88217";
    ctx.beginPath();
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2 + time * 0.15;
      const r = i % 2 === 0 ? 5 * zoom : 4 * zoom;
      const gx = fGearX + Math.cos(angle) * r;
      const gy = fGearY + Math.sin(angle) * r * 0.5;
      if (i === 0) ctx.moveTo(gx, gy);
      else ctx.lineTo(gx, gy);
    }
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#5a4a3a";
    ctx.beginPath();
    ctx.ellipse(fGearX, fGearY, 2 * zoom, 1 * zoom, 0, 0, Math.PI * 2);
    ctx.fill();

    // Steam pipes on foundation
    ctx.strokeStyle = "#6a6a72";
    ctx.lineWidth = 4 * zoom;
    ctx.beginPath();
    ctx.moveTo(bX - 24 * zoom, bY + 10 * zoom);
    ctx.lineTo(bX - 24 * zoom, bY - 8 * zoom);
    ctx.quadraticCurveTo(
      bX - 24 * zoom,
      bY - 16 * zoom,
      bX - 16 * zoom,
      bY - 16 * zoom
    );
    ctx.stroke();
    // Bronze pipe joints
    ctx.fillStyle = "#b89227";
    ctx.beginPath();
    ctx.arc(bX - 24 * zoom, bY + 10 * zoom, 3 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(bX - 24 * zoom, bY - 8 * zoom, 3 * zoom, 0, Math.PI * 2);
    ctx.fill();

    // Steam exhaust with orange glow
    ctx.fillStyle = "#4a4a52";
    ctx.beginPath();
    ctx.ellipse(
      bX - 16 * zoom,
      bY + 12 * zoom,
      4 * zoom,
      2 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
    const fireGlow = 0.5 + Math.sin(time * 6) * 0.25;
    ctx.fillStyle = `rgba(224, 96, 0, ${fireGlow})`;
    ctx.beginPath();
    ctx.ellipse(
      bX - 16 * zoom,
      bY + 12 * zoom,
      2.5 * zoom,
      1.2 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
    // Steam
    const fSteam = 0.4 + Math.sin(time * 3) * 0.2;
    ctx.fillStyle = `rgba(200, 200, 200, ${fSteam})`;
    ctx.beginPath();
    ctx.arc(
      bX - 16 * zoom + Math.sin(time * 2) * 2,
      bY + 4 * zoom,
      5 * zoom,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // === MAIN FORTRESS ===
    drawIsometricPrism(
      ctx,
      bX,
      bY,
      34,
      28,
      38,
      { top: "#6a6a72", left: "#5a5a62", right: "#4a4a52" },
      zoom
    );

    // Orange trim bands on walls
    ctx.strokeStyle = "#e06000";
    ctx.lineWidth = 2.5 * zoom;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(bX - 15 * zoom, bY - 10 * zoom - i * 10 * zoom);
      ctx.lineTo(bX + 2 * zoom, bY - 7 * zoom - i * 10 * zoom);
      ctx.stroke();
    }

    // Decorative crossed spears emblem on wall
    ctx.strokeStyle = "#a88217";
    ctx.lineWidth = 2.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(bX - 10 * zoom, bY - 18 * zoom);
    ctx.lineTo(bX - 4 * zoom, bY - 30 * zoom);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(bX + 2 * zoom, bY - 18 * zoom);
    ctx.lineTo(bX - 4 * zoom, bY - 30 * zoom);
    ctx.stroke();
    // Shield behind spears
    ctx.fillStyle = "#e06000";
    ctx.beginPath();
    ctx.moveTo(bX - 4 * zoom, bY - 28 * zoom);
    ctx.lineTo(bX - 8 * zoom, bY - 22 * zoom);
    ctx.lineTo(bX - 4 * zoom, bY - 16 * zoom);
    ctx.lineTo(bX, bY - 22 * zoom);
    ctx.closePath();
    ctx.fill();

    // Battlements with bronze caps
    const keepTop = bY - 38 * zoom;
    for (let i = 0; i < 6; i++) {
      if (i % 2 === 0) {
        drawIsometricPrism(
          ctx,
          bX - 14 * zoom + i * 6 * zoom,
          keepTop,
          5,
          4,
          6,
          { top: "#b89227", left: "#6a6a72", right: "#5a5a62" },
          zoom
        );
      }
    }

    // Left watchtower
    const ltX = bX - 18 * zoom;
    const ltY = bY + 4 * zoom;
    drawIsometricPrism(
      ctx,
      ltX,
      ltY,
      12,
      10,
      48,
      { top: "#6a6a72", left: "#5a5a62", right: "#4a4a52" },
      zoom
    );
    // Tower orange bands
    ctx.strokeStyle = "#e06000";
    ctx.lineWidth = 2 * zoom;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(ltX - 5 * zoom, ltY - 12 * zoom - i * 12 * zoom);
      ctx.lineTo(ltX + 5 * zoom, ltY - 10 * zoom - i * 12 * zoom);
      ctx.stroke();
    }
    // Conical roof
    const ltRoofY = ltY - 48 * zoom;
    ctx.fillStyle = "#4a4a52";
    ctx.beginPath();
    ctx.moveTo(ltX, ltRoofY - 14 * zoom);
    ctx.lineTo(ltX - 7 * zoom, ltRoofY);
    ctx.lineTo(ltX, ltRoofY + 3 * zoom);
    ctx.lineTo(ltX + 7 * zoom, ltRoofY);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#3a3a42";
    ctx.beginPath();
    ctx.moveTo(ltX, ltRoofY - 14 * zoom);
    ctx.lineTo(ltX + 7 * zoom, ltRoofY);
    ctx.lineTo(ltX, ltRoofY + 3 * zoom);
    ctx.closePath();
    ctx.fill();
    // Bronze spike finial
    ctx.fillStyle = "#b89227";
    ctx.beginPath();
    ctx.moveTo(ltX, ltRoofY - 22 * zoom);
    ctx.lineTo(ltX - 2 * zoom, ltRoofY - 14 * zoom);
    ctx.lineTo(ltX + 2 * zoom, ltRoofY - 14 * zoom);
    ctx.closePath();
    ctx.fill();
    // Orange royal banner
    const flagWave = Math.sin(time * 4) * 2;
    ctx.fillStyle = "#e06000";
    ctx.beginPath();
    ctx.moveTo(ltX, ltRoofY - 24 * zoom);
    ctx.lineTo(ltX, ltRoofY - 38 * zoom);
    ctx.quadraticCurveTo(
      ltX + 10 * zoom + flagWave,
      ltRoofY - 36 * zoom,
      ltX + 12 * zoom + flagWave,
      ltRoofY - 33 * zoom
    );
    ctx.lineTo(ltX, ltRoofY - 30 * zoom);
    ctx.closePath();
    ctx.fill();

    // Right armory tower (taller)
    const rtX = bX + 18 * zoom;
    const rtY = bY + 4 * zoom;
    drawIsometricPrism(
      ctx,
      rtX,
      rtY,
      14,
      12,
      54,
      { top: "#6a6a72", left: "#5a5a62", right: "#4a4a52" },
      zoom
    );
    // Tower machinery - bronze gears
    const tGearX = rtX - 4 * zoom;
    const tGearY = rtY - 22 * zoom;
    ctx.fillStyle = "#a88217";
    ctx.beginPath();
    for (let i = 0; i < 10; i++) {
      const angle = (i / 10) * Math.PI * 2 + time * 0.4;
      const r = i % 2 === 0 ? 5 * zoom : 3.8 * zoom;
      const gx = tGearX + Math.cos(angle) * r;
      const gy = tGearY + Math.sin(angle) * r * 0.5;
      if (i === 0) ctx.moveTo(gx, gy);
      else ctx.lineTo(gx, gy);
    }
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#5a4a3a";
    ctx.beginPath();
    ctx.ellipse(tGearX, tGearY, 2 * zoom, 1 * zoom, 0, 0, Math.PI * 2);
    ctx.fill();

    // Tower spire
    const rtRoofY = rtY - 54 * zoom;
    ctx.fillStyle = "#4a4a52";
    ctx.beginPath();
    ctx.moveTo(rtX, rtRoofY - 18 * zoom);
    ctx.lineTo(rtX - 8 * zoom, rtRoofY);
    ctx.lineTo(rtX, rtRoofY + 4 * zoom);
    ctx.lineTo(rtX + 8 * zoom, rtRoofY);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#3a3a42";
    ctx.beginPath();
    ctx.moveTo(rtX, rtRoofY - 18 * zoom);
    ctx.lineTo(rtX + 8 * zoom, rtRoofY);
    ctx.lineTo(rtX, rtRoofY + 4 * zoom);
    ctx.closePath();
    ctx.fill();
    // Bronze finial
    ctx.fillStyle = "#b89227";
    ctx.fillRect(rtX - 1.5 * zoom, rtRoofY - 26 * zoom, 3 * zoom, 10 * zoom);
    ctx.fillRect(rtX - 4 * zoom, rtRoofY - 23 * zoom, 8 * zoom, 3 * zoom);

    // Glowing forge window (orange)
    const forgeGlow = 0.5 + Math.sin(time * 3) * 0.2;
    ctx.fillStyle = `rgba(224, 120, 0, ${forgeGlow})`;
    ctx.beginPath();
    ctx.arc(rtX - 3 * zoom, rtY - 38 * zoom, 5 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#5a5a62";
    ctx.lineWidth = 2 * zoom;
    ctx.stroke();

    // Main entrance
    ctx.fillStyle = "#2a2a2a";
    ctx.beginPath();
    ctx.moveTo(bX - 7 * zoom, bY - 2 * zoom);
    ctx.lineTo(bX - 7 * zoom, bY - 20 * zoom);
    ctx.arc(bX - 2 * zoom, bY - 20 * zoom, 5 * zoom, Math.PI, 0);
    ctx.lineTo(bX + 3 * zoom, bY - 2 * zoom);
    ctx.closePath();
    ctx.fill();
    // Bronze arch
    ctx.strokeStyle = "#b89227";
    ctx.lineWidth = 3 * zoom;
    ctx.beginPath();
    ctx.arc(bX - 2 * zoom, bY - 20 * zoom, 5.5 * zoom, Math.PI, 0);
    ctx.stroke();
    // Interior orange glow
    const intGlow = 0.4 + Math.sin(time * 2) * 0.15;
    ctx.fillStyle = `rgba(224, 120, 0, ${intGlow})`;
    ctx.beginPath();
    ctx.ellipse(
      bX - 2 * zoom,
      bY - 10 * zoom,
      4 * zoom,
      8 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Sign - bronze plate
    ctx.fillStyle = "#4a4a52";
    ctx.fillRect(bX - 14 * zoom, bY + 12 * zoom, 28 * zoom, 10 * zoom);
    ctx.strokeStyle = "#b89227";
    ctx.lineWidth = 2 * zoom;
    ctx.strokeRect(bX - 14 * zoom, bY + 12 * zoom, 28 * zoom, 10 * zoom);
    ctx.fillStyle = "#e06000";
    ctx.font = `bold ${4 * zoom}px serif`;
    ctx.textAlign = "center";
    ctx.fillText("CAVALRY", bX, bY + 19 * zoom);
  }

  // ========== STATION DETAILS (Gears, Steam, Signs) ==========

  // Animated gear decoration (on platform edge)
  const gearX = screenPos.x + 20 * zoom;
  const gearY = screenPos.y + 2 * zoom;
  const gearSize = 4 + tower.level * 0.5;
  const gearColor =
    tower.level >= 4 ? "#c9a227" : tower.level >= 3 ? "#8a8a92" : "#6a5a4a";
  const gearTeeth = 8 + tower.level;

  // Main gear
  ctx.fillStyle = gearColor;
  ctx.beginPath();
  for (let i = 0; i < gearTeeth; i++) {
    const angle = (i / gearTeeth) * Math.PI * 2 + time * 0.5;
    const outerR = gearSize * zoom;
    const innerR = gearSize * 0.7 * zoom;
    const toothAngle = (0.5 / gearTeeth) * Math.PI * 2;

    if (i === 0) {
      ctx.moveTo(
        gearX + Math.cos(angle) * outerR,
        gearY + Math.sin(angle) * outerR * 0.5
      );
    }
    ctx.lineTo(
      gearX + Math.cos(angle + toothAngle * 0.3) * outerR,
      gearY + Math.sin(angle + toothAngle * 0.3) * outerR * 0.5
    );
    ctx.lineTo(
      gearX + Math.cos(angle + toothAngle * 0.7) * innerR,
      gearY + Math.sin(angle + toothAngle * 0.7) * innerR * 0.5
    );
    ctx.lineTo(
      gearX + Math.cos(angle + toothAngle) * innerR,
      gearY + Math.sin(angle + toothAngle) * innerR * 0.5
    );
  }
  ctx.closePath();
  ctx.fill();
  // Gear center
  ctx.fillStyle = tower.level >= 4 ? "#b8860b" : "#4a4a4a";
  ctx.beginPath();
  ctx.ellipse(
    gearX,
    gearY,
    gearSize * 0.3 * zoom,
    gearSize * 0.15 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Small secondary gear
  const gear2X = gearX - 6 * zoom;
  const gear2Y = gearY + 3 * zoom;
  const gear2Size = gearSize * 0.6;
  ctx.fillStyle = gearColor;
  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2 - time * 0.8;
    const outerR = gear2Size * zoom;
    const innerR = gear2Size * 0.65 * zoom;
    const toothAngle = (0.5 / 6) * Math.PI * 2;

    if (i === 0) {
      ctx.moveTo(
        gear2X + Math.cos(angle) * outerR,
        gear2Y + Math.sin(angle) * outerR * 0.5
      );
    }
    ctx.lineTo(
      gear2X + Math.cos(angle + toothAngle * 0.3) * outerR,
      gear2Y + Math.sin(angle + toothAngle * 0.3) * outerR * 0.5
    );
    ctx.lineTo(
      gear2X + Math.cos(angle + toothAngle * 0.7) * innerR,
      gear2Y + Math.sin(angle + toothAngle * 0.7) * innerR * 0.5
    );
    ctx.lineTo(
      gear2X + Math.cos(angle + toothAngle) * innerR,
      gear2Y + Math.sin(angle + toothAngle) * innerR * 0.5
    );
  }
  ctx.closePath();
  ctx.fill();

  // Steam vents (puffing steam)
  const ventX = screenPos.x - 28 * zoom;
  const ventY = screenPos.y - 5 * zoom;

  // Vent pipe
  ctx.fillStyle = tower.level >= 3 ? "#5a5a62" : "#6b5030";
  ctx.beginPath();
  ctx.ellipse(ventX, ventY + 2 * zoom, 2 * zoom, 1 * zoom, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillRect(ventX - 1.5 * zoom, ventY, 3 * zoom, 3 * zoom);

  // Steam puffs
  const steamPhase = (time * 2) % 3;
  const steamAlpha =
    steamPhase < 1 ? steamPhase : steamPhase < 2 ? 1 : 3 - steamPhase;
  if (steamAlpha > 0.1) {
    ctx.fillStyle = `rgba(200, 200, 200, ${steamAlpha * 0.4})`;
    ctx.beginPath();
    ctx.arc(
      ventX + Math.sin(time * 2) * 2,
      ventY - 4 * zoom - steamPhase * 3 * zoom,
      (2 + steamPhase) * zoom,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.fillStyle = `rgba(180, 180, 180, ${steamAlpha * 0.25})`;
    ctx.beginPath();
    ctx.arc(
      ventX + Math.sin(time * 2 + 1) * 3,
      ventY - 8 * zoom - steamPhase * 4 * zoom,
      (1.5 + steamPhase * 0.8) * zoom,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  // Pressure gauge (on station wall)
  const gaugeX = screenPos.x - 22 * zoom;
  const gaugeY = screenPos.y - 20 * zoom;

  // Gauge body
  ctx.fillStyle = tower.level >= 4 ? "#b8860b" : "#8b7355";
  ctx.beginPath();
  ctx.arc(gaugeX, gaugeY, 4 * zoom, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#f0f0e8";
  ctx.beginPath();
  ctx.arc(gaugeX, gaugeY, 3 * zoom, 0, Math.PI * 2);
  ctx.fill();

  // Gauge markings
  ctx.strokeStyle = "#3a3a3a";
  ctx.lineWidth = 0.5 * zoom;
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI + Math.PI;
    ctx.beginPath();
    ctx.moveTo(
      gaugeX + Math.cos(angle) * 2.2 * zoom,
      gaugeY + Math.sin(angle) * 2.2 * zoom
    );
    ctx.lineTo(
      gaugeX + Math.cos(angle) * 2.8 * zoom,
      gaugeY + Math.sin(angle) * 2.8 * zoom
    );
    ctx.stroke();
  }

  // Gauge needle (animated)
  const needleAngle =
    Math.PI + Math.PI * 0.2 + Math.sin(time * 2) * 0.3 + Math.PI * 0.5;
  ctx.strokeStyle = "#cc0000";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(gaugeX, gaugeY);
  ctx.lineTo(
    gaugeX + Math.cos(needleAngle) * 2.5 * zoom,
    gaugeY + Math.sin(needleAngle) * 2.5 * zoom
  );
  ctx.stroke();

  // Gauge center cap
  ctx.fillStyle = "#3a3a3a";
  ctx.beginPath();
  ctx.arc(gaugeX, gaugeY, 0.8 * zoom, 0, Math.PI * 2);
  ctx.fill();

  // "ON TIME" sign board
  const signX = screenPos.x + 27 * zoom;
  const signY = screenPos.y - 12 * zoom;

  // Sign post
  ctx.fillStyle = tower.level >= 4 ? "#c9a227" : "#5a4a3a";
  ctx.fillRect(signX - 1 * zoom, signY, 2 * zoom, 18 * zoom);

  // Sign board
  ctx.fillStyle = tower.level >= 4 ? "#2a2a32" : "#3a3a3a";
  ctx.fillRect(signX - 8 * zoom, signY - 8 * zoom, 16 * zoom, 8 * zoom);
  ctx.strokeStyle = tower.level >= 4 ? "#c9a227" : "#e06000";
  ctx.lineWidth = 1 * zoom;
  ctx.strokeRect(signX - 8 * zoom, signY - 8 * zoom, 16 * zoom, 8 * zoom);

  // "ON TIME" text with glow
  const onTimeGlow = 0.7 + Math.sin(time * 3) * 0.3;
  ctx.fillStyle = `rgba(0, 255, 100, ${onTimeGlow})`;
  ctx.shadowColor = "#00ff64";
  ctx.shadowBlur = 4 * zoom;
  ctx.font = `bold ${3.5 * zoom}px monospace`;
  ctx.textAlign = "center";
  ctx.fillText("ON TIME", signX, signY - 3 * zoom);
  ctx.shadowBlur = 0;

  // Small indicator lights on sign
  for (let i = 0; i < 3; i++) {
    const lightX = signX - 5 * zoom + i * 5 * zoom;
    const lightY = signY - 1 * zoom;
    const lightOn = Math.sin(time * 4 + i * 0.5) > 0;
    ctx.fillStyle = lightOn ? "#00ff64" : "#1a3a1a";
    ctx.beginPath();
    ctx.arc(lightX, lightY, 1 * zoom, 0, Math.PI * 2);
    ctx.fill();
  }

  // Level-specific station extras
  if (tower.level >= 2) {
    // Extra pipes
    ctx.strokeStyle = tower.level >= 4 ? "#b8860b" : "#6a6a72";
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.moveTo(screenPos.x - 25 * zoom, screenPos.y);
    ctx.quadraticCurveTo(
      screenPos.x - 30 * zoom,
      screenPos.y - 10 * zoom,
      screenPos.x - 28 * zoom,
      screenPos.y - 5 * zoom
    );
    ctx.stroke();
  }

  if (tower.level >= 3) {
    // Extra gear cluster
    const clusterX = screenPos.x - 30 * zoom;
    const clusterY = screenPos.y + 8 * zoom;
    ctx.fillStyle = "#5a5a62";
    ctx.beginPath();
    ctx.arc(clusterX, clusterY, 2.5 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#4a4a52";
    ctx.beginPath();
    ctx.arc(
      clusterX + 3 * zoom,
      clusterY + 1.5 * zoom,
      1.8 * zoom,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  if (tower.level === 4) {
    // Royal crest on station
    const crestX = screenPos.x - 5 * zoom;
    const crestY = screenPos.y - 35 * zoom;
    ctx.fillStyle = "#c9a227";
    ctx.shadowColor = "#c9a227";
    ctx.shadowBlur = 6 * zoom;
    ctx.beginPath();
    ctx.moveTo(crestX, crestY - 5 * zoom);
    ctx.lineTo(crestX - 4 * zoom, crestY);
    ctx.lineTo(crestX - 3 * zoom, crestY + 2 * zoom);
    ctx.lineTo(crestX, crestY + 5 * zoom);
    ctx.lineTo(crestX + 3 * zoom, crestY + 2 * zoom);
    ctx.lineTo(crestX + 4 * zoom, crestY);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;
    // Crown on crest
    ctx.fillStyle = "#e06000";
    ctx.beginPath();
    ctx.moveTo(crestX - 2 * zoom, crestY - 1 * zoom);
    ctx.lineTo(crestX - 1 * zoom, crestY - 3 * zoom);
    ctx.lineTo(crestX, crestY - 1.5 * zoom);
    ctx.lineTo(crestX + 1 * zoom, crestY - 3 * zoom);
    ctx.lineTo(crestX + 2 * zoom, crestY - 1 * zoom);
    ctx.closePath();
    ctx.fill();
  }

  // ========== DETAILED ISOMETRIC TRAINS ==========
  // CORRECT LAYERING: Draw cab FIRST (bottom-right), then boiler, then tender LAST (top-left)
  // This makes tender appear "in front" visually
  const trainAnimProgress = tower.trainAnimProgress || 0;
  const trainVisible = trainAnimProgress > 0 && trainAnimProgress < 1;

  if (trainVisible) {
    let trainT = 0;
    let trainAlpha = 1;

    if (trainAnimProgress < 0.25) {
      trainT = 0.45 - (trainAnimProgress / 0.25) * 0.45;
      trainAlpha = Math.min(1, trainAnimProgress / 0.15);
    } else if (trainAnimProgress < 0.75) {
      trainT = 0;
      trainAlpha = 1;
    } else {
      trainT = -((trainAnimProgress - 0.75) / 0.25) * 0.45;
      trainAlpha = Math.max(0, 1 - (trainAnimProgress - 0.75) / 0.2);
    }

    const trackLen = baseW * 0.9 * zoom;
    const trainX = screenPos.x + trackLen * trainT;
    const trainY = screenPos.y - trackLen * trainT * 0.5 - 6 * zoom;

    ctx.save();
    ctx.globalAlpha = trainAlpha;

    // Isometric offset - positive = toward bottom-right (front), negative = toward top-left (back)
    const isoOffset = (baseX: number, baseY: number, offset: number) => ({
      x: baseX + offset * zoom,
      y: baseY - offset * zoom * 0.5,
    });

    // Shadow
    ctx.fillStyle = "rgba(0,0,0,0.2)";
    ctx.beginPath();
    ctx.ellipse(
      trainX,
      trainY + 10 * zoom,
      18 * zoom,
      8 * zoom,
      -0.46,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Improved wheel helper - more realistic train wheel
    const drawWheel = (
      wx: number,
      wy: number,
      r: number,
      mainColor: string,
      rimColor: string
    ) => {
      // Wheel outer rim
      ctx.fillStyle = mainColor;
      ctx.strokeStyle = rimColor;
      ctx.lineWidth = 1.5 * zoom;
      ctx.beginPath();
      ctx.ellipse(wx, wy, r * zoom, r * zoom * 0.5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Inner wheel face
      ctx.fillStyle = rimColor;
      ctx.beginPath();
      ctx.ellipse(wx, wy, r * zoom * 0.7, r * zoom * 0.35, 0, 0, Math.PI * 2);
      ctx.fill();

      // Spokes
      ctx.strokeStyle = mainColor;
      ctx.lineWidth = 1 * zoom;
      const spokeCount = 5;
      for (let i = 0; i < spokeCount; i++) {
        const angle = (i / spokeCount) * Math.PI * 2 + time * 3;
        ctx.beginPath();
        ctx.moveTo(wx, wy);
        ctx.lineTo(
          wx + Math.cos(angle) * r * zoom * 0.6,
          wy + Math.sin(angle) * r * zoom * 0.3
        );
        ctx.stroke();
      }

      // Center hub
      ctx.fillStyle = "#1a1a1a";
      ctx.beginPath();
      ctx.ellipse(wx, wy, r * zoom * 0.2, r * zoom * 0.1, 0, 0, Math.PI * 2);
      ctx.fill();
    };

    if (tower.level === 1) {
      // ========== LEVEL 1: Wooden Steam Train ==========
      const cabPos = isoOffset(trainX, trainY, 6); // Front (draw first)
      const boilerPos = isoOffset(trainX, trainY, 0); // Middle
      const tenderPos = isoOffset(trainX, trainY, -6); // Back (draw last, appears in front)

      // Wheels - positioned under each car
      const wheelY = trainY + 4 * zoom;
      // Front wheels (under cab)
      drawWheel(
        isoOffset(trainX, wheelY, 8).x,
        isoOffset(trainX, wheelY, 8).y,
        3.5,
        "#5a4a3a",
        "#3a2a1a"
      );
      drawWheel(
        isoOffset(trainX, wheelY, 4).x,
        isoOffset(trainX, wheelY, 4).y,
        3.5,
        "#5a4a3a",
        "#3a2a1a"
      );
      // Rear wheels (under tender)
      drawWheel(
        isoOffset(trainX, wheelY, -3).x,
        isoOffset(trainX, wheelY, -3).y,
        3.5,
        "#5a4a3a",
        "#3a2a1a"
      );
      drawWheel(
        isoOffset(trainX, wheelY, -8).x,
        isoOffset(trainX, wheelY, -8).y,
        3.5,
        "#5a4a3a",
        "#3a2a1a"
      );

      // === CAB (front, draw first) ===
      drawIsometricPrism(
        ctx,
        cabPos.x,
        cabPos.y,
        10,
        9,
        14,
        { top: "#6b5030", left: "#5a4020", right: "#4a3010" },
        zoom
      );
      // Cab roof
      drawIsometricPrism(
        ctx,
        cabPos.x,
        cabPos.y - 14 * zoom,
        12,
        11,
        2,
        { top: "#5a4020", left: "#4a3010", right: "#3a2000" },
        zoom
      );
      // Cab window
      ctx.fillStyle = "#2a1a0a";
      ctx.fillRect(
        cabPos.x + 2 * zoom,
        cabPos.y - 11 * zoom,
        4 * zoom,
        5 * zoom
      );
      const cabGlow = 0.5 + Math.sin(time * 2) * 0.2;
      ctx.fillStyle = `rgba(255, 200, 100, ${cabGlow})`;
      ctx.fillRect(
        cabPos.x + 2.5 * zoom,
        cabPos.y - 10.5 * zoom,
        3 * zoom,
        4 * zoom
      );
      // Side window
      const sideWin = isoOffset(cabPos.x, cabPos.y - 9 * zoom, -3);
      ctx.fillStyle = "#2a1a0a";
      ctx.beginPath();
      ctx.arc(sideWin.x, sideWin.y, 2 * zoom, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = `rgba(255, 200, 100, ${cabGlow * 0.7})`;
      ctx.beginPath();
      ctx.arc(sideWin.x, sideWin.y, 1.5 * zoom, 0, Math.PI * 2);
      ctx.fill();

      // === BOILER (middle) ===
      drawIsometricPrism(
        ctx,
        boilerPos.x,
        boilerPos.y,
        10,
        9,
        10,
        { top: "#6b5535", left: "#5a4525", right: "#4a3515" },
        zoom
      );
      // Boiler cylinder top
      ctx.fillStyle = "#5a4525";
      ctx.beginPath();
      ctx.ellipse(
        boilerPos.x,
        boilerPos.y - 8 * zoom,
        4 * zoom,
        2.5 * zoom,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();
      // Boiler bands
      ctx.strokeStyle = "#8b7355";
      ctx.lineWidth = 1.5 * zoom;
      for (let i = 0; i < 2; i++) {
        const bandY = boilerPos.y - 4 * zoom - i * 4 * zoom;
        ctx.beginPath();
        ctx.moveTo(boilerPos.x - 4 * zoom, bandY + 2 * zoom);
        ctx.lineTo(boilerPos.x + 4 * zoom, bandY - 2 * zoom);
        ctx.stroke();
      }
      // Dome
      ctx.fillStyle = "#7a6545";
      ctx.beginPath();
      ctx.arc(boilerPos.x, boilerPos.y - 12 * zoom, 3 * zoom, Math.PI, 0);
      ctx.fill();
      ctx.fillStyle = "#6a5535";
      ctx.beginPath();
      ctx.ellipse(
        boilerPos.x,
        boilerPos.y - 12 * zoom,
        3 * zoom,
        1.5 * zoom,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();
      // Smokestack
      const stackPos = isoOffset(boilerPos.x, boilerPos.y - 10 * zoom, 3);
      ctx.fillStyle = "#3a2a1a";
      ctx.beginPath();
      ctx.moveTo(stackPos.x - 2.5 * zoom, stackPos.y);
      ctx.lineTo(stackPos.x - 3 * zoom, stackPos.y - 10 * zoom);
      ctx.lineTo(stackPos.x + 3 * zoom, stackPos.y - 10 * zoom);
      ctx.lineTo(stackPos.x + 2.5 * zoom, stackPos.y);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "#4a3a2a";
      ctx.beginPath();
      ctx.ellipse(
        stackPos.x,
        stackPos.y - 10 * zoom,
        3.5 * zoom,
        1.8 * zoom,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();
      // Steam
      const steam = 0.4 + Math.sin(time * 4) * 0.2;
      ctx.fillStyle = `rgba(220, 220, 220, ${steam})`;
      ctx.beginPath();
      ctx.arc(
        stackPos.x + Math.sin(time * 3) * 3,
        stackPos.y - 16 * zoom,
        5 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();
      // Headlight
      const lightPos = isoOffset(boilerPos.x, boilerPos.y - 5 * zoom, 5);
      ctx.fillStyle = "#8b7355";
      ctx.beginPath();
      ctx.arc(lightPos.x, lightPos.y, 2.5 * zoom, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = `rgba(255, 250, 200, ${0.6 + Math.sin(time * 3) * 0.2})`;
      ctx.shadowColor = "#fffacc";
      ctx.shadowBlur = 8 * zoom;
      ctx.beginPath();
      ctx.arc(lightPos.x, lightPos.y, 1.8 * zoom, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      // Bell
      const bellPos = isoOffset(boilerPos.x, boilerPos.y - 14 * zoom, 0);
      ctx.fillStyle = "#c9a227";
      ctx.beginPath();
      ctx.arc(bellPos.x, bellPos.y, 2 * zoom, 0, Math.PI);
      ctx.fill();

      // === TENDER (back, draw last - appears in front) ===
      drawIsometricPrism(
        ctx,
        tenderPos.x,
        tenderPos.y,
        10,
        9,
        8,
        { top: "#7a6040", left: "#5a4020", right: "#4a3010" },
        zoom
      );
      // Coal pile
      ctx.fillStyle = "#1a1008";
      ctx.beginPath();
      ctx.ellipse(
        tenderPos.x,
        tenderPos.y - 8 * zoom,
        4 * zoom,
        2.5 * zoom,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();
      // Coal lumps
      ctx.fillStyle = "#2a2010";
      for (let i = 0; i < 6; i++) {
        const cx = tenderPos.x + Math.sin(i * 1.5) * 3 * zoom;
        const cy = tenderPos.y - 8.5 * zoom + Math.cos(i * 2) * 1 * zoom;
        ctx.beginPath();
        ctx.arc(cx, cy, 1.5 * zoom, 0, Math.PI * 2);
        ctx.fill();
      }
      // Tender sides
      ctx.strokeStyle = "#4a3010";
      ctx.lineWidth = 1.5 * zoom;
      ctx.strokeRect(
        tenderPos.x - 4 * zoom,
        tenderPos.y - 8 * zoom,
        8 * zoom,
        1 * zoom
      );

      // === ORANGE STRIPE (runs along whole train) ===
      ctx.strokeStyle = "#e06000";
      ctx.lineWidth = 2.5 * zoom;
      const stripeY = trainY - 2 * zoom;
      ctx.beginPath();
      ctx.moveTo(
        isoOffset(trainX, stripeY, -10).x,
        isoOffset(trainX, stripeY, -10).y
      );
      ctx.lineTo(
        isoOffset(trainX, stripeY, 10).x,
        isoOffset(trainX, stripeY, 10).y
      );
      ctx.stroke();

      // Cowcatcher at very front
      const cowPos = isoOffset(cabPos.x, cabPos.y, 6);
      ctx.fillStyle = "#4a3a2a";
      ctx.beginPath();
      ctx.moveTo(cowPos.x, cowPos.y + 4 * zoom);
      ctx.lineTo(cowPos.x - 4 * zoom, cowPos.y);
      ctx.lineTo(cowPos.x + 4 * zoom, cowPos.y - 2 * zoom);
      ctx.closePath();
      ctx.fill();
    } else if (tower.level === 2) {
      // ========== LEVEL 2: Armored Military Train ==========
      const cabPos = isoOffset(trainX, trainY, 7);
      const locoPos = isoOffset(trainX, trainY, 0);
      const cargoPos = isoOffset(trainX, trainY, -7);

      // Wheels
      const wheelY = trainY + 4 * zoom;
      drawWheel(
        isoOffset(trainX, wheelY, 10).x,
        isoOffset(trainX, wheelY, 10).y,
        4,
        "#5a5a62",
        "#3a3a42"
      );
      drawWheel(
        isoOffset(trainX, wheelY, 4).x,
        isoOffset(trainX, wheelY, 4).y,
        4,
        "#5a5a62",
        "#3a3a42"
      );
      drawWheel(
        isoOffset(trainX, wheelY, -3).x,
        isoOffset(trainX, wheelY, -3).y,
        4,
        "#5a5a62",
        "#3a3a42"
      );
      drawWheel(
        isoOffset(trainX, wheelY, -10).x,
        isoOffset(trainX, wheelY, -10).y,
        4,
        "#5a5a62",
        "#3a3a42"
      );

      // === CAB (front, first) ===
      drawIsometricPrism(
        ctx,
        cabPos.x,
        cabPos.y,
        11,
        10,
        14,
        { top: "#5a5a62", left: "#4a4a52", right: "#3a3a42" },
        zoom
      );
      drawIsometricPrism(
        ctx,
        cabPos.x,
        cabPos.y - 14 * zoom,
        13,
        12,
        2,
        { top: "#4a4a52", left: "#3a3a42", right: "#2a2a32" },
        zoom
      );
      // Vision slit
      ctx.fillStyle = "#2a2a32";
      ctx.fillRect(
        cabPos.x + 2 * zoom,
        cabPos.y - 11 * zoom,
        5 * zoom,
        2 * zoom
      );
      // Periscope
      drawIsometricPrism(
        ctx,
        isoOffset(cabPos.x, cabPos.y - 16 * zoom, 2).x,
        isoOffset(cabPos.x, cabPos.y - 16 * zoom, 2).y,
        3,
        3,
        6,
        { top: "#4a4a52", left: "#3a3a42", right: "#2a2a32" },
        zoom
      );
      // Front armor
      const frontArmor = isoOffset(cabPos.x, cabPos.y, 7);
      ctx.fillStyle = "#4a4a52";
      ctx.beginPath();
      ctx.moveTo(frontArmor.x - 5 * zoom, frontArmor.y - 6 * zoom);
      ctx.lineTo(frontArmor.x + 5 * zoom, frontArmor.y - 11 * zoom);
      ctx.lineTo(frontArmor.x + 5 * zoom, frontArmor.y - 2 * zoom);
      ctx.lineTo(frontArmor.x - 5 * zoom, frontArmor.y + 3 * zoom);
      ctx.closePath();
      ctx.fill();

      // === LOCOMOTIVE (middle) ===
      drawIsometricPrism(
        ctx,
        locoPos.x,
        locoPos.y,
        12,
        10,
        12,
        { top: "#5a5a62", left: "#4a4a52", right: "#3a3a42" },
        zoom
      );
      // Armored boiler
      ctx.fillStyle = "#4a4a52";
      ctx.beginPath();
      ctx.ellipse(
        locoPos.x,
        locoPos.y - 10 * zoom,
        4.5 * zoom,
        2.8 * zoom,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();
      // Smokestack with cap
      const stackPos = isoOffset(locoPos.x, locoPos.y - 12 * zoom, 0);
      ctx.fillStyle = "#3a3a42";
      ctx.beginPath();
      ctx.moveTo(stackPos.x - 2.5 * zoom, stackPos.y);
      ctx.lineTo(stackPos.x - 2 * zoom, stackPos.y - 8 * zoom);
      ctx.lineTo(stackPos.x + 2 * zoom, stackPos.y - 8 * zoom);
      ctx.lineTo(stackPos.x + 2.5 * zoom, stackPos.y);
      ctx.closePath();
      ctx.fill();
      drawIsometricPrism(
        ctx,
        stackPos.x,
        stackPos.y - 8 * zoom,
        6,
        5,
        2,
        { top: "#4a4a52", left: "#3a3a42", right: "#2a2a32" },
        zoom
      );
      // Steam
      const steam = 0.35 + Math.sin(time * 4) * 0.15;
      ctx.fillStyle = `rgba(180, 180, 180, ${steam})`;
      ctx.beginPath();
      ctx.arc(
        stackPos.x + Math.sin(time * 3) * 3,
        stackPos.y - 14 * zoom,
        5 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();
      // Headlight
      const lightPos = isoOffset(locoPos.x, locoPos.y - 7 * zoom, 6);
      ctx.fillStyle = "#5a5a62";
      ctx.beginPath();
      ctx.arc(lightPos.x, lightPos.y, 3 * zoom, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = `rgba(255, 250, 200, ${0.5 + Math.sin(time * 3) * 0.2})`;
      ctx.shadowColor = "#fffacc";
      ctx.shadowBlur = 6 * zoom;
      ctx.beginPath();
      ctx.arc(lightPos.x, lightPos.y, 2 * zoom, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // === CARGO (back, last) ===
      drawIsometricPrism(
        ctx,
        cargoPos.x,
        cargoPos.y,
        12,
        10,
        10,
        { top: "#6a6a72", left: "#5a5a62", right: "#4a4a52" },
        zoom
      );
      // Rivets
      ctx.fillStyle = "#8a8a92";
      for (let row = 0; row < 2; row++) {
        for (let col = 0; col < 3; col++) {
          ctx.beginPath();
          ctx.arc(
            cargoPos.x - 4 * zoom + col * 3 * zoom,
            cargoPos.y - 3 * zoom - row * 4 * zoom + col * 0.5 * zoom,
            1 * zoom,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
      }
      // Arrow slits
      ctx.fillStyle = "#2a2a32";
      ctx.fillRect(
        cargoPos.x - 1 * zoom,
        cargoPos.y - 7 * zoom,
        2 * zoom,
        5 * zoom
      );
      // Shield emblem
      ctx.fillStyle = "#e06000";
      ctx.shadowColor = "#e06000";
      ctx.shadowBlur = 4 * zoom;
      const shield = isoOffset(cargoPos.x, cargoPos.y - 5 * zoom, -4);
      ctx.beginPath();
      ctx.moveTo(shield.x, shield.y - 4 * zoom);
      ctx.lineTo(shield.x - 3 * zoom, shield.y);
      ctx.lineTo(shield.x, shield.y + 4 * zoom);
      ctx.lineTo(shield.x + 3 * zoom, shield.y);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;

      // Orange stripe
      ctx.strokeStyle = "#e06000";
      ctx.lineWidth = 3 * zoom;
      const stripeY = trainY - 2 * zoom;
      ctx.beginPath();
      ctx.moveTo(
        isoOffset(trainX, stripeY, -12).x,
        isoOffset(trainX, stripeY, -12).y
      );
      ctx.lineTo(
        isoOffset(trainX, stripeY, 12).x,
        isoOffset(trainX, stripeY, 12).y
      );
      ctx.stroke();
    } else if (tower.level === 3) {
      // ========== LEVEL 3: Fortress War Train ==========
      const cabPos = isoOffset(trainX, trainY, 8);
      const locoPos = isoOffset(trainX, trainY, 0);
      const fortressPos = isoOffset(trainX, trainY, -8);

      // Wheels
      const wheelY = trainY + 4 * zoom;
      drawWheel(
        isoOffset(trainX, wheelY, 12).x,
        isoOffset(trainX, wheelY, 12).y,
        4.5,
        "#5a5a62",
        "#3a3a42"
      );
      drawWheel(
        isoOffset(trainX, wheelY, 4).x,
        isoOffset(trainX, wheelY, 4).y,
        4.5,
        "#5a5a62",
        "#3a3a42"
      );
      drawWheel(
        isoOffset(trainX, wheelY, -4).x,
        isoOffset(trainX, wheelY, -4).y,
        4.5,
        "#5a5a62",
        "#3a3a42"
      );
      drawWheel(
        isoOffset(trainX, wheelY, -12).x,
        isoOffset(trainX, wheelY, -12).y,
        4.5,
        "#5a5a62",
        "#3a3a42"
      );

      // === CAB (front, first) ===
      drawIsometricPrism(
        ctx,
        cabPos.x,
        cabPos.y,
        12,
        11,
        16,
        { top: "#5a5a62", left: "#4a4a52", right: "#3a3a42" },
        zoom
      );
      // Cab battlements
      for (let i = 0; i < 2; i++) {
        const bPos = isoOffset(cabPos.x, cabPos.y - 16 * zoom, -3 + i * 6);
        drawIsometricPrism(
          ctx,
          bPos.x,
          bPos.y,
          3,
          3,
          3,
          { top: "#6a6a72", left: "#5a5a62", right: "#4a4a52" },
          zoom
        );
      }
      // Arrow slit
      ctx.fillStyle = "#2a2a32";
      ctx.fillRect(
        cabPos.x + 3 * zoom,
        cabPos.y - 12 * zoom,
        4 * zoom,
        2 * zoom
      );

      // === LOCOMOTIVE (middle) ===
      drawIsometricPrism(
        ctx,
        locoPos.x,
        locoPos.y,
        14,
        12,
        14,
        { top: "#5a5a62", left: "#4a4a52", right: "#3a3a42" },
        zoom
      );
      // Tower
      const towerPos = isoOffset(locoPos.x, locoPos.y - 14 * zoom, -2);
      drawIsometricPrism(
        ctx,
        towerPos.x,
        towerPos.y,
        7,
        7,
        12,
        { top: "#6a6a72", left: "#5a5a62", right: "#4a4a52" },
        zoom
      );
      // Tower battlements
      for (let i = 0; i < 2; i++) {
        const tbPos = isoOffset(towerPos.x, towerPos.y - 12 * zoom, -2 + i * 4);
        drawIsometricPrism(
          ctx,
          tbPos.x,
          tbPos.y,
          3,
          3,
          3,
          { top: "#7a7a82", left: "#5a5a62", right: "#4a4a52" },
          zoom
        );
      }
      // Smokestack
      const stackPos = isoOffset(locoPos.x, locoPos.y - 14 * zoom, 4);
      // use an isometric prism
      drawIsometricPrism(
        ctx,
        stackPos.x,
        stackPos.y,
        5,
        5,
        10,
        { top: "#3a3a42", left: "#2a2a32", right: "#1a1a1a" },
        zoom
      );
      // Stack cap
      drawIsometricPrism(
        ctx,
        stackPos.x,
        stackPos.y - 10 * zoom,
        7,
        7,
        2,
        { top: "#4a4a52", left: "#3a3a42", right: "#2a2a32" },
        zoom
      );
      // Steam
      const steam = 0.35 + Math.sin(time * 4) * 0.15;
      ctx.fillStyle = `rgba(180, 180, 180, ${steam})`;
      ctx.beginPath();
      ctx.arc(
        stackPos.x + Math.sin(time * 3) * 3,
        stackPos.y - 16 * zoom,
        6 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // === FORTRESS CAR (back, last) ===
      drawIsometricPrism(
        ctx,
        fortressPos.x,
        fortressPos.y,
        14,
        12,
        12,
        { top: "#6a6a72", left: "#5a5a62", right: "#4a4a52" },
        zoom
      );
      // Battlements
      for (let i = 0; i < 3; i++) {
        const bPos = isoOffset(
          fortressPos.x,
          fortressPos.y - 12 * zoom,
          -4 + i * 4
        );
        drawIsometricPrism(
          ctx,
          bPos.x,
          bPos.y,
          3,
          3,
          4,
          { top: "#7a7a82", left: "#5a5a62", right: "#4a4a52" },
          zoom
        );
      }
      // Portcullis
      ctx.fillStyle = "#2a2a32";
      ctx.fillRect(
        fortressPos.x - 2 * zoom,
        fortressPos.y - 9 * zoom,
        4 * zoom,
        6 * zoom
      );
      ctx.strokeStyle = "#5a5a62";
      ctx.lineWidth = 1 * zoom;
      ctx.beginPath();
      ctx.moveTo(fortressPos.x, fortressPos.y - 9 * zoom);
      ctx.lineTo(fortressPos.x, fortressPos.y - 3 * zoom);
      ctx.stroke();
      // Rose window
      const roseGlow = 0.6 + Math.sin(time * 2) * 0.25;
      ctx.fillStyle = `rgba(255, 108, 0, ${roseGlow})`;
      ctx.shadowColor = "#e06000";
      ctx.shadowBlur = 10 * zoom;
      const rosePos = isoOffset(fortressPos.x, fortressPos.y - 7 * zoom, -5);
      ctx.beginPath();
      ctx.arc(rosePos.x, rosePos.y, 3 * zoom, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Orange stripe
      ctx.strokeStyle = "#e06000";
      ctx.lineWidth = 3.5 * zoom;
      const stripeY = trainY - 2 * zoom;
      ctx.beginPath();
      ctx.moveTo(
        isoOffset(trainX, stripeY, -14).x,
        isoOffset(trainX, stripeY, -14).y
      );
      ctx.lineTo(
        isoOffset(trainX, stripeY, 14).x,
        isoOffset(trainX, stripeY, 14).y
      );
      ctx.stroke();
    } else if (tower.level === 4 && tower.upgrade === "A") {
      // ========== LEVEL 4A: Royal Marble Train ==========
      const cabPos = isoOffset(trainX, trainY, 7);
      const locoPos = isoOffset(trainX, trainY, 0);
      const passengerPos = isoOffset(trainX, trainY, -7);

      // Gold wheels
      const wheelY = trainY + 4 * zoom;
      const wPositions = [10, 4, -3, -10];
      for (const wp of wPositions) {
        const wPos = isoOffset(trainX, wheelY, wp);
        ctx.fillStyle = "#c9a227";
        ctx.strokeStyle = "#b8860b";
        ctx.lineWidth = 2 * zoom;
        ctx.beginPath();
        ctx.ellipse(wPos.x, wPos.y, 4 * zoom, 2 * zoom, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Gold spokes
        ctx.strokeStyle = "#daa520";
        ctx.lineWidth = 1 * zoom;
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2 + time * 2;
          ctx.beginPath();
          ctx.moveTo(wPos.x, wPos.y);
          ctx.lineTo(
            wPos.x + Math.cos(angle) * 3.2 * zoom,
            wPos.y + Math.sin(angle) * 1.6 * zoom
          );
          ctx.stroke();
        }
        ctx.fillStyle = "#b8860b";
        ctx.beginPath();
        ctx.ellipse(wPos.x, wPos.y, 1.2 * zoom, 0.6 * zoom, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      // === CAB (front, first) ===
      drawIsometricPrism(
        ctx,
        cabPos.x,
        cabPos.y,
        10,
        10,
        12,
        { top: "#f0ece4", left: "#e0dcd4", right: "#d0ccc4" },
        zoom
      );
      // Domed roof
      ctx.fillStyle = "#e8e4dc";
      ctx.beginPath();
      ctx.arc(cabPos.x, cabPos.y - 12 * zoom, 5 * zoom, Math.PI, 0);
      ctx.fill();
      ctx.strokeStyle = "#c9a227";
      ctx.lineWidth = 2 * zoom;
      ctx.stroke();
      // Finial
      ctx.fillStyle = "#c9a227";
      ctx.shadowColor = "#c9a227";
      ctx.shadowBlur = 5 * zoom;
      ctx.beginPath();
      ctx.arc(cabPos.x, cabPos.y - 17 * zoom, 1.5 * zoom, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      // Arched window
      const cabGlow = 0.5 + Math.sin(time * 2) * 0.15;
      ctx.fillStyle = "#c0a080";
      ctx.beginPath();
      ctx.arc(cabPos.x + 2 * zoom, cabPos.y - 8 * zoom, 3 * zoom, Math.PI, 0);
      ctx.fill();
      ctx.fillStyle = `rgba(255, 250, 230, ${cabGlow})`;
      ctx.beginPath();
      ctx.arc(cabPos.x + 2 * zoom, cabPos.y - 8 * zoom, 2.5 * zoom, Math.PI, 0);
      ctx.fill();

      // === LOCOMOTIVE (middle) ===
      drawIsometricPrism(
        ctx,
        locoPos.x,
        locoPos.y,
        12,
        10,
        12,
        { top: "#f8f4ec", left: "#e8e4dc", right: "#d8d4cc" },
        zoom
      );
      // Gold bands
      ctx.strokeStyle = "#c9a227";
      ctx.lineWidth = 2 * zoom;
      for (let i = 0; i < 2; i++) {
        const bandY = locoPos.y - 5 * zoom - i * 5 * zoom;
        ctx.beginPath();
        ctx.moveTo(locoPos.x - 5 * zoom, bandY + 2.5 * zoom);
        ctx.lineTo(locoPos.x + 5 * zoom, bandY - 2.5 * zoom);
        ctx.stroke();
      }
      // Marble dome
      ctx.fillStyle = "#e8e4dc";
      ctx.beginPath();
      ctx.arc(locoPos.x, locoPos.y - 14 * zoom, 3.5 * zoom, Math.PI, 0);
      ctx.fill();
      ctx.strokeStyle = "#c9a227";
      ctx.lineWidth = 1.5 * zoom;
      ctx.stroke();
      // Gold smokestack
      const stackPos = isoOffset(locoPos.x, locoPos.y - 12 * zoom, 3);
      ctx.fillStyle = "#daa520";
      ctx.beginPath();
      ctx.moveTo(stackPos.x - 2.5 * zoom, stackPos.y);
      ctx.lineTo(stackPos.x - 3 * zoom, stackPos.y - 10 * zoom);
      ctx.lineTo(stackPos.x + 3 * zoom, stackPos.y - 10 * zoom);
      ctx.lineTo(stackPos.x + 2.5 * zoom, stackPos.y);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "#c9a227";
      ctx.shadowColor = "#c9a227";
      ctx.shadowBlur = 6 * zoom;
      ctx.beginPath();
      ctx.ellipse(
        stackPos.x,
        stackPos.y - 10 * zoom,
        3.5 * zoom,
        1.8 * zoom,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();
      ctx.shadowBlur = 0;
      // Golden steam
      const steam = 0.3 + Math.sin(time * 4) * 0.15;
      ctx.fillStyle = `rgba(255, 245, 220, ${steam})`;
      ctx.beginPath();
      ctx.arc(
        stackPos.x + Math.sin(time * 3) * 3,
        stackPos.y - 16 * zoom,
        5 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // === PASSENGER CAR (back, last) ===
      drawIsometricPrism(
        ctx,
        passengerPos.x,
        passengerPos.y,
        12,
        10,
        10,
        { top: "#f0ece4", left: "#e0dcd4", right: "#d0ccc4" },
        zoom
      );
      // Gold columns
      ctx.fillStyle = "#c9a227";
      ctx.shadowColor = "#c9a227";
      ctx.shadowBlur = 3 * zoom;
      const col1 = isoOffset(passengerPos.x, passengerPos.y, -3);
      const col2 = isoOffset(passengerPos.x, passengerPos.y, 3);
      ctx.fillRect(col1.x - 1 * zoom, col1.y - 10 * zoom, 2 * zoom, 10 * zoom);
      ctx.fillRect(col2.x - 1 * zoom, col2.y - 10 * zoom, 2 * zoom, 10 * zoom);
      ctx.shadowBlur = 0;
      // Arched window
      const winGlow = 0.5 + Math.sin(time * 2) * 0.15;
      ctx.fillStyle = "#c0a080";
      ctx.beginPath();
      ctx.arc(passengerPos.x, passengerPos.y - 6 * zoom, 3 * zoom, Math.PI, 0);
      ctx.fill();
      ctx.fillStyle = `rgba(200, 230, 255, ${winGlow})`;
      ctx.beginPath();
      ctx.arc(
        passengerPos.x,
        passengerPos.y - 6 * zoom,
        2.5 * zoom,
        Math.PI,
        0
      );
      ctx.fill();
      // Horse emblem
      ctx.fillStyle = "#c9a227";
      ctx.shadowColor = "#c9a227";
      ctx.shadowBlur = 5 * zoom;
      const horsePos = isoOffset(passengerPos.x, passengerPos.y - 5 * zoom, -4);
      ctx.beginPath();
      ctx.moveTo(horsePos.x - 2 * zoom, horsePos.y + 2 * zoom);
      ctx.quadraticCurveTo(
        horsePos.x,
        horsePos.y - 3 * zoom,
        horsePos.x + 2 * zoom,
        horsePos.y
      );
      ctx.quadraticCurveTo(
        horsePos.x + 2.5 * zoom,
        horsePos.y + 2 * zoom,
        horsePos.x + 1.5 * zoom,
        horsePos.y + 3 * zoom
      );
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    } else {
      // ========== LEVEL 4B: Royal Armored Train ==========
      const cabPos = isoOffset(trainX, trainY, 8);
      const locoPos = isoOffset(trainX, trainY, 0);
      const armoredPos = isoOffset(trainX, trainY, -8);

      // Wheels with gold trim
      const wheelY = trainY + 4 * zoom;
      const wPositions = [12, 4, -4, -12];
      for (const wp of wPositions) {
        const wPos = isoOffset(trainX, wheelY, wp);
        ctx.fillStyle = "#5a5a62";
        ctx.strokeStyle = "#c9a227";
        ctx.lineWidth = 2 * zoom;
        ctx.beginPath();
        ctx.ellipse(wPos.x, wPos.y, 4.5 * zoom, 2.25 * zoom, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Spokes
        ctx.strokeStyle = "#4a4a52";
        ctx.lineWidth = 1 * zoom;
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2 + time * 2;
          ctx.beginPath();
          ctx.moveTo(wPos.x, wPos.y);
          ctx.lineTo(
            wPos.x + Math.cos(angle) * 3.6 * zoom,
            wPos.y + Math.sin(angle) * 1.8 * zoom
          );
          ctx.stroke();
        }
        ctx.fillStyle = "#c9a227";
        ctx.beginPath();
        ctx.ellipse(wPos.x, wPos.y, 1.4 * zoom, 0.7 * zoom, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      // === CAB (front, first) ===
      drawIsometricPrism(
        ctx,
        cabPos.x,
        cabPos.y,
        12,
        12,
        16,
        { top: "#5a5a62", left: "#4a4a52", right: "#3a3a42" },
        zoom
      );
      // Crown on cab
      ctx.fillStyle = "#c9a227";
      ctx.shadowColor = "#c9a227";
      ctx.shadowBlur = 8 * zoom;
      ctx.beginPath();
      ctx.moveTo(cabPos.x - 5 * zoom, cabPos.y - 16 * zoom);
      ctx.lineTo(cabPos.x - 3 * zoom, cabPos.y - 21 * zoom);
      ctx.lineTo(cabPos.x - 1 * zoom, cabPos.y - 17 * zoom);
      ctx.lineTo(cabPos.x + 1 * zoom, cabPos.y - 21 * zoom);
      ctx.lineTo(cabPos.x + 3 * zoom, cabPos.y - 17 * zoom);
      ctx.lineTo(cabPos.x + 5 * zoom, cabPos.y - 21 * zoom);
      ctx.lineTo(cabPos.x + 5 * zoom, cabPos.y - 16 * zoom);
      ctx.closePath();
      ctx.fill();
      // Crown jewel
      ctx.fillStyle = "#e06000";
      ctx.beginPath();
      ctx.arc(cabPos.x, cabPos.y - 18 * zoom, 1.5 * zoom, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      // Vision slit with gold frame
      ctx.fillStyle = "#2a2a32";
      ctx.fillRect(
        cabPos.x + 3 * zoom,
        cabPos.y - 12 * zoom,
        5 * zoom,
        2 * zoom
      );
      ctx.strokeStyle = "#c9a227";
      ctx.lineWidth = 1.5 * zoom;
      ctx.strokeRect(
        cabPos.x + 2.5 * zoom,
        cabPos.y - 12.5 * zoom,
        6 * zoom,
        3 * zoom
      );

      // === LOCOMOTIVE (middle) ===
      drawIsometricPrism(
        ctx,
        locoPos.x,
        locoPos.y,
        14,
        12,
        14,
        { top: "#5a5a62", left: "#4a4a52", right: "#3a3a42" },
        zoom
      );
      // Gold bands
      ctx.strokeStyle = "#c9a227";
      ctx.lineWidth = 2.5 * zoom;
      for (let i = 0; i < 2; i++) {
        const bandY = locoPos.y - 5 * zoom - i * 6 * zoom;
        ctx.beginPath();
        ctx.moveTo(locoPos.x - 6 * zoom, bandY + 3 * zoom);
        ctx.lineTo(locoPos.x + 6 * zoom, bandY - 3 * zoom);
        ctx.stroke();
      }
      // Armored dome with gold
      ctx.fillStyle = "#4a4a52";
      ctx.beginPath();
      ctx.arc(locoPos.x, locoPos.y - 15 * zoom, 4 * zoom, Math.PI, 0);
      ctx.fill();
      ctx.strokeStyle = "#c9a227";
      ctx.lineWidth = 2 * zoom;
      ctx.stroke();
      // Royal smokestack with crown
      const stackPos = isoOffset(locoPos.x, locoPos.y - 14 * zoom, 4);
      ctx.fillStyle = "#4a4a52";
      ctx.beginPath();
      ctx.moveTo(stackPos.x - 3 * zoom, stackPos.y);
      ctx.lineTo(stackPos.x - 2.5 * zoom, stackPos.y - 10 * zoom);
      ctx.lineTo(stackPos.x + 2.5 * zoom, stackPos.y - 10 * zoom);
      ctx.lineTo(stackPos.x + 3 * zoom, stackPos.y);
      ctx.closePath();
      ctx.fill();
      // Crown on stack
      ctx.fillStyle = "#c9a227";
      ctx.shadowColor = "#c9a227";
      ctx.shadowBlur = 5 * zoom;
      ctx.beginPath();
      ctx.moveTo(stackPos.x - 3.5 * zoom, stackPos.y - 10 * zoom);
      ctx.lineTo(stackPos.x - 2 * zoom, stackPos.y - 14 * zoom);
      ctx.lineTo(stackPos.x, stackPos.y - 11 * zoom);
      ctx.lineTo(stackPos.x + 2 * zoom, stackPos.y - 14 * zoom);
      ctx.lineTo(stackPos.x + 3.5 * zoom, stackPos.y - 10 * zoom);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
      // Steam
      const steam = 0.35 + Math.sin(time * 4) * 0.15;
      ctx.fillStyle = `rgba(180, 180, 180, ${steam})`;
      ctx.beginPath();
      ctx.arc(
        stackPos.x + Math.sin(time * 3) * 3,
        stackPos.y - 20 * zoom,
        6 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // === ARMORED CAR (back, last) ===
      drawIsometricPrism(
        ctx,
        armoredPos.x,
        armoredPos.y,
        14,
        12,
        12,
        { top: "#6a6a72", left: "#5a5a62", right: "#4a4a52" },
        zoom
      );
      // Gold trim
      ctx.strokeStyle = "#c9a227";
      ctx.lineWidth = 2.5 * zoom;
      ctx.beginPath();
      ctx.moveTo(armoredPos.x - 6 * zoom, armoredPos.y - 12 * zoom);
      ctx.lineTo(armoredPos.x + 6 * zoom, armoredPos.y - 12 * zoom + 3 * zoom);
      ctx.stroke();
      // Stained glass window
      const sgGlow = 0.6 + Math.sin(time * 2) * 0.25;
      ctx.fillStyle = "#4a4a52";
      ctx.beginPath();
      ctx.arc(
        armoredPos.x,
        armoredPos.y - 6 * zoom,
        4.5 * zoom,
        0,
        Math.PI * 2
      );
      ctx.fill();
      ctx.fillStyle = `rgba(255, 150, 50, ${sgGlow})`;
      ctx.shadowColor = "#e06000";
      ctx.shadowBlur = 10 * zoom;
      ctx.beginPath();
      ctx.arc(armoredPos.x, armoredPos.y - 6 * zoom, 4 * zoom, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      // Crown emblem
      ctx.fillStyle = "#c9a227";
      ctx.shadowColor = "#c9a227";
      ctx.shadowBlur = 6 * zoom;
      const crownPos = isoOffset(armoredPos.x, armoredPos.y - 10 * zoom, 0);
      ctx.beginPath();
      ctx.moveTo(crownPos.x - 5 * zoom, crownPos.y);
      ctx.lineTo(crownPos.x - 3 * zoom, crownPos.y - 4 * zoom);
      ctx.lineTo(crownPos.x - 1 * zoom, crownPos.y - 2 * zoom);
      ctx.lineTo(crownPos.x + 1 * zoom, crownPos.y - 4 * zoom);
      ctx.lineTo(crownPos.x + 3 * zoom, crownPos.y - 2 * zoom);
      ctx.lineTo(crownPos.x + 5 * zoom, crownPos.y - 4 * zoom);
      ctx.lineTo(crownPos.x + 5 * zoom, crownPos.y);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;

      // Orange stripe
      ctx.strokeStyle = "#e06000";
      ctx.lineWidth = 3.5 * zoom;
      const stripeY = trainY - 2 * zoom;
      ctx.beginPath();
      ctx.moveTo(
        isoOffset(trainX, stripeY, -14).x,
        isoOffset(trainX, stripeY, -14).y
      );
      ctx.lineTo(
        isoOffset(trainX, stripeY, 14).x,
        isoOffset(trainX, stripeY, 14).y
      );
      ctx.stroke();
    }

    ctx.restore();
  }

  // ========== SPAWN POSITIONS ==========
  const spawnPositions = [
    { x: screenPos.x - 24 * zoom, y: screenPos.y + 22 * zoom },
    { x: screenPos.x, y: screenPos.y + 28 * zoom },
    { x: screenPos.x + 24 * zoom, y: screenPos.y + 22 * zoom },
  ];

  if (tower.showSpawnMarkers || tower.selected) {
    for (let i = 0; i < spawnPositions.length; i++) {
      const pos = spawnPositions[i];
      const occupied = (tower.occupiedSpawnSlots || [])[i];
      const pulse = 0.6 + Math.sin(time * 3 + i) * 0.3;

      ctx.strokeStyle = occupied
        ? `rgba(255, 100, 100, ${pulse * 0.6})`
        : `rgba(255, 108, 0, ${pulse})`;
      ctx.lineWidth = 2.5 * zoom;
      ctx.setLineDash([5, 4]);
      ctx.beginPath();
      ctx.ellipse(pos.x, pos.y, 14 * zoom, 7 * zoom, 0, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = occupied
        ? "rgba(180, 80, 80, 0.9)"
        : "rgba(200, 100, 0, 0.9)";
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, 5 * zoom, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.font = `bold ${6 * zoom}px Arial`;
      ctx.textAlign = "center";
      ctx.fillText((i + 1).toString(), pos.x, pos.y + 2 * zoom);
    }
  }

  // ========== SPAWN EFFECT ==========
  if (tower.spawnEffect && tower.spawnEffect > 0) {
    const effectProgress = 1 - tower.spawnEffect / 500;
    ctx.strokeStyle = `rgba(255, 108, 0, ${1 - effectProgress})`;
    ctx.lineWidth = 4 * zoom;
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      screenPos.y + 8 * zoom,
      35 * zoom * (1 + effectProgress * 0.6),
      18 * zoom * (1 + effectProgress * 0.6),
      0,
      0,
      Math.PI * 2
    );
    ctx.stroke();

    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2 + time * 2;
      const dist = 30 * zoom * (1 + effectProgress * 0.4);
      ctx.fillStyle = `rgba(255, 108, 0, ${(1 - effectProgress) * 0.8})`;
      ctx.beginPath();
      ctx.arc(
        screenPos.x + Math.cos(angle) * dist,
        screenPos.y + 8 * zoom + Math.sin(angle) * dist * 0.5,
        3 * zoom * (1 - effectProgress),
        0,
        Math.PI * 2
      );
      ctx.fill();
    }
  }

  // ========== PLATFORM LAMPS ==========
  const lampPositions = [
    { x: screenPos.x - 38 * zoom, y: screenPos.y - 30 * zoom },
    { x: screenPos.x + 38 * zoom, y: screenPos.y - 30 * zoom },
  ];

  for (let i = 0; i < lampPositions.length; i++) {
    const lamp = lampPositions[i];

    // Lamp post
    ctx.fillStyle = "#2a2a32";
    ctx.fillRect(lamp.x - 2 * zoom, lamp.y, 4 * zoom, 34 * zoom);

    // Lamp head
    ctx.fillStyle = "#3a3a42";
    ctx.beginPath();
    ctx.moveTo(lamp.x - 6 * zoom, lamp.y + 3 * zoom);
    ctx.lineTo(lamp.x - 5 * zoom, lamp.y - 5 * zoom);
    ctx.lineTo(lamp.x + 5 * zoom, lamp.y - 5 * zoom);
    ctx.lineTo(lamp.x + 6 * zoom, lamp.y + 3 * zoom);
    ctx.closePath();
    ctx.fill();

    // Lamp glow (Princeton orange)
    const lampGlow = 0.6 + Math.sin(time * 2.5 + i * Math.PI) * 0.25;
    ctx.fillStyle = `rgba(255, 150, 50, ${lampGlow})`;
    ctx.shadowColor = "#ff9632";
    ctx.shadowBlur = 12 * zoom;
    ctx.beginPath();
    ctx.arc(lamp.x, lamp.y, 4 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  ctx.restore();
}

// ============================================================================
// RANGE INDICATORS - Only for Library and Arch towers
// ============================================================================
export function renderStationRange(
  ctx: CanvasRenderingContext2D,
  tower: Tower & { isHovered?: boolean },
  canvasWidth: number,
  canvasHeight: number,
  dpr: number,
  cameraOffset?: Position,
  cameraZoom?: number
) {
  // Only show spawn range when station is hovered or selected
  if (!tower.isHovered && !tower.selected) return;

  const range = tower.spawnRange || 180;
  const worldPos = gridToWorld(tower.pos);
  const screenPos = worldToScreen(
    worldPos,
    canvasWidth,
    canvasHeight,
    dpr,
    cameraOffset,
    cameraZoom
  );
  const zoom = cameraZoom || 1;

  // Use orange color for spawn range
  ctx.strokeStyle = tower.isHovered
    ? "rgba(255, 180, 100, 0.4)"
    : "rgba(255, 180, 100, 0.6)";
  ctx.fillStyle = tower.isHovered
    ? "rgba(255, 180, 100, 0.08)"
    : "rgba(255, 180, 100, 0.15)";
  ctx.lineWidth = 2;
  ctx.setLineDash([8, 4]);
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    screenPos.y,
    range * zoom * 0.7,
    range * zoom * 0.35,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();
  ctx.stroke();
  ctx.setLineDash([]);
}

export function renderTowerRange(
  ctx: CanvasRenderingContext2D,
  tower: Tower & { isHovered?: boolean },
  canvasWidth: number,
  canvasHeight: number,
  dpr: number,
  cameraOffset?: Position,
  cameraZoom?: number
) {
  const tData = TOWER_DATA[tower.type];
  if (tData.range <= 0) return;
  const worldPos = gridToWorld(tower.pos);
  const screenPos = worldToScreen(
    worldPos,
    canvasWidth,
    canvasHeight,
    dpr,
    cameraOffset,
    cameraZoom
  );
  const zoom = cameraZoom || 1;

  let range = tData.range;
  if (tower.level === 2) range *= 1.15;
  if (tower.level === 3) {
    if (tower.type === "library" && tower.upgrade === "B") range *= 1.5;
    else range *= 1.25;
  }
  // Level 4 uses the range from TOWER_STATS upgrade paths
  if (tower.level >= 4 && tower.upgrade) {
    const towerStats = TOWER_STATS[tower.type];
    const upgradeRange = towerStats?.upgrades?.[tower.upgrade]?.stats?.range;
    if (upgradeRange !== undefined) {
      range = upgradeRange;
    } else {
      // Fallback: 1.5x base range if no specific range defined
      range = tData.range * 1.5;
    }
  }
  // Apply external range buff (from beacons etc)
  range *= (tower.rangeBoost || 1);

  // Use more subtle colors for hover state
  if (tower.isHovered) {
    ctx.strokeStyle = "rgba(100, 200, 255, 0.3)";
    ctx.fillStyle = "rgba(100, 200, 255, 0.05)";
  } else {
    ctx.strokeStyle = "rgba(100, 200, 255, 0.5)";
    ctx.fillStyle = "rgba(100, 200, 255, 0.1)";
  }
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    screenPos.y,
    range * zoom * 0.7,
    range * zoom * 0.35,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();
  ctx.stroke();
}

// ============================================================================
// ENEMY RENDERING
// ============================================================================
export function renderEnemy(
  ctx: CanvasRenderingContext2D,
  enemy: Enemy,
  canvasWidth: number,
  canvasHeight: number,
  dpr: number,
  selectedMap: string,
  cameraOffset?: Position,
  cameraZoom?: number
) {
  // Use enemy's pathKey for dual-path support
  const pathKey = enemy.pathKey || selectedMap;
  const worldPos = getEnemyPosition(enemy, pathKey);
  const screenPos = worldToScreen(
    worldPos,
    canvasWidth,
    canvasHeight,
    dpr,
    cameraOffset,
    cameraZoom
  );
  const zoom = cameraZoom || 1;
  const eData = ENEMY_DATA[enemy.type];
  const time = Date.now() / 1000;
  const spawnAlpha = Math.min(1, enemy.spawnProgress);
  if (spawnAlpha <= 0) return;

  ctx.save();
  ctx.globalAlpha = spawnAlpha;

  const size = eData.size * zoom;
  const isFlying = eData.flying;
  const floatOffset = isFlying ? Math.sin(time * 3) * 10 * zoom : 0;
  const bobOffset = Math.sin(time * 5 + enemy.pathIndex) * 2 * zoom;
  const drawY =
    screenPos.y -
    size / 2 -
    floatOffset -
    bobOffset -
    (isFlying ? 35 * zoom : 0);

  // Shadow
  ctx.fillStyle = `rgba(0,0,0,${0.35 * spawnAlpha})`;
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    screenPos.y + 5 * zoom,
    size * 0.6,
    size * 0.3,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // PERFORMANCE OPTIMIZED: Removed expensive shadowBlur for status effects
  // Instead, we use colored outlines/overlays which are much cheaper

  const flashIntensity = enemy.damageFlash > 0 ? enemy.damageFlash / 200 : 0;

  // Calculate attack phase for animation (smooth 1-0 based on attack timing)
  // Check BOTH lastTroopAttack AND lastHeroAttack - use whichever is more recent
  const attackDuration = 450; // ms for attack animation
  const lastAttackTime = Math.max(enemy.lastTroopAttack || 0, enemy.lastHeroAttack || 0);
  const timeSinceAttack = Date.now() - lastAttackTime;
  // attackPhase goes from 1.0 (just attacked) down to 0 (animation done)
  const attackPhase = timeSinceAttack < attackDuration 
    ? 1 - (timeSinceAttack / attackDuration)
    : 0;

  // ATTACK RESIZE EFFECT - Subtle scale pulse during attack
  const attackScalePulse = attackPhase > 0 
    ? 1 + Math.sin(attackPhase * Math.PI) * 0.12 // Subtle 12% scale up at peak
    : 1;
  
  // Apply scale transform for the enemy sprite
  ctx.save();
  ctx.translate(screenPos.x, drawY);
  ctx.scale(attackScalePulse, attackScalePulse);
  ctx.translate(-screenPos.x, -drawY);

  drawEnemySprite(
    ctx,
    screenPos.x,
    drawY,
    size,
    enemy.type,
    eData.color,
    flashIntensity,
    time,
    isFlying,
    zoom,
    attackPhase
  );

  // ATTACK ANIMATION EFFECTS - Subtle, elegant red visual feedback
  if (attackPhase > 0) {
    const attackPulse = Math.sin(attackPhase * Math.PI); // Peaks in middle
    const attackEase = 1 - Math.pow(1 - attackPhase, 2); // Ease out curve
    
    // Soft outer aura ring - fades outward (red)
    const ringExpand = (1 - attackPhase) * 0.4;
    ctx.strokeStyle = `rgba(255, 80, 80, ${attackPhase * 0.3})`;
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.arc(screenPos.x, drawY, size * (0.7 + ringExpand), 0, Math.PI * 2);
    ctx.stroke();
    
    // Inner soft glow - red tones
    const glowGrad = ctx.createRadialGradient(
      screenPos.x, drawY - size * 0.1, 0, 
      screenPos.x, drawY, size * 0.65
    );
    glowGrad.addColorStop(0, `rgba(255, 100, 100, ${attackPulse * 0.25})`);
    glowGrad.addColorStop(0.4, `rgba(220, 60, 60, ${attackPulse * 0.15})`);
    glowGrad.addColorStop(1, `rgba(180, 40, 40, 0)`);
    ctx.fillStyle = glowGrad;
    ctx.beginPath();
    ctx.ellipse(screenPos.x, drawY, size * 0.65, size * 0.45, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Motion lines - red speed streaks
    ctx.lineCap = "round";
    const streakCount = 3;
    for (let i = 0; i < streakCount; i++) {
      const baseAngle = -Math.PI * 0.3 + (i / (streakCount - 1)) * Math.PI * 0.6;
      const streakAlpha = attackEase * 0.4 * (1 - Math.abs(i - 1) * 0.2);
      const streakLen = size * (0.25 + attackPulse * 0.15);
      const startDist = size * 0.55;
      
      // Create gradient for each streak
      const sx = screenPos.x + Math.cos(baseAngle) * startDist;
      const sy = drawY + Math.sin(baseAngle) * startDist * 0.5;
      const ex = screenPos.x + Math.cos(baseAngle) * (startDist + streakLen);
      const ey = drawY + Math.sin(baseAngle) * (startDist + streakLen) * 0.5;
      
      ctx.strokeStyle = `rgba(255, 120, 120, ${streakAlpha})`;
      ctx.lineWidth = (2.5 - i * 0.3) * zoom;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(ex, ey);
      ctx.stroke();
    }
    
    // Small impact particles - only at attack start (first 30%)
    if (attackPhase > 0.7) {
      const burstPhase = (attackPhase - 0.7) / 0.3;
      const particleCount = 5;
      for (let i = 0; i < particleCount; i++) {
        const pAngle = (i / particleCount) * Math.PI * 2 + Math.PI * 0.1;
        const pDist = size * (0.35 + burstPhase * 0.25);
        const pAlpha = burstPhase * 0.55 * (1 - burstPhase * 0.3);
        const pSize = size * 0.025 * (1 + burstPhase * 0.5);
        
        ctx.fillStyle = `rgba(255, 100, 100, ${pAlpha})`;
        ctx.beginPath();
        ctx.arc(
          screenPos.x + Math.cos(pAngle) * pDist,
          drawY + Math.sin(pAngle) * pDist * 0.5,
          pSize,
          0,
          Math.PI * 2
        );
        ctx.fill();
      }
    }
    
    // Ground impact indicator - subtle red arc beneath enemy
    if (attackPulse > 0.3) {
      const impactAlpha = (attackPulse - 0.3) * 0.35;
      ctx.strokeStyle = `rgba(180, 50, 50, ${impactAlpha})`;
      ctx.lineWidth = 2 * zoom;
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x, 
        drawY + size * 0.4, 
        size * (0.4 + attackPulse * 0.15), 
        size * 0.1,
        0, 
        0.1 * Math.PI, 
        0.9 * Math.PI
      );
      ctx.stroke();
    }
  }
  
  // Restore canvas state after attack scale transform
  ctx.restore();

  // FROZEN EFFECT - Detailed ice crystals and frost
  if (enemy.frozen) {
    // Frost aura base - layered for depth
    ctx.fillStyle = "rgba(180, 230, 255, 0.25)";
    ctx.beginPath();
    ctx.ellipse(screenPos.x, drawY, size * 0.9, size * 0.55, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "rgba(150, 210, 255, 0.35)";
    ctx.beginPath();
    ctx.ellipse(screenPos.x, drawY, size * 0.7, size * 0.42, 0, 0, Math.PI * 2);
    ctx.fill();

    // Icy crystalline border
    ctx.strokeStyle = "rgba(100, 200, 255, 0.9)";
    ctx.lineWidth = 1.5 * zoom;
    ctx.setLineDash([4 * zoom, 3 * zoom]);
    ctx.beginPath();
    ctx.ellipse(screenPos.x, drawY, size * 0.8, size * 0.48, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);

    // 5 detailed ice crystals orbiting slowly
    const crystalRotation = time * 0.5;
    for (let i = 0; i < 5; i++) {
      const angle = (i / 5) * Math.PI * 2 + crystalRotation;
      const dist = size * 0.55;
      const cx = screenPos.x + Math.cos(angle) * dist;
      const cy = drawY + Math.sin(angle) * dist * 0.5;
      const cSize = (3.5 + Math.sin(i * 1.3) * 1.5) * zoom;

      // Crystal body - hexagonal ice shard
      ctx.fillStyle = "rgba(220, 245, 255, 0.9)";
      ctx.beginPath();
      ctx.moveTo(cx, cy - cSize * 1.4);
      ctx.lineTo(cx + cSize * 0.6, cy - cSize * 0.4);
      ctx.lineTo(cx + cSize * 0.6, cy + cSize * 0.4);
      ctx.lineTo(cx, cy + cSize * 0.8);
      ctx.lineTo(cx - cSize * 0.6, cy + cSize * 0.4);
      ctx.lineTo(cx - cSize * 0.6, cy - cSize * 0.4);
      ctx.closePath();
      ctx.fill();

      // Crystal highlight
      ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
      ctx.beginPath();
      ctx.moveTo(cx - cSize * 0.2, cy - cSize * 1.1);
      ctx.lineTo(cx + cSize * 0.15, cy - cSize * 0.3);
      ctx.lineTo(cx - cSize * 0.35, cy - cSize * 0.2);
      ctx.closePath();
      ctx.fill();
    }

    // Floating frost particles
    for (let i = 0; i < 4; i++) {
      const pAngle = time * 2 + i * 1.57;
      const pDist = size * (0.3 + Math.sin(time * 1.5 + i) * 0.15);
      const px = screenPos.x + Math.cos(pAngle) * pDist;
      const py = drawY - size * 0.3 + Math.sin(pAngle * 0.7) * size * 0.2;
      ctx.fillStyle = `rgba(200, 240, 255, ${0.6 + Math.sin(time * 3 + i) * 0.3})`;
      ctx.beginPath();
      ctx.arc(px, py, 1.5 * zoom, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // BURNING EFFECT - Detailed flames with embers
  if (enemy.burning) {
    // Heat shimmer ring at base
    ctx.strokeStyle = `rgba(255, 100, 0, ${0.3 + Math.sin(time * 8) * 0.15})`;
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.ellipse(screenPos.x, drawY + size * 0.1, size * 0.5, size * 0.25, 0, 0, Math.PI * 2);
    ctx.stroke();

    // Main flames - layered teardrop shapes
    for (let i = 0; i < 4; i++) {
      const flameOffset = Math.sin(time * 6 + i * 1.8) * size * 0.15;
      const flameX = screenPos.x + flameOffset + (i - 1.5) * size * 0.12;
      const baseY = drawY - size * 0.15;
      const flameHeight = (size * 0.55 + Math.sin(time * 7 + i * 2) * size * 0.15) * zoom;
      const flameWidth = (size * 0.18 + Math.sin(time * 5 + i) * size * 0.04) * zoom;
      const flicker = Math.sin(time * 10 + i * 3) * 0.15;

      // Outer red flame
      ctx.fillStyle = `rgba(220, 60, 20, ${0.75 + flicker})`;
      ctx.beginPath();
      ctx.moveTo(flameX, baseY);
      ctx.quadraticCurveTo(flameX - flameWidth, baseY - flameHeight * 0.5, flameX, baseY - flameHeight);
      ctx.quadraticCurveTo(flameX + flameWidth, baseY - flameHeight * 0.5, flameX, baseY);
      ctx.fill();

      // Inner orange/yellow core
      ctx.fillStyle = `rgba(255, ${180 + Math.floor(Math.sin(time * 8 + i) * 40)}, 50, ${0.85 + flicker})`;
      ctx.beginPath();
      ctx.moveTo(flameX, baseY);
      ctx.quadraticCurveTo(flameX - flameWidth * 0.5, baseY - flameHeight * 0.4, flameX, baseY - flameHeight * 0.7);
      ctx.quadraticCurveTo(flameX + flameWidth * 0.5, baseY - flameHeight * 0.4, flameX, baseY);
      ctx.fill();
    }

    // Rising embers/sparks
    for (let i = 0; i < 5; i++) {
      const emberPhase = (time * 2.5 + i * 0.4) % 1;
      const emberX = screenPos.x + Math.sin(time * 3 + i * 2.2) * size * 0.3;
      const emberY = drawY - size * 0.2 - emberPhase * size * 0.8;
      const emberSize = (1.5 - emberPhase) * 2 * zoom;
      const emberAlpha = (1 - emberPhase) * 0.9;

      // Ember glow
      ctx.fillStyle = `rgba(255, ${200 - Math.floor(emberPhase * 100)}, ${100 - Math.floor(emberPhase * 80)}, ${emberAlpha})`;
      ctx.beginPath();
      ctx.arc(emberX, emberY, emberSize, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // SLOWED EFFECT - Highly visible arcane magic circles
  if (
    enemy.slowed &&
    enemy.slowIntensity &&
    enemy.slowIntensity > 0 &&
    !enemy.frozen
  ) {
    const slowIntensity = Math.max(0.6, enemy.slowIntensity); // Minimum visibility
    const pulseAlpha = 0.8 + Math.sin(time * 4) * 0.2;

    // Purple aura glow underneath for visibility
    ctx.fillStyle = `rgba(147, 51, 234, ${0.35 * slowIntensity})`;
    ctx.beginPath();
    ctx.ellipse(screenPos.x, drawY, size * 0.85, size * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Outer magic circle - thick rotating ring
    ctx.save();
    ctx.translate(screenPos.x, drawY);
    ctx.rotate(time * 0.8);
    ctx.strokeStyle = `rgba(168, 85, 247, ${0.9 * slowIntensity * pulseAlpha})`;
    ctx.lineWidth = 3 * zoom;
    ctx.setLineDash([8 * zoom, 4 * zoom]);
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 0.8, size * 0.48, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

    // Inner magic circle - solid bright ring
    ctx.strokeStyle = `rgba(216, 180, 254, ${0.95 * slowIntensity})`;
    ctx.lineWidth = 2.5 * zoom;
    ctx.beginPath();
    ctx.ellipse(screenPos.x, drawY, size * 0.5, size * 0.3, 0, 0, Math.PI * 2);
    ctx.stroke();

    // 6 bright rune markers rotating around
    for (let i = 0; i < 6; i++) {
      const runeAngle = time * 0.8 + (i / 6) * Math.PI * 2;
      const rx = screenPos.x + Math.cos(runeAngle) * size * 0.78;
      const ry = drawY + Math.sin(runeAngle) * size * 0.47;
      
      // Bright rune diamond
      ctx.fillStyle = `rgba(233, 213, 255, ${0.95 * slowIntensity})`;
      ctx.beginPath();
      const runeSize = 4.5 * zoom;
      ctx.moveTo(rx, ry - runeSize);
      ctx.lineTo(rx + runeSize * 0.7, ry);
      ctx.lineTo(rx, ry + runeSize);
      ctx.lineTo(rx - runeSize * 0.7, ry);
      ctx.closePath();
      ctx.fill();
      
      // Rune outline for extra pop
      ctx.strokeStyle = `rgba(147, 51, 234, ${0.8 * slowIntensity})`;
      ctx.lineWidth = 1 * zoom;
      ctx.stroke();
    }

    // Bright floating particles
    for (let i = 0; i < 5; i++) {
      const pAngle = time * 2.5 + i * 1.26;
      const pDist = size * (0.4 + Math.sin(time * 1.8 + i) * 0.12);
      const px = screenPos.x + Math.cos(pAngle) * pDist;
      const py = drawY + Math.sin(pAngle) * pDist * 0.5 - size * 0.1;
      
      ctx.fillStyle = `rgba(216, 180, 254, ${0.9 * slowIntensity})`;
      ctx.beginPath();
      ctx.arc(px, py, 3 * zoom, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // STUNNED EFFECT - Orbiting stars with trails
  if (Date.now() < enemy.stunUntil && !enemy.frozen) {
    const orbitRadius = size * 0.5;
    
    // Draw 3 detailed stars orbiting
    for (let i = 0; i < 3; i++) {
      const baseAngle = time * 4 + (i / 3) * Math.PI * 2;
      
      // Star trail (3 fading copies behind)
      for (let t = 2; t >= 0; t--) {
        const trailAngle = baseAngle - t * 0.15;
        const trailAlpha = (1 - t * 0.3) * 0.5;
        const tx = screenPos.x + Math.cos(trailAngle) * orbitRadius * 0.7;
        const ty = drawY - size * 0.65 + Math.sin(trailAngle) * orbitRadius * 0.25;
        ctx.fillStyle = `rgba(255, 255, 100, ${trailAlpha})`;
        ctx.beginPath();
        ctx.arc(tx, ty, (2 - t * 0.4) * zoom, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Main star position
      const sx = screenPos.x + Math.cos(baseAngle) * orbitRadius * 0.7;
      const sy = drawY - size * 0.65 + Math.sin(baseAngle) * orbitRadius * 0.25;
      const starSize = 4 * zoom;
      
      // 4-pointed star shape
      ctx.fillStyle = "rgba(255, 255, 150, 0.95)";
      ctx.beginPath();
      ctx.moveTo(sx, sy - starSize);
      ctx.lineTo(sx + starSize * 0.3, sy - starSize * 0.3);
      ctx.lineTo(sx + starSize, sy);
      ctx.lineTo(sx + starSize * 0.3, sy + starSize * 0.3);
      ctx.lineTo(sx, sy + starSize);
      ctx.lineTo(sx - starSize * 0.3, sy + starSize * 0.3);
      ctx.lineTo(sx - starSize, sy);
      ctx.lineTo(sx - starSize * 0.3, sy - starSize * 0.3);
      ctx.closePath();
      ctx.fill();
      
      // Star center highlight
      ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
      ctx.beginPath();
      ctx.arc(sx, sy, starSize * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // GOLD AURA EFFECT - Floating coins (Gold Rush spell)
  if (enemy.goldAura) {
    // Draw floating coins orbiting around the enemy
    for (let i = 0; i < 5; i++) {
      const coinAngle = time * 2.5 + (i * Math.PI * 2 / 5);
      const coinOrbitX = Math.cos(coinAngle) * size * 1.0;
      const coinOrbitY = Math.sin(coinAngle) * size * 0.5; // Flattened for isometric
      const coinFloat = Math.sin(time * 4 + i * 1.2) * 6 * zoom; // Bobbing motion
      const coinX = screenPos.x + coinOrbitX;
      const coinY = drawY + coinOrbitY - 10 * zoom + coinFloat;
      const coinSize = 5 * zoom;
      
      // Coin body (gold)
      ctx.fillStyle = "#ffd700";
      ctx.beginPath();
      ctx.ellipse(coinX, coinY, coinSize, coinSize * 0.6, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Coin highlight
      ctx.fillStyle = "#fff8dc";
      ctx.beginPath();
      ctx.ellipse(coinX - coinSize * 0.2, coinY - coinSize * 0.15, coinSize * 0.4, coinSize * 0.25, -0.3, 0, Math.PI * 2);
      ctx.fill();
      
      // Coin edge/shadow
      ctx.strokeStyle = "#b8860b";
      ctx.lineWidth = 1.2 * zoom;
      ctx.beginPath();
      ctx.ellipse(coinX, coinY, coinSize, coinSize * 0.6, 0, 0, Math.PI * 2);
      ctx.stroke();
      
      // Dollar sign on coin
      ctx.fillStyle = "#b8860b";
      ctx.font = `bold ${coinSize * 0.8}px Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("$", coinX, coinY);
    }
    
    // Soft golden glow underneath
    const glowAlpha = 0.25 + Math.sin(time * 3) * 0.1;
    ctx.fillStyle = `rgba(255, 215, 0, ${glowAlpha})`;
    ctx.beginPath();
    ctx.ellipse(screenPos.x, drawY, size * 0.9, size * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // HP Bar
  if (enemy.hp < enemy.maxHp) {
    const barWidth = size * 1.3;
    const barHeight = 5 * zoom;
    const barY = drawY - size * 0.9;

    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(
      screenPos.x - barWidth / 2 - 1,
      barY - 1,
      barWidth + 2,
      barHeight + 2
    );
    ctx.fillStyle = "#333";
    ctx.fillRect(screenPos.x - barWidth / 2, barY, barWidth, barHeight);

    const hpPercent = enemy.hp / enemy.maxHp;
    // Enemies have red health bars
    const hpColor =
      hpPercent > 0.5 ? "#ef4444" : hpPercent > 0.25 ? "#dc2626" : "#b91c1c";
    ctx.fillStyle = hpColor;
    ctx.fillRect(
      screenPos.x - barWidth / 2,
      barY,
      barWidth * hpPercent,
      barHeight
    );
  }

  ctx.restore();
}

function drawEnemySprite(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  type: string,
  color: string,
  flash: number,
  time: number,
  isFlying: boolean,
  zoom: number,
  attackPhase: number = 0
) {
  const bodyColor = flash > 0 ? lightenColor(color, flash * 100) : color;
  const bodyColorDark = darkenColor(bodyColor, 30);
  const bodyColorLight = lightenColor(bodyColor, 20);

  // Draw different enemy types with unique epic designs
  switch (type) {
    case "freshman":
    case "frosh":
      drawFreshmanEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "sophomore":
      drawSophomoreEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "junior":
      drawJuniorEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "senior":
      drawSeniorEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "gradstudent":
      drawGradStudentEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "professor":
      drawProfessorEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "dean":
      drawDeanEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "trustee":
      drawTrusteeEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "mascot":
      drawMascotEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        isFlying,
        attackPhase
      );
      break;
    case "archer":
      drawArcherEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "mage":
      drawMageEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "catapult":
      drawCatapultEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    // New ranged enemies
    case "warlock":
      drawWarlockEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "crossbowman":
      drawCrossbowmanEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "hexer":
      drawHexerEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    // New flying enemies
    case "harpy":
      drawHarpyEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "wyvern":
      drawWyvernEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "specter":
      drawSpecterEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    // New ground enemies
    case "berserker":
      drawBerserkerEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "golem":
      drawGolemEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "necromancer":
      drawNecromancerEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    case "shadow_knight":
      drawShadowKnightEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
      break;
    default:
      drawDefaultEnemy(
        ctx,
        x,
        y,
        size,
        bodyColor,
        bodyColorDark,
        bodyColorLight,
        time,
        zoom,
        attackPhase
      );
  }
}

function drawFreshmanEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // CORRUPTED NEOPHYTE - Possessed first-year consumed by eldritch knowledge
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const bobble = Math.sin(time * 6) * 2 * zoom + (isAttacking ? attackIntensity * size * 0.15 : 0);
  const pulseIntensity = 0.5 + Math.sin(time * 4) * 0.3 + attackIntensity * 0.3;
  const runeGlow = 0.6 + Math.sin(time * 5) * 0.4 + attackIntensity * 0.4;
  const corruptionPulse = 0.4 + Math.sin(time * 7) * 0.3 + attackIntensity * 0.3;
  const chainsRattle = Math.sin(time * 8) * size * 0.02 + (isAttacking ? Math.sin(attackPhase * Math.PI * 4) * size * 0.04 : 0);

  // Void distortion field
  ctx.strokeStyle = `rgba(0, 20, 0, ${pulseIntensity * 0.3})`;
  ctx.lineWidth = 2 * zoom;
  for (let i = 0; i < 4; i++) {
    const distortPhase = (time * 0.8 + i * 0.3) % 2;
    const distortSize = size * 0.3 + distortPhase * size * 0.4;
    ctx.globalAlpha = 0.4 * (1 - distortPhase / 2);
    ctx.beginPath();
    for (let a = 0; a < Math.PI * 2; a += 0.15) {
      const r = distortSize + Math.sin(a * 5 + time * 4) * size * 0.04;
      const wx = x + Math.cos(a) * r;
      const wy = y + Math.sin(a) * r * 0.7;
      if (a === 0) ctx.moveTo(wx, wy);
      else ctx.lineTo(wx, wy);
    }
    ctx.closePath();
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Dark corruption aura with inner darkness
  const auraGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.8);
  auraGrad.addColorStop(0, `rgba(20, 80, 20, ${pulseIntensity * 0.35})`);
  auraGrad.addColorStop(0.3, `rgba(74, 222, 128, ${pulseIntensity * 0.2})`);
  auraGrad.addColorStop(0.6, `rgba(34, 197, 94, ${pulseIntensity * 0.1})`);
  auraGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.8, 0, Math.PI * 2);
  ctx.fill();

  // Floating corruption particles with trails
  for (let i = 0; i < 8; i++) {
    const particleAngle = time * 2 + i * Math.PI * 0.25;
    const particleDist = size * 0.45 + Math.sin(time * 3 + i) * size * 0.12;
    const px = x + Math.cos(particleAngle) * particleDist;
    const py = y - size * 0.1 + Math.sin(particleAngle) * particleDist * 0.4;
    // Trail
    ctx.strokeStyle = `rgba(74, 222, 128, ${0.2})`;
    ctx.lineWidth = 1 * zoom;
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(px + Math.cos(particleAngle + Math.PI) * size * 0.08, py + Math.sin(particleAngle + Math.PI) * size * 0.04);
    ctx.stroke();
    // Particle core
    ctx.fillStyle = `rgba(74, 222, 128, ${0.5 + Math.sin(time * 5 + i) * 0.3})`;
    ctx.shadowColor = "#4ade80";
    ctx.shadowBlur = 4 * zoom;
    ctx.beginPath();
    ctx.arc(px, py, size * 0.02 + Math.sin(time * 6 + i) * size * 0.008, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Eldritch tentacles emerging from ground
  ctx.strokeStyle = `rgba(30, 80, 30, ${corruptionPulse * 0.7})`;
  ctx.lineWidth = 3 * zoom;
  for (let i = 0; i < 4; i++) {
    const tentacleAngle = -Math.PI * 0.8 + i * Math.PI * 0.4 + Math.sin(time * 2) * 0.1;
    ctx.beginPath();
    ctx.moveTo(x + Math.cos(tentacleAngle) * size * 0.35, y + size * 0.48);
    ctx.quadraticCurveTo(
      x + Math.cos(tentacleAngle) * size * 0.45 + Math.sin(time * 3 + i) * size * 0.08,
      y + size * 0.25,
      x + Math.cos(tentacleAngle) * size * 0.3 + Math.sin(time * 4 + i) * size * 0.1,
      y + size * 0.1 + Math.sin(time * 5 + i) * size * 0.05
    );
    ctx.stroke();
    // Tentacle tip
    ctx.fillStyle = `rgba(74, 222, 128, ${corruptionPulse})`;
    ctx.beginPath();
    ctx.arc(
      x + Math.cos(tentacleAngle) * size * 0.3 + Math.sin(time * 4 + i) * size * 0.1,
      y + size * 0.1 + Math.sin(time * 5 + i) * size * 0.05,
      size * 0.015,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  // Shadow beneath with corruption seepage
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.48, 0, x, y + size * 0.48, size * 0.35);
  shadowGrad.addColorStop(0, "rgba(20, 60, 20, 0.6)");
  shadowGrad.addColorStop(0.5, "rgba(0, 0, 0, 0.4)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.48, size * 0.35, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  // Floating forbidden tome (behind) - more ornate
  ctx.save();
  ctx.translate(x - size * 0.38, y - size * 0.15 + Math.sin(time * 3) * 4);
  ctx.rotate(Math.sin(time * 2) * 0.15);
  // Book shadow
  ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
  ctx.fillRect(-size * 0.11, -size * 0.13, size * 0.24, size * 0.3);
  // Leather cover with metal corners
  ctx.fillStyle = "#0a1a0a";
  ctx.fillRect(-size * 0.13, -size * 0.16, size * 0.26, size * 0.32);
  ctx.fillStyle = "#1a2a1a";
  ctx.fillRect(-size * 0.11, -size * 0.14, size * 0.22, size * 0.28);
  // Metal corner plates
  ctx.fillStyle = "#3a5a3a";
  ctx.fillRect(-size * 0.13, -size * 0.16, size * 0.05, size * 0.05);
  ctx.fillRect(size * 0.08, -size * 0.16, size * 0.05, size * 0.05);
  ctx.fillRect(-size * 0.13, size * 0.11, size * 0.05, size * 0.05);
  ctx.fillRect(size * 0.08, size * 0.11, size * 0.05, size * 0.05);
  // Glowing pages with pulsing light
  ctx.fillStyle = `rgba(74, 222, 128, ${runeGlow * 0.4})`;
  ctx.fillRect(-size * 0.09, -size * 0.1, size * 0.18, size * 0.2);
  // Ancient eldritch runes
  ctx.fillStyle = `rgba(74, 222, 128, ${runeGlow})`;
  ctx.shadowColor = "#4ade80";
  ctx.shadowBlur = 6 * zoom;
  ctx.font = `${size * 0.07}px serif`;
  ctx.textAlign = "center";
  ctx.fillText("", 0, -size * 0.02);
  ctx.fillText("", 0, size * 0.06);
  ctx.shadowBlur = 0;
  // Floating pages
  for (let p = 0; p < 3; p++) {
    const pageAngle = time * 1.5 + p * Math.PI * 0.6;
    const pageX = Math.cos(pageAngle) * size * 0.15;
    const pageY = Math.sin(pageAngle) * size * 0.08 - size * 0.05;
    ctx.fillStyle = `rgba(200, 230, 200, ${0.4 + Math.sin(time * 4 + p) * 0.2})`;
    ctx.save();
    ctx.translate(pageX, pageY);
    ctx.rotate(Math.sin(time * 3 + p) * 0.3);
    ctx.fillRect(-size * 0.03, -size * 0.04, size * 0.06, size * 0.08);
    ctx.restore();
  }
  ctx.restore();

  // Ethereal chains binding the initiate
  ctx.strokeStyle = `rgba(74, 222, 128, ${corruptionPulse * 0.5})`;
  ctx.lineWidth = 2 * zoom;
  for (let c = 0; c < 2; c++) {
    const chainSide = c === 0 ? -1 : 1;
    ctx.beginPath();
    for (let link = 0; link < 6; link++) {
      const linkX = x + chainSide * (size * 0.2 + link * size * 0.05) + chainsRattle * chainSide;
      const linkY = y - size * 0.1 + Math.sin(time * 4 + link * 0.5) * size * 0.02;
      ctx.arc(linkX, linkY, size * 0.015, 0, Math.PI * 2);
    }
    ctx.stroke();
  }

  // Tattered robes with corruption spreading
  const robeGrad = ctx.createLinearGradient(x - size * 0.35, y - size * 0.3, x + size * 0.35, y + size * 0.5);
  robeGrad.addColorStop(0, "#1a3a1a");
  robeGrad.addColorStop(0.2, "#2a5a2a");
  robeGrad.addColorStop(0.4, "#3a7a3a");
  robeGrad.addColorStop(0.6, "#4a9a4a");
  robeGrad.addColorStop(0.8, "#3a7a3a");
  robeGrad.addColorStop(1, "#1a3a1a");
  ctx.fillStyle = robeGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.35, y + size * 0.48);
  ctx.quadraticCurveTo(x - size * 0.42, y - size * 0.08, x - size * 0.18, y - size * 0.32);
  ctx.lineTo(x + size * 0.18, y - size * 0.32);
  ctx.quadraticCurveTo(x + size * 0.42, y - size * 0.08, x + size * 0.35, y + size * 0.48);
  // More dramatic tattered bottom
  for (let i = 0; i < 8; i++) {
    const jagX = x - size * 0.35 + i * size * 0.1;
    const jagY = y + size * 0.48 + Math.sin(time * 4 + i * 1.3) * size * 0.04 + (i % 2) * size * 0.06 + (i % 3) * size * 0.03;
    ctx.lineTo(jagX, jagY);
  }
  ctx.closePath();
  ctx.fill();

  // Corruption veins spreading across robe
  ctx.strokeStyle = `rgba(74, 222, 128, ${pulseIntensity * 0.7})`;
  ctx.lineWidth = 2 * zoom;
  for (let v = 0; v < 6; v++) {
    const veinStartX = x - size * 0.25 + v * size * 0.1;
    const veinStartY = y - size * 0.2 + Math.sin(v) * size * 0.1;
    ctx.beginPath();
    ctx.moveTo(veinStartX, veinStartY);
    ctx.quadraticCurveTo(
      veinStartX + Math.sin(time * 2 + v) * size * 0.08,
      veinStartY + size * 0.15,
      veinStartX + Math.cos(v) * size * 0.1,
      y + size * 0.35
    );
    ctx.stroke();
    // Vein nodes
    ctx.fillStyle = `rgba(74, 222, 128, ${corruptionPulse})`;
    ctx.beginPath();
    ctx.arc(veinStartX + Math.cos(v) * size * 0.05, veinStartY + size * 0.1, size * 0.01, 0, Math.PI * 2);
    ctx.fill();
  }

  // Arcane symbols on robe
  ctx.fillStyle = `rgba(100, 255, 150, ${runeGlow * 0.6})`;
  ctx.font = `${size * 0.06}px serif`;
  ctx.textAlign = "center";
  ctx.fillText("", x - size * 0.12, y + size * 0.05);
  ctx.fillText("", x + size * 0.12, y + size * 0.15);
  ctx.fillText("", x, y + size * 0.28);

  // Hood casting deep shadow with corruption dripping
  ctx.fillStyle = "#0a1a0a";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.35 + bobble * 0.3, size * 0.28, size * 0.2, 0, Math.PI, 0);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x - size * 0.28, y - size * 0.35 + bobble * 0.3);
  ctx.quadraticCurveTo(x - size * 0.34, y - size * 0.12, x - size * 0.26, y + size * 0.08);
  ctx.lineTo(x - size * 0.18, y - size * 0.18);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.28, y - size * 0.35 + bobble * 0.3);
  ctx.quadraticCurveTo(x + size * 0.34, y - size * 0.12, x + size * 0.26, y + size * 0.08);
  ctx.lineTo(x + size * 0.18, y - size * 0.18);
  ctx.fill();

  // Face (pale, gaunt, corrupted)
  const faceGrad = ctx.createRadialGradient(x, y - size * 0.4 + bobble, 0, x, y - size * 0.4 + bobble, size * 0.22);
  faceGrad.addColorStop(0, "#d0f0d0");
  faceGrad.addColorStop(0.6, "#a8d8a8");
  faceGrad.addColorStop(1, "#80b080");
  ctx.fillStyle = faceGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.4 + bobble, size * 0.2, 0, Math.PI * 2);
  ctx.fill();

  // Corruption spreading across face
  ctx.strokeStyle = "#2a6a2a";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.14, y - size * 0.32 + bobble);
  ctx.quadraticCurveTo(x - size * 0.1, y - size * 0.28 + bobble, x - size * 0.06, y - size * 0.24 + bobble);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.12, y - size * 0.36 + bobble);
  ctx.quadraticCurveTo(x + size * 0.14, y - size * 0.3 + bobble, x + size * 0.1, y - size * 0.26 + bobble);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x - size * 0.02, y - size * 0.54 + bobble);
  ctx.quadraticCurveTo(x + size * 0.04, y - size * 0.48 + bobble, x + size * 0.02, y - size * 0.42 + bobble);
  ctx.stroke();

  // Possessed glowing eyes with void pupils
  ctx.fillStyle = "#4ade80";
  ctx.shadowColor = "#4ade80";
  ctx.shadowBlur = 12 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.07, y - size * 0.42 + bobble, size * 0.045, 0, Math.PI * 2);
  ctx.arc(x + size * 0.07, y - size * 0.42 + bobble, size * 0.045, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Void center pupils
  ctx.fillStyle = "#001000";
  ctx.beginPath();
  ctx.arc(x - size * 0.07, y - size * 0.42 + bobble, size * 0.018, 0, Math.PI * 2);
  ctx.arc(x + size * 0.07, y - size * 0.42 + bobble, size * 0.018, 0, Math.PI * 2);
  ctx.fill();
  // Eye reflection
  ctx.fillStyle = "rgba(200, 255, 200, 0.6)";
  ctx.beginPath();
  ctx.arc(x - size * 0.08, y - size * 0.44 + bobble, size * 0.01, 0, Math.PI * 2);
  ctx.arc(x + size * 0.06, y - size * 0.44 + bobble, size * 0.01, 0, Math.PI * 2);
  ctx.fill();

  // Grimacing mouth with sharp fangs
  ctx.fillStyle = "#0a1a0a";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.28 + bobble, size * 0.07, size * 0.035, 0, 0, Math.PI * 2);
  ctx.fill();
  // Upper fangs
  ctx.fillStyle = "#e8f8e8";
  for (let f = 0; f < 4; f++) {
    ctx.beginPath();
    ctx.moveTo(x - size * 0.04 + f * size * 0.027, y - size * 0.29 + bobble);
    ctx.lineTo(x - size * 0.035 + f * size * 0.027, y - size * 0.24 + bobble);
    ctx.lineTo(x - size * 0.03 + f * size * 0.027, y - size * 0.29 + bobble);
    ctx.fill();
  }

  // Magical energy swirling from both hands
  for (let hand = 0; hand < 2; hand++) {
    const handX = x + (hand === 0 ? -1 : 1) * size * 0.28;
    const handY = y + size * 0.08;
    // Energy orb
    ctx.fillStyle = `rgba(74, 222, 128, ${pulseIntensity * 0.8})`;
    ctx.shadowColor = "#4ade80";
    ctx.shadowBlur = 10 * zoom;
    ctx.beginPath();
    ctx.arc(handX, handY, size * 0.06, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    // Expanding rings
    ctx.strokeStyle = `rgba(74, 222, 128, ${pulseIntensity})`;
    ctx.lineWidth = 1.5 * zoom;
    for (let ring = 0; ring < 4; ring++) {
      const ringPhase = (time * 2.5 + ring * 0.25) % 1;
      ctx.globalAlpha = 1 - ringPhase;
      ctx.beginPath();
      ctx.arc(handX, handY, size * 0.04 + ringPhase * size * 0.18, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  // Eldritch sigil above head
  ctx.save();
  ctx.translate(x, y - size * 0.65 + bobble + Math.sin(time * 2) * size * 0.02);
  ctx.rotate(time * 0.5);
  ctx.strokeStyle = `rgba(74, 222, 128, ${runeGlow * 0.6})`;
  ctx.lineWidth = 1.5 * zoom;
  // Outer ring
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.08, 0, Math.PI * 2);
  ctx.stroke();
  // Inner triangle
  ctx.beginPath();
  for (let i = 0; i < 3; i++) {
    const angle = i * Math.PI * 2 / 3 - Math.PI / 2;
    if (i === 0) ctx.moveTo(Math.cos(angle) * size * 0.05, Math.sin(angle) * size * 0.05);
    else ctx.lineTo(Math.cos(angle) * size * 0.05, Math.sin(angle) * size * 0.05);
  }
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}

function drawSophomoreEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // STORM APPRENTICE - Arrogant spellcaster channeling tempest magic with crackling lightning
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const swagger = Math.sin(time * 5) * 3 * zoom + (isAttacking ? attackIntensity * size * 0.12 : 0);
  const magicPulse = 0.6 + Math.sin(time * 4) * 0.4 + attackIntensity * 0.4;
  const stormIntensity = 0.5 + Math.sin(time * 6) * 0.3 + attackIntensity * 0.5;
  const lightningFlash = (Math.random() > 0.95 || isAttacking) ? (isAttacking ? attackIntensity : 1) : 0;

  // Storm vortex aura
  ctx.save();
  for (let ring = 0; ring < 5; ring++) {
    const ringPhase = (time * 1.5 + ring * 0.3) % 2;
    const ringSize = size * 0.3 + ring * size * 0.12;
    ctx.strokeStyle = `rgba(96, 165, 250, ${(0.3 - ring * 0.05) * magicPulse})`;
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.arc(x, y, ringSize, time * 2 + ring, time * 2 + ring + Math.PI * 1.5);
    ctx.stroke();
  }
  ctx.restore();

  // Blue elemental aura with storm effects
  const auraGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.8);
  auraGrad.addColorStop(0, `rgba(59, 130, 246, ${magicPulse * 0.35})`);
  auraGrad.addColorStop(0.3, `rgba(96, 165, 250, ${magicPulse * 0.25})`);
  auraGrad.addColorStop(0.6, `rgba(147, 197, 253, ${magicPulse * 0.15})`);
  auraGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.8, 0, Math.PI * 2);
  ctx.fill();

  // Lightning bolts crackling around
  if (lightningFlash || Math.sin(time * 15) > 0.8) {
    ctx.strokeStyle = `rgba(255, 255, 255, ${0.7 + Math.random() * 0.3})`;
    ctx.lineWidth = 2 * zoom;
    for (let bolt = 0; bolt < 2; bolt++) {
      const boltAngle = time * 3 + bolt * Math.PI;
      const startX = x + Math.cos(boltAngle) * size * 0.4;
      const startY = y - size * 0.3 + Math.sin(boltAngle) * size * 0.2;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      let bx = startX, by = startY;
      for (let seg = 0; seg < 4; seg++) {
        bx += (Math.random() - 0.5) * size * 0.15;
        by += size * 0.08;
        ctx.lineTo(bx, by);
      }
      ctx.stroke();
    }
  }

  // Floating arcane symbols with enhanced glow
  for (let i = 0; i < 6; i++) {
    const symbolAngle = time * 1.5 + i * Math.PI * 0.33;
    const symbolDist = size * 0.5 + Math.sin(time * 2 + i) * size * 0.05;
    const sx = x + Math.cos(symbolAngle) * symbolDist;
    const sy = y - size * 0.1 + Math.sin(symbolAngle) * symbolDist * 0.35;
    ctx.fillStyle = `rgba(147, 197, 253, ${0.5 + Math.sin(time * 4 + i) * 0.3})`;
    ctx.shadowColor = "#60a5fa";
    ctx.shadowBlur = 6 * zoom;
    ctx.font = `${size * 0.1}px serif`;
    ctx.textAlign = "center";
    ctx.fillText(["", "", "", "", "", ""][i], sx, sy);
    ctx.shadowBlur = 0;
  }

  // Storm cloud wisps
  for (let w = 0; w < 4; w++) {
    const wispX = x + Math.sin(time * 1.5 + w * 1.5) * size * 0.35;
    const wispY = y - size * 0.5 + Math.cos(time * 1.2 + w) * size * 0.1;
    ctx.fillStyle = `rgba(100, 130, 170, ${0.3 + Math.sin(time * 3 + w) * 0.15})`;
    ctx.beginPath();
    ctx.ellipse(wispX, wispY, size * 0.08, size * 0.04, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Shadow with electrical discharge
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.48, 0, x, y + size * 0.48, size * 0.35);
  shadowGrad.addColorStop(0, "rgba(30, 58, 95, 0.5)");
  shadowGrad.addColorStop(0.5, "rgba(0, 0, 0, 0.35)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.48, size * 0.35, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  // Flowing apprentice robes with storm patterns
  const robeGrad = ctx.createLinearGradient(x - size * 0.4, y - size * 0.3, x + size * 0.4, y + size * 0.5);
  robeGrad.addColorStop(0, "#0c1929");
  robeGrad.addColorStop(0.2, "#1e3a5f");
  robeGrad.addColorStop(0.4, "#2563eb");
  robeGrad.addColorStop(0.5, "#3b82f6");
  robeGrad.addColorStop(0.6, "#2563eb");
  robeGrad.addColorStop(0.8, "#1e3a5f");
  robeGrad.addColorStop(1, "#0c1929");
  ctx.fillStyle = robeGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.38, y + size * 0.5);
  ctx.quadraticCurveTo(x - size * 0.44, y, x - size * 0.22, y - size * 0.32 + swagger * 0.2);
  ctx.lineTo(x + size * 0.22, y - size * 0.32 + swagger * 0.2);
  ctx.quadraticCurveTo(x + size * 0.44, y, x + size * 0.38, y + size * 0.5);
  // Dramatic flowing bottom
  for (let i = 0; i < 7; i++) {
    const waveX = x - size * 0.38 + i * size * 0.1267;
    const waveY = y + size * 0.5 + Math.sin(time * 4 + i) * size * 0.04 + (i % 2) * size * 0.03;
    ctx.lineTo(waveX, waveY);
  }
  ctx.closePath();
  ctx.fill();

  // Lightning patterns on robe
  ctx.strokeStyle = `rgba(147, 197, 253, ${stormIntensity * 0.6})`;
  ctx.lineWidth = 1.5 * zoom;
  for (let p = 0; p < 4; p++) {
    const startX = x - size * 0.2 + p * size * 0.13;
    ctx.beginPath();
    ctx.moveTo(startX, y - size * 0.15);
    let px = startX;
    for (let seg = 0; seg < 3; seg++) {
      px += (Math.random() - 0.5) * size * 0.06;
      ctx.lineTo(px, y + seg * size * 0.12);
    }
    ctx.stroke();
  }

  // Ornate silver trim with gems
  ctx.strokeStyle = "#e0e7ff";
  ctx.lineWidth = 3 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.14, y - size * 0.28 + swagger * 0.2);
  ctx.lineTo(x - size * 0.17, y + size * 0.38);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.14, y - size * 0.28 + swagger * 0.2);
  ctx.lineTo(x + size * 0.17, y + size * 0.38);
  ctx.stroke();
  // Gem on trim
  ctx.fillStyle = "#60a5fa";
  ctx.shadowColor = "#60a5fa";
  ctx.shadowBlur = 6 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.155, y + size * 0.1, size * 0.025, 0, Math.PI * 2);
  ctx.arc(x + size * 0.155, y + size * 0.1, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Apprentice sash with arcane embroidery
  const sashGrad = ctx.createLinearGradient(x - size * 0.25, y - size * 0.1, x + size * 0.25, y);
  sashGrad.addColorStop(0, "#b8860b");
  sashGrad.addColorStop(0.5, "#fbbf24");
  sashGrad.addColorStop(1, "#b8860b");
  ctx.fillStyle = sashGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.28, y - size * 0.12);
  ctx.quadraticCurveTo(x, y + size * 0.08, x + size * 0.28, y - size * 0.12);
  ctx.lineTo(x + size * 0.25, y + size * 0.02);
  ctx.quadraticCurveTo(x, y + size * 0.18, x - size * 0.25, y + size * 0.02);
  ctx.fill();
  // Sash emblem
  ctx.fillStyle = "#1e3a5f";
  ctx.font = `${size * 0.08}px serif`;
  ctx.textAlign = "center";
  ctx.fillText("", x, y);

  // Confident face with magical features
  const faceGrad = ctx.createRadialGradient(x, y - size * 0.44 + swagger * 0.15, 0, x, y - size * 0.44 + swagger * 0.15, size * 0.24);
  faceGrad.addColorStop(0, "#fde8d8");
  faceGrad.addColorStop(0.7, "#fcd9b6");
  faceGrad.addColorStop(1, "#e5c4a0");
  ctx.fillStyle = faceGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.44 + swagger * 0.15, size * 0.23, 0, Math.PI * 2);
  ctx.fill();

  // Stylish swept hair with magical highlights
  ctx.fillStyle = "#0f172a";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.22, y - size * 0.54 + swagger * 0.15);
  ctx.quadraticCurveTo(x - size * 0.35, y - size * 0.75, x - size * 0.05, y - size * 0.72 + swagger * 0.15);
  ctx.quadraticCurveTo(x + size * 0.18, y - size * 0.78, x + size * 0.28, y - size * 0.62 + swagger * 0.15);
  ctx.quadraticCurveTo(x + size * 0.25, y - size * 0.5, x + size * 0.2, y - size * 0.52 + swagger * 0.15);
  ctx.lineTo(x - size * 0.2, y - size * 0.52 + swagger * 0.15);
  ctx.fill();
  // Magical blue streaks in hair
  ctx.strokeStyle = "#60a5fa";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.1, y - size * 0.64 + swagger * 0.15);
  ctx.quadraticCurveTo(x + size * 0.08, y - size * 0.72, x + size * 0.2, y - size * 0.64 + swagger * 0.15);
  ctx.stroke();
  ctx.strokeStyle = "#93c5fd";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.02, y - size * 0.68 + swagger * 0.15);
  ctx.quadraticCurveTo(x + size * 0.12, y - size * 0.74, x + size * 0.22, y - size * 0.58 + swagger * 0.15);
  ctx.stroke();

  // Confident glowing eyes with storm power
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.085, y - size * 0.46 + swagger * 0.15, size * 0.06, size * 0.07, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.085, y - size * 0.46 + swagger * 0.15, size * 0.06, size * 0.07, 0, 0, Math.PI * 2);
  ctx.fill();
  // Electric blue magical pupils
  ctx.fillStyle = "#3b82f6";
  ctx.shadowColor = "#60a5fa";
  ctx.shadowBlur = 8 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.085, y - size * 0.46 + swagger * 0.15, size * 0.035, 0, Math.PI * 2);
  ctx.arc(x + size * 0.085, y - size * 0.46 + swagger * 0.15, size * 0.035, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Inner spark
  ctx.fillStyle = "#dbeafe";
  ctx.beginPath();
  ctx.arc(x - size * 0.095, y - size * 0.475 + swagger * 0.15, size * 0.012, 0, Math.PI * 2);
  ctx.arc(x + size * 0.075, y - size * 0.475 + swagger * 0.15, size * 0.012, 0, Math.PI * 2);
  ctx.fill();

  // Cocky raised eyebrow
  ctx.strokeStyle = "#0f172a";
  ctx.lineWidth = 3 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.16, y - size * 0.54 + swagger * 0.15);
  ctx.quadraticCurveTo(x - size * 0.09, y - size * 0.58, x - size * 0.02, y - size * 0.52 + swagger * 0.15);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.02, y - size * 0.54 + swagger * 0.15);
  ctx.quadraticCurveTo(x + size * 0.11, y - size * 0.6, x + size * 0.16, y - size * 0.52 + swagger * 0.15);
  ctx.stroke();

  // Smug smirk
  ctx.strokeStyle = "#92400e";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.07, y - size * 0.32 + swagger * 0.15);
  ctx.quadraticCurveTo(x + size * 0.02, y - size * 0.27, x + size * 0.1, y - size * 0.35 + swagger * 0.15);
  ctx.stroke();

  // Massive glowing storm orb in hand
  ctx.fillStyle = `rgba(59, 130, 246, ${magicPulse * 0.9})`;
  ctx.shadowColor = "#3b82f6";
  ctx.shadowBlur = 18 * zoom;
  ctx.beginPath();
  ctx.arc(x + size * 0.42, y + swagger * 0.1, size * 0.13, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Inner storm core
  ctx.fillStyle = "#dbeafe";
  ctx.beginPath();
  ctx.arc(x + size * 0.42, y + swagger * 0.1, size * 0.05, 0, Math.PI * 2);
  ctx.fill();
  // Mini lightning in orb
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 1.5 * zoom;
  for (let l = 0; l < 3; l++) {
    const lAngle = time * 8 + l * Math.PI * 0.67;
    ctx.beginPath();
    ctx.moveTo(x + size * 0.42, y + swagger * 0.1);
    ctx.lineTo(
      x + size * 0.42 + Math.cos(lAngle) * size * 0.1,
      y + swagger * 0.1 + Math.sin(lAngle) * size * 0.1
    );
    ctx.stroke();
  }
  // Energy rings around orb
  ctx.strokeStyle = `rgba(147, 197, 253, ${magicPulse})`;
  ctx.lineWidth = 2 * zoom;
  for (let i = 0; i < 4; i++) {
    const wispAngle = time * 5 + i * Math.PI * 0.5;
    ctx.beginPath();
    ctx.arc(x + size * 0.42, y + swagger * 0.1, size * 0.15 + i * size * 0.03, wispAngle, wispAngle + Math.PI * 0.6);
    ctx.stroke();
  }

  // Secondary spell forming in other hand
  ctx.fillStyle = `rgba(147, 197, 253, ${stormIntensity * 0.6})`;
  ctx.shadowColor = "#93c5fd";
  ctx.shadowBlur = 8 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.35, y + size * 0.1 + swagger * 0.05, size * 0.06, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
}

function drawJuniorEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // MAD ARCHIVIST - Scholar driven insane by forbidden knowledge, reality tears around them
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const twitch = Math.sin(time * 8) * 2 * zoom + Math.sin(time * 13) * 1 * zoom + (isAttacking ? attackIntensity * size * 0.15 : 0);
  const madnessPulse = 0.5 + Math.sin(time * 5) * 0.3 + attackIntensity * 0.4;
  const bookFloat = Math.sin(time * 2) * 4 + (isAttacking ? attackIntensity * 8 : 0);
  const realityTear = 0.4 + Math.sin(time * 7) * 0.3 + attackIntensity * 0.4;
  const eyeSpasm = Math.sin(time * 15) * size * 0.01 + (isAttacking ? Math.sin(attackPhase * Math.PI * 6) * size * 0.02 : 0);

  // Reality fractures around the scholar
  ctx.strokeStyle = `rgba(147, 51, 234, ${realityTear * 0.4})`;
  ctx.lineWidth = 2 * zoom;
  for (let f = 0; f < 5; f++) {
    const fractureAngle = time * 0.5 + f * Math.PI * 0.4;
    const fractureLen = size * (0.3 + Math.sin(time * 2 + f) * 0.1);
    ctx.beginPath();
    ctx.moveTo(x + Math.cos(fractureAngle) * size * 0.3, y + Math.sin(fractureAngle) * size * 0.2);
    for (let seg = 0; seg < 4; seg++) {
      const segX = x + Math.cos(fractureAngle) * (size * 0.3 + seg * fractureLen * 0.25) + (Math.random() - 0.5) * size * 0.05;
      const segY = y + Math.sin(fractureAngle) * (size * 0.2 + seg * fractureLen * 0.15);
      ctx.lineTo(segX, segY);
    }
    ctx.stroke();
  }

  // Purple madness aura with void tendrils
  const auraGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.85);
  auraGrad.addColorStop(0, `rgba(139, 92, 246, ${madnessPulse * 0.35})`);
  auraGrad.addColorStop(0.3, `rgba(192, 132, 252, ${madnessPulse * 0.25})`);
  auraGrad.addColorStop(0.6, `rgba(147, 51, 234, ${madnessPulse * 0.15})`);
  auraGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.85, 0, Math.PI * 2);
  ctx.fill();

  // Floating ancient tomes orbiting with chains
  for (let i = 0; i < 5; i++) {
    const bookAngle = time * 1.2 + i * Math.PI * 0.4;
    const bookDist = size * 0.55 + Math.sin(time * 1.5 + i) * size * 0.08;
    const bx = x + Math.cos(bookAngle) * bookDist;
    const by = y - size * 0.08 + Math.sin(bookAngle) * bookDist * 0.35 + bookFloat;
    
    // Ethereal chain to book
    ctx.strokeStyle = `rgba(147, 51, 234, ${madnessPulse * 0.4})`;
    ctx.lineWidth = 1 * zoom;
    ctx.beginPath();
    ctx.moveTo(x, y - size * 0.2);
    ctx.quadraticCurveTo(
      x + Math.cos(bookAngle) * bookDist * 0.5,
      y - size * 0.1 + Math.sin(bookAngle) * bookDist * 0.2,
      bx, by
    );
    ctx.stroke();
    
    ctx.save();
    ctx.translate(bx, by);
    ctx.rotate(Math.sin(time * 2.5 + i) * 0.25);
    // Ornate book cover
    ctx.fillStyle = ["#2a0a3a", "#0a1a3a", "#3a0a2a", "#1a0a2a", "#0a2a1a"][i];
    ctx.fillRect(-size * 0.07, -size * 0.09, size * 0.14, size * 0.18);
    // Metal clasp
    ctx.fillStyle = "#8b5cf6";
    ctx.fillRect(-size * 0.075, -size * 0.02, size * 0.015, size * 0.04);
    // Aged pages
    ctx.fillStyle = "#fef9c3";
    ctx.fillRect(-size * 0.055, -size * 0.075, size * 0.11, size * 0.15);
    // Glowing forbidden runes
    ctx.fillStyle = `rgba(192, 132, 252, ${madnessPulse})`;
    ctx.shadowColor = "#a855f7";
    ctx.shadowBlur = 4 * zoom;
    ctx.font = `${size * 0.055}px serif`;
    ctx.textAlign = "center";
    ctx.fillText(["", "", "", "", ""][i], 0, size * 0.015);
    ctx.shadowBlur = 0;
    ctx.restore();
  }

  // Knowledge tendrils - eldritch whispers made visible
  ctx.strokeStyle = `rgba(147, 51, 234, ${madnessPulse * 0.6})`;
  ctx.lineWidth = 2.5 * zoom;
  for (let i = 0; i < 7; i++) {
    const tendrilAngle = -Math.PI * 0.7 + i * Math.PI * 0.2;
    const tendrilPhase = time * 3 + i * 0.5;
    ctx.beginPath();
    ctx.moveTo(x + Math.cos(tendrilAngle) * size * 0.18, y - size * 0.52 + twitch * 0.3);
    ctx.bezierCurveTo(
      x + Math.cos(tendrilAngle) * size * 0.35 + Math.sin(tendrilPhase) * size * 0.12,
      y - size * 0.65 - i * size * 0.04,
      x + Math.cos(tendrilAngle + 0.2) * size * 0.45 + Math.cos(tendrilPhase * 1.5) * size * 0.08,
      y - size * 0.75 + Math.sin(tendrilPhase * 0.7) * size * 0.08,
      x + Math.cos(tendrilAngle) * size * 0.5,
      y - size * 0.85 + Math.sin(tendrilPhase) * size * 0.12
    );
    ctx.stroke();
    // Tendril tip glow
    ctx.fillStyle = `rgba(192, 132, 252, ${madnessPulse})`;
    ctx.beginPath();
    ctx.arc(
      x + Math.cos(tendrilAngle) * size * 0.5,
      y - size * 0.85 + Math.sin(tendrilPhase) * size * 0.12,
      size * 0.015,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  // Floating text fragments - whispered secrets
  ctx.fillStyle = `rgba(192, 132, 252, ${madnessPulse * 0.5})`;
  ctx.font = `${size * 0.04}px serif`;
  for (let t = 0; t < 6; t++) {
    const textX = x + Math.sin(time * 1.5 + t * 1.2) * size * 0.5;
    const textY = y - size * 0.2 + Math.cos(time * 0.8 + t) * size * 0.3;
    ctx.save();
    ctx.translate(textX, textY);
    ctx.rotate(Math.sin(time * 2 + t) * 0.3);
    ctx.fillText(["truth", "void", "KNOW", "see", "END", ""][t], 0, 0);
    ctx.restore();
  }

  // Shadow with madness seeping out
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.5, 0, x, y + size * 0.5, size * 0.4);
  shadowGrad.addColorStop(0, "rgba(59, 7, 100, 0.5)");
  shadowGrad.addColorStop(0.5, "rgba(0, 0, 0, 0.4)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.5, size * 0.38, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  // Disheveled scholar robes - worn and stained with ink
  const robeGrad = ctx.createLinearGradient(x - size * 0.4, y - size * 0.35, x + size * 0.4, y + size * 0.55);
  robeGrad.addColorStop(0, "#1e0a30");
  robeGrad.addColorStop(0.2, "#3b0764");
  robeGrad.addColorStop(0.4, "#6b21a8");
  robeGrad.addColorStop(0.5, "#7c3aed");
  robeGrad.addColorStop(0.6, "#6b21a8");
  robeGrad.addColorStop(0.8, "#3b0764");
  robeGrad.addColorStop(1, "#1e0a30");
  ctx.fillStyle = robeGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.36, y + size * 0.52);
  ctx.quadraticCurveTo(x - size * 0.42, y, x - size * 0.2, y - size * 0.34);
  ctx.lineTo(x + size * 0.2, y - size * 0.34);
  ctx.quadraticCurveTo(x + size * 0.42, y, x + size * 0.36, y + size * 0.52);
  // Extremely tattered bottom
  for (let i = 0; i < 10; i++) {
    const tearX = x - size * 0.36 + i * size * 0.072;
    const tearY = y + size * 0.52 + Math.sin(time * 3 + i * 1.7) * size * 0.04 + (i % 2) * size * 0.07 + (i % 3) * size * 0.04;
    ctx.lineTo(tearX, tearY);
  }
  ctx.closePath();
  ctx.fill();

  // Ink stains on robe
  ctx.fillStyle = "rgba(30, 10, 50, 0.6)";
  for (let s = 0; s < 4; s++) {
    ctx.beginPath();
    ctx.ellipse(
      x - size * 0.15 + s * size * 0.1,
      y + size * 0.1 + Math.sin(s) * size * 0.15,
      size * 0.04,
      size * 0.06,
      Math.sin(s),
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  // Ancient symbols burning into robe
  ctx.fillStyle = `rgba(192, 132, 252, ${madnessPulse * 0.7})`;
  ctx.shadowColor = "#a855f7";
  ctx.shadowBlur = 6 * zoom;
  ctx.font = `${size * 0.09}px serif`;
  ctx.textAlign = "center";
  ctx.fillText("", x, y + size * 0.08);
  ctx.fillText("", x - size * 0.18, y + size * 0.28);
  ctx.fillText("", x + size * 0.18, y + size * 0.22);
  ctx.fillText("", x, y + size * 0.38);
  ctx.shadowBlur = 0;

  // Cracked spectacles floating askew with one lens missing
  ctx.save();
  ctx.translate(x, y - size * 0.46 + twitch * 0.25);
  ctx.rotate(0.08 + Math.sin(time * 3.5) * 0.05);
  ctx.strokeStyle = "#4b5563";
  ctx.lineWidth = 2.5 * zoom;
  // Left lens frame (lens cracked)
  ctx.beginPath();
  ctx.rect(-size * 0.18, -size * 0.065, size * 0.14, size * 0.11);
  ctx.stroke();
  // Right lens frame (lens missing)
  ctx.beginPath();
  ctx.rect(size * 0.04, -size * 0.065, size * 0.14, size * 0.11);
  ctx.stroke();
  // Bridge
  ctx.beginPath();
  ctx.moveTo(-size * 0.04, -size * 0.01);
  ctx.lineTo(size * 0.04, -size * 0.01);
  ctx.stroke();
  // Multiple cracks in left lens
  ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(-size * 0.15, -size * 0.05);
  ctx.lineTo(-size * 0.08, size * 0.025);
  ctx.moveTo(-size * 0.12, -size * 0.04);
  ctx.lineTo(-size * 0.06, -size * 0.02);
  ctx.lineTo(-size * 0.1, size * 0.03);
  ctx.stroke();
  // Glowing residue in empty frame
  ctx.fillStyle = `rgba(147, 51, 234, ${madnessPulse * 0.3})`;
  ctx.fillRect(size * 0.055, -size * 0.05, size * 0.12, size * 0.08);
  ctx.restore();

  // Gaunt, haunted face - pale and drawn
  const faceGrad = ctx.createRadialGradient(x, y - size * 0.44 + twitch * 0.2, 0, x, y - size * 0.44 + twitch * 0.2, size * 0.24);
  faceGrad.addColorStop(0, "#ede9fe");
  faceGrad.addColorStop(0.5, "#ddd6fe");
  faceGrad.addColorStop(1, "#c4b5fd");
  ctx.fillStyle = faceGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.44 + twitch * 0.2, size * 0.23, 0, Math.PI * 2);
  ctx.fill();

  // Deep sunken cheeks
  ctx.fillStyle = "rgba(91, 33, 182, 0.35)";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.13, y - size * 0.36 + twitch * 0.2, size * 0.05, size * 0.08, 0.1, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.13, y - size * 0.36 + twitch * 0.2, size * 0.05, size * 0.08, -0.1, 0, Math.PI * 2);
  ctx.fill();

  // Wide, terrified eyes with eldritch knowledge burning within
  ctx.fillStyle = "#fefefe";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.1 + eyeSpasm, y - size * 0.46 + twitch * 0.2, size * 0.06, size * 0.075, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.1 - eyeSpasm, y - size * 0.46 + twitch * 0.2, size * 0.06, size * 0.075, 0, 0, Math.PI * 2);
  ctx.fill();
  // Purple irises with swirling knowledge
  ctx.fillStyle = "#7c3aed";
  ctx.shadowColor = "#a855f7";
  ctx.shadowBlur = 10 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.1 + eyeSpasm, y - size * 0.46 + twitch * 0.2, size * 0.04, 0, Math.PI * 2);
  ctx.arc(x + size * 0.1 - eyeSpasm, y - size * 0.46 + twitch * 0.2, size * 0.04, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Tiny pinprick pupils (dilated from madness)
  ctx.fillStyle = "#0f0520";
  ctx.beginPath();
  ctx.arc(x - size * 0.1 + eyeSpasm, y - size * 0.46 + twitch * 0.2, size * 0.01, 0, Math.PI * 2);
  ctx.arc(x + size * 0.1 - eyeSpasm, y - size * 0.46 + twitch * 0.2, size * 0.01, 0, Math.PI * 2);
  ctx.fill();
  // Knowledge symbols in eyes
  ctx.fillStyle = `rgba(192, 132, 252, ${madnessPulse * 0.5})`;
  ctx.font = `${size * 0.02}px serif`;
  ctx.fillText("", x - size * 0.1 + eyeSpasm, y - size * 0.455 + twitch * 0.2);
  ctx.fillText("", x + size * 0.1 - eyeSpasm, y - size * 0.455 + twitch * 0.2);

  // Heavy dark circles under eyes
  ctx.fillStyle = "rgba(59, 7, 100, 0.6)";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.1, y - size * 0.38 + twitch * 0.2, size * 0.055, size * 0.025, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.1, y - size * 0.38 + twitch * 0.2, size * 0.055, size * 0.025, 0, 0, Math.PI * 2);
  ctx.fill();

  // Wild, unkempt hair turning white from terror
  ctx.fillStyle = "#1e1b4b";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.58 + twitch * 0.2, size * 0.22, size * 0.12, 0, 0, Math.PI);
  ctx.fill();
  // Wild strands with gray/white streaks
  for (let i = 0; i < 12; i++) {
    const hairAngle = -Math.PI * 0.5 + i * Math.PI * 0.083;
    const isGray = i % 2 === 0;
    ctx.strokeStyle = isGray ? "#9ca3af" : "#1e1b4b";
    ctx.lineWidth = 2.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(x + Math.cos(hairAngle) * size * 0.17, y - size * 0.57 + twitch * 0.2);
    ctx.bezierCurveTo(
      x + Math.cos(hairAngle) * size * 0.28 + Math.sin(time * 5 + i) * size * 0.06,
      y - size * 0.72 + twitch * 0.2,
      x + Math.cos(hairAngle + 0.15) * size * 0.3 + Math.cos(time * 4 + i) * size * 0.04,
      y - size * 0.78 + twitch * 0.2,
      x + Math.cos(hairAngle + 0.25) * size * 0.25,
      y - size * 0.82 + twitch * 0.2 + Math.sin(time * 6 + i) * size * 0.04
    );
    ctx.stroke();
  }

  // Trembling mouth muttering forbidden words
  ctx.fillStyle = "#3b0764";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.29 + twitch * 0.2, size * 0.05, size * 0.025 + Math.abs(Math.sin(time * 8)) * size * 0.01, 0, 0, Math.PI * 2);
  ctx.fill();
  // Whispered words escaping
  ctx.fillStyle = `rgba(147, 51, 234, ${madnessPulse * 0.4})`;
  ctx.font = `${size * 0.025}px serif`;
  const whisperY = y - size * 0.24 + twitch * 0.2;
  ctx.fillText("...", x + size * 0.08 + Math.sin(time * 4) * size * 0.02, whisperY);

  // Quill in trembling hand, dripping with glowing ink
  ctx.save();
  ctx.translate(x + size * 0.32, y + size * 0.1);
  ctx.rotate(-0.3 + Math.sin(time * 6) * 0.1);
  // Feather
  ctx.fillStyle = "#1e1b4b";
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.quadraticCurveTo(size * 0.08, -size * 0.15, size * 0.02, -size * 0.35);
  ctx.quadraticCurveTo(-size * 0.02, -size * 0.2, 0, 0);
  ctx.fill();
  // Quill tip
  ctx.fillStyle = "#7c3aed";
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-size * 0.01, size * 0.08);
  ctx.lineTo(size * 0.01, size * 0.08);
  ctx.fill();
  // Dripping magical ink
  ctx.fillStyle = `rgba(147, 51, 234, ${madnessPulse})`;
  const dripPhase = (time * 3) % 1;
  ctx.beginPath();
  ctx.arc(0, size * 0.08 + dripPhase * size * 0.1, size * 0.015 * (1 - dripPhase * 0.5), 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawSeniorEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // SENIOR THESIS - The Ultimate Academic Titan
  // A colossal ethereal manifestation of accumulated academic power
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const strut = Math.sin(time * 3) * 2 * zoom;
  const cloakWave = Math.sin(time * 2.5) * 0.12;
  const powerPulse = 0.5 + Math.sin(time * 3) * 0.3;
  const breathe = Math.sin(time * 2) * size * 0.02;
  const floatHeight = Math.sin(time * 1.5) * size * 0.03;
  
  // Attack animation variables
  const diplomaSwing = isAttacking ? Math.sin(attackPhase * Math.PI * 2) * 0.8 : 0;
  const powerSurge = isAttacking ? attackIntensity * 0.6 : 0;
  const auraExpand = isAttacking ? 1 + attackIntensity * 0.4 : 1;

  // === LAYER 1: COSMIC VOID AURA (Background) ===
  // Outer void distortion field
  for (let ring = 0; ring < 3; ring++) {
    const ringPhase = (time * 0.5 + ring * 0.3) % 1;
    const ringSize = size * (0.9 + ring * 0.25) * auraExpand;
    const ringAlpha = (0.15 - ring * 0.04) * (1 + powerSurge);
    ctx.strokeStyle = `rgba(219, 39, 119, ${ringAlpha})`;
    ctx.lineWidth = (2 - ring * 0.5) * zoom;
    ctx.beginPath();
    for (let a = 0; a < Math.PI * 2; a += 0.1) {
      const wobble = Math.sin(a * 6 + time * 3 + ring) * size * 0.03;
      const rx = x + Math.cos(a) * (ringSize + wobble);
      const ry = y + Math.sin(a) * (ringSize * 0.55 + wobble * 0.5);
      if (a === 0) ctx.moveTo(rx, ry);
      else ctx.lineTo(rx, ry);
    }
    ctx.closePath();
    ctx.stroke();
  }

  // Inner power aura - multi-layered gradient
  const auraGrad = ctx.createRadialGradient(x, y - size * 0.1, 0, x, y, size * 0.95 * auraExpand);
  auraGrad.addColorStop(0, `rgba(251, 207, 232, ${(0.4 + powerSurge * 0.3) * powerPulse})`);
  auraGrad.addColorStop(0.25, `rgba(244, 114, 182, ${(0.25 + powerSurge * 0.2) * powerPulse})`);
  auraGrad.addColorStop(0.5, `rgba(219, 39, 119, ${(0.15 + powerSurge * 0.15) * powerPulse})`);
  auraGrad.addColorStop(0.75, `rgba(157, 23, 77, ${0.08 * powerPulse})`);
  auraGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.ellipse(x, y, size * 0.95 * auraExpand, size * 0.6 * auraExpand, 0, 0, Math.PI * 2);
  ctx.fill();

  // === LAYER 2: FLOATING ARCANE ELEMENTS ===
  // Orbiting thesis chapters (ethereal pages)
  for (let i = 0; i < 8; i++) {
    const orbitAngle = time * 1.2 + i * Math.PI * 0.25;
    const orbitDist = size * 0.55 + Math.sin(time * 2 + i) * size * 0.08;
    const pageX = x + Math.cos(orbitAngle) * orbitDist;
    const pageY = y + Math.sin(orbitAngle) * orbitDist * 0.4 + floatHeight;
    const pageRot = Math.sin(time * 3 + i * 2) * 0.3;
    const pageGlow = 0.4 + Math.sin(time * 4 + i) * 0.2 + powerSurge * 0.3;
    
    ctx.save();
    ctx.translate(pageX, pageY);
    ctx.rotate(pageRot);
    // Page shadow
    ctx.fillStyle = `rgba(0, 0, 0, 0.2)`;
    ctx.fillRect(size * -0.04 + 1, size * -0.05 + 1, size * 0.08, size * 0.1);
    // Page body
    ctx.fillStyle = `rgba(253, 244, 255, ${pageGlow})`;
    ctx.fillRect(size * -0.04, size * -0.05, size * 0.08, size * 0.1);
    // Page text lines
    ctx.fillStyle = `rgba(157, 23, 77, ${pageGlow * 0.6})`;
    for (let line = 0; line < 4; line++) {
      ctx.fillRect(size * -0.03, size * -0.04 + line * size * 0.022, size * 0.06, size * 0.008);
    }
    // Glowing edge
    ctx.strokeStyle = `rgba(244, 114, 182, ${pageGlow * 0.8})`;
    ctx.lineWidth = 1 * zoom;
    ctx.strokeRect(size * -0.04, size * -0.05, size * 0.08, size * 0.1);
    ctx.restore();
  }

  // Floating arcane runes in a circle
  ctx.font = `${size * 0.08}px serif`;
  ctx.textAlign = "center";
  for (let i = 0; i < 6; i++) {
    const runeAngle = time * 0.8 + i * Math.PI / 3;
    const runeDist = size * 0.7 + Math.sin(time * 2.5 + i * 2) * size * 0.05;
    const runeX = x + Math.cos(runeAngle) * runeDist;
    const runeY = y - size * 0.15 + Math.sin(runeAngle) * runeDist * 0.35;
    const runeAlpha = 0.5 + Math.sin(time * 3 + i) * 0.3 + powerSurge * 0.4;
    ctx.fillStyle = `rgba(244, 114, 182, ${runeAlpha})`;
    const runes = ["", "", "", "", "", ""];
    ctx.fillText(runes[i], runeX, runeY);
  }

  // === LAYER 3: SHADOW AND GROUND EFFECT ===
  // Complex shadow with distortion
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.52, 0, x, y + size * 0.52, size * 0.5);
  shadowGrad.addColorStop(0, "rgba(80, 20, 60, 0.5)");
  shadowGrad.addColorStop(0.5, "rgba(40, 10, 30, 0.35)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.52, size * 0.45, size * 0.15, 0, 0, Math.PI * 2);
  ctx.fill();

  // Corruption tendrils from shadow
  ctx.strokeStyle = `rgba(157, 23, 77, ${0.3 + powerSurge * 0.3})`;
  ctx.lineWidth = 2 * zoom;
  for (let i = 0; i < 5; i++) {
    const tendrilAngle = Math.PI * 0.7 + i * Math.PI * 0.15;
    const tendrilWave = Math.sin(time * 3 + i * 2) * size * 0.05;
    ctx.beginPath();
    ctx.moveTo(x + Math.cos(tendrilAngle) * size * 0.3, y + size * 0.48);
    ctx.quadraticCurveTo(
      x + Math.cos(tendrilAngle) * size * 0.4 + tendrilWave,
      y + size * 0.3,
      x + Math.cos(tendrilAngle) * size * 0.25 + tendrilWave * 1.5,
      y + size * 0.1
    );
    ctx.stroke();
  }

  // === LAYER 4: THE LIVING GRADUATION CLOAK ===
  ctx.save();
  ctx.translate(x, y + floatHeight);
  ctx.rotate(cloakWave * 0.5);
  
  // Cloak outer shadow layer
  const cloakShadowGrad = ctx.createLinearGradient(-size * 0.5, -size * 0.35, size * 0.5, size * 0.55);
  cloakShadowGrad.addColorStop(0, "#0a0510");
  cloakShadowGrad.addColorStop(0.5, "#150818");
  cloakShadowGrad.addColorStop(1, "#0a0510");
  ctx.fillStyle = cloakShadowGrad;
  ctx.beginPath();
  ctx.moveTo(-size * 0.44, size * 0.52);
  for (let i = 0; i < 10; i++) {
    const waveX = -size * 0.44 + i * size * 0.098;
    const waveY = size * 0.52 + Math.sin(time * 4 + i * 1.2) * size * 0.05 + (i % 2) * size * 0.03;
    ctx.lineTo(waveX, waveY);
  }
  ctx.quadraticCurveTo(size * 0.52, size * 0.1, size * 0.28, -size * 0.34 + strut * 0.08);
  ctx.lineTo(-size * 0.28, -size * 0.34 + strut * 0.08);
  ctx.quadraticCurveTo(-size * 0.52, size * 0.1, -size * 0.44, size * 0.52);
  ctx.fill();

  // Cloak main body with gradient
  const cloakGrad = ctx.createLinearGradient(-size * 0.45, -size * 0.3, size * 0.45, size * 0.5);
  cloakGrad.addColorStop(0, "#1f1225");
  cloakGrad.addColorStop(0.2, "#2d1832");
  cloakGrad.addColorStop(0.4, "#1f1225");
  cloakGrad.addColorStop(0.6, "#2d1832");
  cloakGrad.addColorStop(0.8, "#1f1225");
  cloakGrad.addColorStop(1, "#150818");
  ctx.fillStyle = cloakGrad;
  ctx.beginPath();
  ctx.moveTo(-size * 0.4, size * 0.48);
  for (let i = 0; i < 9; i++) {
    const waveX = -size * 0.4 + i * size * 0.1;
    const waveY = size * 0.48 + Math.sin(time * 4.5 + i * 1.3) * size * 0.04;
    ctx.lineTo(waveX, waveY);
  }
  ctx.quadraticCurveTo(size * 0.48, size * 0.05, size * 0.24, -size * 0.3 + strut * 0.1);
  ctx.lineTo(-size * 0.24, -size * 0.3 + strut * 0.1);
  ctx.quadraticCurveTo(-size * 0.48, size * 0.05, -size * 0.4, size * 0.48);
  ctx.fill();

  // Cloak magical pattern overlay
  ctx.strokeStyle = `rgba(244, 114, 182, ${0.2 + powerSurge * 0.3})`;
  ctx.lineWidth = 1.5 * zoom;
  for (let i = 0; i < 6; i++) {
    const patternY = -size * 0.2 + i * size * 0.12;
    ctx.beginPath();
    ctx.moveTo(-size * 0.25, patternY);
    ctx.quadraticCurveTo(0, patternY + Math.sin(time * 3 + i) * size * 0.03, size * 0.25, patternY);
    ctx.stroke();
  }
  ctx.restore();

  // === LAYER 5: GOLDEN TRIM AND STOLES ===
  // Left stole with intricate pattern
  const stoleGrad = ctx.createLinearGradient(x - size * 0.2, y - size * 0.3, x - size * 0.15, y + size * 0.4);
  stoleGrad.addColorStop(0, "#f472b6");
  stoleGrad.addColorStop(0.3, "#ec4899");
  stoleGrad.addColorStop(0.5, "#f472b6");
  stoleGrad.addColorStop(0.7, "#db2777");
  stoleGrad.addColorStop(1, "#be185d");
  ctx.fillStyle = stoleGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.14, y - size * 0.26 + strut * 0.1 + floatHeight);
  ctx.lineTo(x - size * 0.18, y + size * 0.42);
  ctx.quadraticCurveTo(x - size * 0.16, y + size * 0.48, x - size * 0.1, y + size * 0.42);
  ctx.lineTo(x - size * 0.06, y - size * 0.22 + strut * 0.1 + floatHeight);
  ctx.fill();
  // Right stole
  ctx.beginPath();
  ctx.moveTo(x + size * 0.14, y - size * 0.26 + strut * 0.1 + floatHeight);
  ctx.lineTo(x + size * 0.18, y + size * 0.42);
  ctx.quadraticCurveTo(x + size * 0.16, y + size * 0.48, x + size * 0.1, y + size * 0.42);
  ctx.lineTo(x + size * 0.06, y - size * 0.22 + strut * 0.1 + floatHeight);
  ctx.fill();

  // Stole emblems and symbols
  ctx.fillStyle = "#fdf4ff";
  ctx.font = `bold ${size * 0.07}px serif`;
  const emblems = ["", "", "", ""];
  for (let i = 0; i < 4; i++) {
    const emblemY = y - size * 0.05 + i * size * 0.12;
    ctx.fillText(emblems[i], x - size * 0.12, emblemY);
    ctx.fillText(emblems[(i + 2) % 4], x + size * 0.12, emblemY + size * 0.03);
  }

  // Golden trim lines
  ctx.strokeStyle = "#fcd34d";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.17, y - size * 0.26 + strut * 0.1 + floatHeight);
  ctx.lineTo(x - size * 0.21, y + size * 0.44);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.17, y - size * 0.26 + strut * 0.1 + floatHeight);
  ctx.lineTo(x + size * 0.21, y + size * 0.44);
  ctx.stroke();

  // === LAYER 6: THE FACE - Wise and Powerful ===
  const headY = y - size * 0.42 + strut * 0.12 + floatHeight;
  
  // Face base
  const faceGrad = ctx.createRadialGradient(x, headY, 0, x, headY, size * 0.2);
  faceGrad.addColorStop(0, "#fdf4ff");
  faceGrad.addColorStop(0.7, "#fce7f3");
  faceGrad.addColorStop(1, "#fbcfe8");
  ctx.fillStyle = faceGrad;
  ctx.beginPath();
  ctx.ellipse(x, headY, size * 0.18, size * 0.2, 0, 0, Math.PI * 2);
  ctx.fill();

  // Jaw definition
  ctx.fillStyle = "#f9a8d4";
  ctx.beginPath();
  ctx.ellipse(x, headY + size * 0.12, size * 0.12, size * 0.06, 0, 0, Math.PI);
  ctx.fill();

  // Elegant dark hair with highlights
  const hairGrad = ctx.createLinearGradient(x - size * 0.2, headY - size * 0.25, x + size * 0.2, headY);
  hairGrad.addColorStop(0, "#1e1b4b");
  hairGrad.addColorStop(0.3, "#312e81");
  hairGrad.addColorStop(0.5, "#1e1b4b");
  hairGrad.addColorStop(0.7, "#312e81");
  hairGrad.addColorStop(1, "#1e1b4b");
  ctx.fillStyle = hairGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.2, headY - size * 0.08);
  ctx.quadraticCurveTo(x - size * 0.28, headY - size * 0.32, x, headY - size * 0.38);
  ctx.quadraticCurveTo(x + size * 0.28, headY - size * 0.32, x + size * 0.2, headY - size * 0.08);
  ctx.quadraticCurveTo(x + size * 0.15, headY - size * 0.15, x, headY - size * 0.12);
  ctx.quadraticCurveTo(x - size * 0.15, headY - size * 0.15, x - size * 0.2, headY - size * 0.08);
  ctx.fill();
  
  // Hair shine
  ctx.strokeStyle = "rgba(99, 102, 241, 0.4)";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.08, headY - size * 0.25, size * 0.08, -0.8, 0.3);
  ctx.stroke();

  // === LAYER 7: THE MORTARBOARD - Floating Crown of Knowledge ===
  ctx.save();
  ctx.translate(x, headY - size * 0.32 + Math.sin(time * 2) * size * 0.015);
  ctx.rotate(Math.sin(time * 1.5) * 0.06);
  
  // Board shadow
  ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
  ctx.beginPath();
  ctx.moveTo(-size * 0.28, size * 0.02);
  ctx.lineTo(0, -size * 0.1);
  ctx.lineTo(size * 0.28, size * 0.02);
  ctx.lineTo(0, size * 0.12);
  ctx.closePath();
  ctx.fill();
  
  // Board top with gradient
  const boardGrad = ctx.createLinearGradient(-size * 0.25, 0, size * 0.25, 0);
  boardGrad.addColorStop(0, "#1e1b4b");
  boardGrad.addColorStop(0.5, "#312e81");
  boardGrad.addColorStop(1, "#1e1b4b");
  ctx.fillStyle = boardGrad;
  ctx.beginPath();
  ctx.moveTo(-size * 0.26, 0);
  ctx.lineTo(0, -size * 0.1);
  ctx.lineTo(size * 0.26, 0);
  ctx.lineTo(0, size * 0.1);
  ctx.closePath();
  ctx.fill();
  
  // Board edge highlight
  ctx.strokeStyle = "#6366f1";
  ctx.lineWidth = 1.5 * zoom;
  ctx.stroke();
  
  // Cap base
  const capGrad = ctx.createRadialGradient(0, size * 0.04, 0, 0, size * 0.04, size * 0.15);
  capGrad.addColorStop(0, "#4338ca");
  capGrad.addColorStop(1, "#312e81");
  ctx.fillStyle = capGrad;
  ctx.beginPath();
  ctx.ellipse(0, size * 0.04, size * 0.14, size * 0.07, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Tassel - flowing and magical
  const tasselSwing = Math.sin(time * 4) * size * 0.06;
  ctx.strokeStyle = "#f472b6";
  ctx.lineWidth = 3 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.05);
  ctx.quadraticCurveTo(size * 0.08 + tasselSwing, size * 0.05, size * 0.1 + tasselSwing * 0.5, size * 0.18);
  ctx.stroke();
  
  // Tassel strands
  ctx.lineWidth = 1.5 * zoom;
  for (let i = 0; i < 5; i++) {
    const strandX = size * 0.1 + tasselSwing * 0.5 + (i - 2) * size * 0.015;
    ctx.beginPath();
    ctx.moveTo(strandX, size * 0.18);
    ctx.lineTo(strandX + Math.sin(time * 5 + i) * size * 0.02, size * 0.28);
    ctx.stroke();
  }
  
  // Tassel button
  ctx.fillStyle = "#fcd34d";
  ctx.beginPath();
  ctx.arc(0, -size * 0.05, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // === LAYER 8: THE EYES - Windows to Academic Power ===
  // Eye whites with slight glow
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.075, headY - size * 0.02, size * 0.055, size * 0.065, -0.1, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.075, headY - size * 0.02, size * 0.055, size * 0.065, 0.1, 0, Math.PI * 2);
  ctx.fill();
  
  // Irises - glowing with power
  const irisGlow = isAttacking ? 0.9 + attackIntensity * 0.1 : 0.7 + Math.sin(time * 2) * 0.2;
  ctx.fillStyle = `rgba(219, 39, 119, ${irisGlow})`;
  ctx.beginPath();
  ctx.arc(x - size * 0.075, headY - size * 0.02, size * 0.035, 0, Math.PI * 2);
  ctx.arc(x + size * 0.075, headY - size * 0.02, size * 0.035, 0, Math.PI * 2);
  ctx.fill();
  
  // Pupils
  ctx.fillStyle = "#1e1b4b";
  ctx.beginPath();
  ctx.arc(x - size * 0.075, headY - size * 0.02, size * 0.018, 0, Math.PI * 2);
  ctx.arc(x + size * 0.075, headY - size * 0.02, size * 0.018, 0, Math.PI * 2);
  ctx.fill();
  
  // Eye shine
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(x - size * 0.085, headY - size * 0.035, size * 0.012, 0, Math.PI * 2);
  ctx.arc(x + size * 0.065, headY - size * 0.035, size * 0.012, 0, Math.PI * 2);
  ctx.fill();

  // Confident brow lines
  ctx.strokeStyle = "#1e1b4b";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.14, headY - size * 0.1);
  ctx.quadraticCurveTo(x - size * 0.075, headY - size * 0.13 - (isAttacking ? size * 0.02 : 0), x - size * 0.02, headY - size * 0.09);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.14, headY - size * 0.1);
  ctx.quadraticCurveTo(x + size * 0.075, headY - size * 0.13 - (isAttacking ? size * 0.02 : 0), x + size * 0.02, headY - size * 0.09);
  ctx.stroke();

  // Knowing smile
  ctx.strokeStyle = "#9d174d";
  ctx.lineWidth = 2 * zoom;
  const smileWidth = isAttacking ? 0.1 : 0.07;
  ctx.beginPath();
  ctx.arc(x, headY + size * 0.08, size * smileWidth, 0.15 * Math.PI, 0.85 * Math.PI);
  ctx.stroke();

  // === LAYER 9: THE DIPLOMA OF POWER ===
  ctx.save();
  ctx.translate(x + size * 0.45, y + size * 0.05 + strut * 0.08 + floatHeight);
  ctx.rotate(0.35 + Math.sin(time * 2) * 0.12 + diplomaSwing);
  
  // Diploma shadow
  ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
  ctx.fillRect(-size * 0.05 + 2, -size * 0.22 + 2, size * 0.1, size * 0.44);
  
  // Diploma scroll body
  const diplomaGrad = ctx.createLinearGradient(-size * 0.05, 0, size * 0.05, 0);
  diplomaGrad.addColorStop(0, "#fef3c7");
  diplomaGrad.addColorStop(0.3, "#fefce8");
  diplomaGrad.addColorStop(0.5, "#fef3c7");
  diplomaGrad.addColorStop(0.7, "#fefce8");
  diplomaGrad.addColorStop(1, "#fef3c7");
  ctx.fillStyle = diplomaGrad;
  ctx.fillRect(-size * 0.05, -size * 0.22, size * 0.1, size * 0.44);
  
  // Diploma edges (rolled appearance)
  ctx.fillStyle = "#fcd34d";
  ctx.beginPath();
  ctx.ellipse(0, -size * 0.22, size * 0.05, size * 0.02, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(0, size * 0.22, size * 0.05, size * 0.02, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Magical text lines
  ctx.fillStyle = `rgba(157, 23, 77, ${0.6 + powerSurge * 0.4})`;
  for (let i = 0; i < 8; i++) {
    const lineWidth = size * (0.06 - Math.abs(i - 4) * 0.005);
    ctx.fillRect(-lineWidth / 2, -size * 0.16 + i * size * 0.045, lineWidth, size * 0.015);
  }
  
  // Glowing seal
  ctx.fillStyle = `rgba(219, 39, 119, ${0.8 + powerSurge * 0.2})`;
  ctx.beginPath();
  ctx.arc(0, size * 0.15, size * 0.045, 0, Math.PI * 2);
  ctx.fill();
  
  // Seal emblem
  ctx.fillStyle = "#fcd34d";
  ctx.font = `${size * 0.04}px serif`;
  ctx.textAlign = "center";
  ctx.fillText("P", 0, size * 0.165);
  
  // Magical glow effect around diploma
  ctx.strokeStyle = `rgba(244, 114, 182, ${powerPulse * 0.7 + powerSurge * 0.3})`;
  ctx.lineWidth = 2 * zoom;
  ctx.strokeRect(-size * 0.06, -size * 0.23, size * 0.12, size * 0.46);
  
  ctx.restore();

  // === LAYER 10: ATTACK EFFECTS ===
  if (isAttacking) {
    // Power burst from diploma
    const burstCount = 8;
    for (let i = 0; i < burstCount; i++) {
      const burstAngle = (i / burstCount) * Math.PI * 2 + time * 3;
      const burstDist = size * 0.3 + attackIntensity * size * 0.4;
      const burstX = x + size * 0.45 + Math.cos(burstAngle) * burstDist;
      const burstY = y + size * 0.05 + Math.sin(burstAngle) * burstDist * 0.6;
      ctx.fillStyle = `rgba(244, 114, 182, ${attackIntensity * 0.5})`;
      ctx.beginPath();
      ctx.arc(burstX, burstY, size * 0.02 + attackIntensity * size * 0.02, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Energy wave
    ctx.strokeStyle = `rgba(219, 39, 119, ${attackIntensity * 0.6})`;
    ctx.lineWidth = 3 * zoom;
    ctx.beginPath();
    ctx.arc(x, y, size * 0.6 + attackIntensity * size * 0.3, 0, Math.PI * 2);
    ctx.stroke();
    
    // Academic power words
    ctx.font = `italic ${size * 0.06}px Georgia`;
    ctx.fillStyle = `rgba(244, 114, 182, ${attackIntensity * 0.8})`;
    const words = ["THESIS", "DEFENSE", "QED"];
    const wordIndex = Math.floor((attackPhase * 3) % 3);
    ctx.fillText(words[wordIndex], x + size * 0.2 + attackIntensity * size * 0.3, y - size * 0.3 - attackIntensity * size * 0.2);
  }

  // === LAYER 11: AMBIENT PARTICLES ===
  // Knowledge particles floating upward
  for (let i = 0; i < 6; i++) {
    const particlePhase = (time * 0.5 + i * 0.5) % 3;
    const particleX = x - size * 0.3 + i * size * 0.12 + Math.sin(time * 2 + i) * size * 0.05;
    const particleY = y + size * 0.3 - particlePhase * size * 0.25;
    const particleAlpha = (1 - particlePhase / 3) * 0.5;
    ctx.fillStyle = `rgba(244, 114, 182, ${particleAlpha})`;
    ctx.beginPath();
    ctx.arc(particleX, particleY, size * 0.015 + Math.sin(time * 4 + i) * size * 0.005, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawGradStudentEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  // VOID-TOUCHED RESEARCHER - Driven mad by dimensional research, reality warps around them
  const exhaustionSway = Math.sin(time * 1.5) * 4 * zoom + (isAttacking ? attackIntensity * size * 0.15 : 0);
  const insanityPulse = 0.5 + Math.sin(time * 6) * 0.3 + attackIntensity * 0.4;
  const eyeTwitch = Math.sin(time * 12) * 0.5 + Math.sin(time * 17) * 0.3 + (isAttacking ? attackIntensity * 0.5 : 0);
  const dimensionalRift = 0.4 + Math.sin(time * 4) * 0.3 + attackIntensity * 0.4;
  const caffeineTremor = Math.sin(time * 20) * size * 0.005 + (isAttacking ? attackIntensity * size * 0.01 : 0);

  // Dimensional instability field
  ctx.save();
  for (let layer = 0; layer < 4; layer++) {
    const layerPhase = (time * 0.6 + layer * 0.4) % 2.5;
    const layerSize = size * 0.35 + layerPhase * size * 0.35;
    ctx.strokeStyle = `rgba(251, 146, 60, ${(0.4 - layer * 0.08) * (1 - layerPhase / 2.5)})`;
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    for (let a = 0; a < Math.PI * 2; a += 0.1) {
      const distort = Math.sin(a * 4 + time * 3 + layer) * size * 0.06;
      const rx = layerSize + distort;
      const ry = (layerSize + distort) * 0.65;
      const px = x + Math.cos(a) * rx;
      const py = y + Math.sin(a) * ry;
      if (a === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.stroke();
  }
  ctx.restore();

  // Void tears in reality
  ctx.fillStyle = `rgba(20, 10, 30, ${dimensionalRift * 0.6})`;
  for (let tear = 0; tear < 4; tear++) {
    const tearX = x + Math.sin(time * 0.8 + tear * 1.5) * size * 0.4;
    const tearY = y + Math.cos(time * 0.6 + tear) * size * 0.3 - size * 0.1;
    ctx.save();
    ctx.translate(tearX, tearY);
    ctx.rotate(time * 0.5 + tear);
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 0.03 + Math.sin(time * 3 + tear) * size * 0.01, size * 0.08, 0, 0, Math.PI * 2);
    ctx.fill();
    // Void energy leaking
    ctx.strokeStyle = `rgba(251, 146, 60, ${insanityPulse * 0.5})`;
    ctx.lineWidth = 1 * zoom;
    ctx.beginPath();
    ctx.moveTo(0, size * 0.08);
    ctx.quadraticCurveTo(Math.sin(time * 4 + tear) * size * 0.03, size * 0.12, 0, size * 0.15);
    ctx.stroke();
    ctx.restore();
  }

  // Floating research papers with forbidden equations
  for (let i = 0; i < 8; i++) {
    const paperAngle = time * 0.8 + i * Math.PI * 0.25;
    const paperDist = size * 0.5 + Math.sin(time * 2 + i) * size * 0.12;
    const px = x + Math.cos(paperAngle) * paperDist;
    const py = y - size * 0.12 + Math.sin(paperAngle) * paperDist * 0.4;
    ctx.save();
    ctx.translate(px, py);
    ctx.rotate(Math.sin(time * 3.5 + i) * 0.6);
    // Aged paper
    ctx.fillStyle = "#fef3c7";
    ctx.fillRect(-size * 0.055, -size * 0.07, size * 0.11, size * 0.14);
    // Paper edge wear
    ctx.strokeStyle = "#d4a574";
    ctx.lineWidth = 0.5 * zoom;
    ctx.strokeRect(-size * 0.055, -size * 0.07, size * 0.11, size * 0.14);
    // Forbidden equations and diagrams
    ctx.strokeStyle = "#1c1917";
    ctx.lineWidth = 0.5 * zoom;
    for (let j = 0; j < 5; j++) {
      ctx.beginPath();
      ctx.moveTo(-size * 0.045, -size * 0.055 + j * size * 0.022);
      ctx.lineTo(size * 0.045, -size * 0.055 + j * size * 0.022);
      ctx.stroke();
    }
    // Glowing warning symbol on some papers
    if (i % 3 === 0) {
      ctx.fillStyle = `rgba(251, 146, 60, ${insanityPulse})`;
      ctx.font = `${size * 0.04}px serif`;
      ctx.textAlign = "center";
      ctx.fillText("", 0, size * 0.04);
    }
    ctx.restore();
  }

  // Shadow with dimensional bleed
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.52, 0, x, y + size * 0.52, size * 0.4);
  shadowGrad.addColorStop(0, "rgba(120, 53, 15, 0.5)");
  shadowGrad.addColorStop(0.5, "rgba(0, 0, 0, 0.4)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.52, size * 0.4, size * 0.14, 0, 0, Math.PI * 2);
  ctx.fill();

  // Tattered lab coat with dimensional burns and chemical stains
  const coatGrad = ctx.createLinearGradient(x - size * 0.4, y - size * 0.35, x + size * 0.4, y + size * 0.55);
  coatGrad.addColorStop(0, "#a3a3a3");
  coatGrad.addColorStop(0.2, "#d4d4d4");
  coatGrad.addColorStop(0.4, "#f5f5f5");
  coatGrad.addColorStop(0.5, "#ffffff");
  coatGrad.addColorStop(0.6, "#f5f5f5");
  coatGrad.addColorStop(0.8, "#d4d4d4");
  coatGrad.addColorStop(1, "#a3a3a3");
  ctx.fillStyle = coatGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.38, y + size * 0.55);
  ctx.quadraticCurveTo(x - size * 0.44, y, x - size * 0.22, y - size * 0.34 + exhaustionSway * 0.1);
  ctx.lineTo(x + size * 0.22, y - size * 0.34 + exhaustionSway * 0.1);
  ctx.quadraticCurveTo(x + size * 0.44, y, x + size * 0.38, y + size * 0.55);
  // Burned and tattered bottom
  for (let i = 0; i < 9; i++) {
    const tearX = x - size * 0.38 + i * size * 0.095;
    const tearY = y + size * 0.55 + Math.sin(time * 2 + i * 1.3) * size * 0.03 + (i % 2) * size * 0.06 + (i % 3) * size * 0.03;
    ctx.lineTo(tearX, tearY);
  }
  ctx.closePath();
  ctx.fill();

  // Multiple stains - coffee, chemicals, dimensional residue
  // Coffee stains
  ctx.fillStyle = "rgba(120, 53, 15, 0.4)";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.18, y + size * 0.18, size * 0.09, size * 0.12, 0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x + size * 0.12, y + size * 0.08, size * 0.07, size * 0.09, -0.2, 0, Math.PI * 2);
  ctx.fill();
  // Chemical burns
  ctx.fillStyle = "rgba(20, 184, 166, 0.3)";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.05, y + size * 0.3, size * 0.05, size * 0.06, 0.5, 0, Math.PI * 2);
  ctx.fill();
  // Dimensional residue (glowing)
  ctx.fillStyle = `rgba(251, 146, 60, ${insanityPulse * 0.5})`;
  ctx.shadowColor = "#fb923c";
  ctx.shadowBlur = 6 * zoom;
  ctx.beginPath();
  ctx.ellipse(x + size * 0.2, y + size * 0.28, size * 0.045, size * 0.055, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Multiple pockets overflowing with tools
  ctx.fillStyle = "#e5e5e5";
  ctx.fillRect(x - size * 0.24, y - size * 0.18, size * 0.14, size * 0.16);
  ctx.strokeStyle = "#a3a3a3";
  ctx.lineWidth = 1 * zoom;
  ctx.strokeRect(x - size * 0.24, y - size * 0.18, size * 0.14, size * 0.16);
  // Chaotic pens and tools
  const penColors = ["#1c1917", "#dc2626", "#2563eb", "#16a34a", "#9333ea"];
  for (let i = 0; i < 5; i++) {
    ctx.save();
    ctx.translate(x - size * 0.22 + i * size * 0.025, y - size * 0.14);
    ctx.rotate(-0.35 + Math.sin(time * 2 + i * 0.7) * 0.25);
    ctx.fillStyle = penColors[i];
    ctx.fillRect(-size * 0.008, -size * 0.12, size * 0.016, size * 0.12);
    ctx.restore();
  }

  // Gaunt, exhausted face - nearly skeletal from sleep deprivation
  ctx.save();
  ctx.translate(x + caffeineTremor, y - size * 0.44 + exhaustionSway * 0.15);
  ctx.rotate(exhaustionSway * 0.025);

  const faceGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.24);
  faceGrad.addColorStop(0, "#fef9c3");
  faceGrad.addColorStop(0.6, "#fef3c7");
  faceGrad.addColorStop(1, "#fde68a");
  ctx.fillStyle = faceGrad;
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.24, 0, Math.PI * 2);
  ctx.fill();

  // Extremely sunken cheeks
  ctx.fillStyle = "rgba(120, 53, 15, 0.25)";
  ctx.beginPath();
  ctx.ellipse(-size * 0.14, size * 0.02, size * 0.06, size * 0.1, 0.1, 0, Math.PI * 2);
  ctx.ellipse(size * 0.14, size * 0.02, size * 0.06, size * 0.1, -0.1, 0, Math.PI * 2);
  ctx.fill();

  // Scraggly unkempt beard with food bits
  ctx.fillStyle = "#57534e";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.14, size * 0.14, size * 0.1, 0, 0, Math.PI);
  ctx.fill();
  // Stubble texture
  ctx.fillStyle = "#44403c";
  for (let i = 0; i < 18; i++) {
    const stubX = -size * 0.12 + (i % 6) * size * 0.04;
    const stubY = size * 0.06 + Math.floor(i / 6) * size * 0.035;
    ctx.fillRect(stubX, stubY, size * 0.012, size * 0.025);
  }
  // Crumbs in beard
  ctx.fillStyle = "#d4a574";
  ctx.beginPath();
  ctx.arc(-size * 0.05, size * 0.12, size * 0.01, 0, Math.PI * 2);
  ctx.arc(size * 0.08, size * 0.1, size * 0.008, 0, Math.PI * 2);
  ctx.fill();

  // Bloodshot, twitching eyes with dimensional sight
  ctx.fillStyle = "#fef2f2";
  ctx.beginPath();
  ctx.ellipse(-size * 0.09 + eyeTwitch, -size * 0.02, size * 0.06, size * 0.045, 0, 0, Math.PI * 2);
  ctx.ellipse(size * 0.09 + eyeTwitch, -size * 0.02, size * 0.06, size * 0.045, 0, 0, Math.PI * 2);
  ctx.fill();
  // Heavy bloodshot veins
  ctx.strokeStyle = "#ef4444";
  ctx.lineWidth = 0.8 * zoom;
  for (let eye = 0; eye < 2; eye++) {
    const ex = eye === 0 ? -size * 0.09 : size * 0.09;
    for (let v = 0; v < 5; v++) {
      const vAngle = -Math.PI * 0.5 + v * Math.PI * 0.25;
      ctx.beginPath();
      ctx.moveTo(ex + eyeTwitch, -size * 0.02);
      ctx.lineTo(ex + eyeTwitch + Math.cos(vAngle) * size * 0.05, -size * 0.02 + Math.sin(vAngle) * size * 0.04);
      ctx.stroke();
    }
  }
  // Orange dimensional-touched pupils
  ctx.fillStyle = "#fb923c";
  ctx.shadowColor = "#fb923c";
  ctx.shadowBlur = 8 * zoom;
  ctx.beginPath();
  ctx.arc(-size * 0.09 + eyeTwitch, -size * 0.02, size * 0.028, 0, Math.PI * 2);
  ctx.arc(size * 0.09 + eyeTwitch, -size * 0.02, size * 0.028, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Tiny pinprick pupils (over-caffeinated)
  ctx.fillStyle = "#1c1917";
  ctx.beginPath();
  ctx.arc(-size * 0.09 + eyeTwitch, -size * 0.02, size * 0.007, 0, Math.PI * 2);
  ctx.arc(size * 0.09 + eyeTwitch, -size * 0.02, size * 0.007, 0, Math.PI * 2);
  ctx.fill();

  // Massive dark circles - practically bruises
  ctx.fillStyle = "rgba(88, 28, 135, 0.6)";
  ctx.beginPath();
  ctx.ellipse(-size * 0.09, size * 0.05, size * 0.07, size * 0.03, 0, 0, Math.PI * 2);
  ctx.ellipse(size * 0.09, size * 0.05, size * 0.07, size * 0.03, 0, 0, Math.PI * 2);
  ctx.fill();

  // Broken glasses held together with tape
  ctx.strokeStyle = "#374151";
  ctx.lineWidth = 2.5 * zoom;
  // Left lens (cracked)
  ctx.beginPath();
  ctx.arc(-size * 0.09, -size * 0.02, size * 0.07, 0, Math.PI * 2);
  ctx.stroke();
  // Right lens
  ctx.beginPath();
  ctx.arc(size * 0.09, -size * 0.02, size * 0.07, 0, Math.PI * 2);
  ctx.stroke();
  // Bridge with tape
  ctx.beginPath();
  ctx.moveTo(-size * 0.02, -size * 0.02);
  ctx.lineTo(size * 0.02, -size * 0.02);
  ctx.stroke();
  // Tape on bridge
  ctx.fillStyle = "#fef3c7";
  ctx.fillRect(-size * 0.015, -size * 0.035, size * 0.03, size * 0.03);
  // Crack in left lens
  ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(-size * 0.12, -size * 0.04);
  ctx.lineTo(-size * 0.08, size * 0.02);
  ctx.lineTo(-size * 0.06, -size * 0.01);
  ctx.stroke();

  // Wild, unkempt hair standing on end
  ctx.fillStyle = "#44403c";
  ctx.beginPath();
  ctx.ellipse(0, -size * 0.16, size * 0.22, size * 0.12, 0, 0, Math.PI);
  ctx.fill();
  // Chaotic strands with gray from stress
  for (let i = 0; i < 14; i++) {
    const hairAngle = -Math.PI * 0.55 + i * Math.PI * 0.077;
    const isGray = i % 4 === 0;
    ctx.strokeStyle = isGray ? "#9ca3af" : "#44403c";
    ctx.lineWidth = 2.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(Math.cos(hairAngle) * size * 0.18, -size * 0.16);
    ctx.bezierCurveTo(
      Math.cos(hairAngle) * size * 0.28 + Math.sin(time * 6 + i) * size * 0.1,
      -size * 0.32 + Math.sin(time * 4 + i) * size * 0.06,
      Math.cos(hairAngle + 0.2) * size * 0.3 + Math.cos(time * 5 + i) * size * 0.05,
      -size * 0.38,
      Math.cos(hairAngle + 0.35) * size * 0.25,
      -size * 0.42 + Math.sin(time * 5 + i) * size * 0.08
    );
    ctx.stroke();
  }

  ctx.restore();

  // MASSIVE coffee thermos (industrial size)
  ctx.save();
  ctx.translate(x + size * 0.4, y - size * 0.15 + exhaustionSway * 0.1);
  // Thermos body
  ctx.fillStyle = "#1f2937";
  ctx.beginPath();
  ctx.roundRect(-size * 0.1, -size * 0.08, size * 0.2, size * 0.45, size * 0.03);
  ctx.fill();
  // Metal bands
  ctx.fillStyle = "#6b7280";
  ctx.fillRect(-size * 0.1, -size * 0.02, size * 0.2, size * 0.03);
  ctx.fillRect(-size * 0.1, size * 0.25, size * 0.2, size * 0.03);
  // Coffee inside (visible through opening)
  ctx.fillStyle = "#78350f";
  ctx.beginPath();
  ctx.ellipse(0, -size * 0.06, size * 0.07, size * 0.025, 0, 0, Math.PI * 2);
  ctx.fill();
  // Excessive steam - reality-warping caffeine vapor
  ctx.strokeStyle = `rgba(251, 146, 60, ${0.5 + Math.sin(time * 5) * 0.25})`;
  ctx.lineWidth = 2.5 * zoom;
  for (let i = 0; i < 7; i++) {
    const steamPhase = (time * 2.5 + i * 0.25) % 1.5;
    ctx.beginPath();
    ctx.moveTo(-size * 0.06 + i * size * 0.02, -size * 0.1);
    ctx.bezierCurveTo(
      -size * 0.06 + i * size * 0.02 + Math.sin(time * 6 + i) * size * 0.04,
      -size * 0.2 - steamPhase * size * 0.1,
      -size * 0.04 + i * size * 0.02 + Math.cos(time * 5 + i) * size * 0.03,
      -size * 0.35 - steamPhase * size * 0.1,
      -size * 0.06 + i * size * 0.02,
      -size * 0.5 - steamPhase * size * 0.12
    );
    ctx.stroke();
  }
  // Warning label
  ctx.fillStyle = "#ef4444";
  ctx.fillRect(-size * 0.06, size * 0.1, size * 0.12, size * 0.08);
  ctx.fillStyle = "#fef2f2";
  ctx.font = `${size * 0.03}px sans-serif`;
  ctx.textAlign = "center";
  ctx.fillText("", 0, size * 0.155);
  ctx.restore();

  // Floating equations and diagrams around head
  ctx.fillStyle = `rgba(251, 146, 60, ${insanityPulse * 0.6})`;
  ctx.font = `${size * 0.035}px serif`;
  const equations = ["E=mc", "", "n", "/t", ""];
  for (let e = 0; e < 5; e++) {
    const eqX = x + Math.sin(time * 1.2 + e * 1.3) * size * 0.55;
    const eqY = y - size * 0.6 + Math.cos(time * 0.8 + e) * size * 0.15;
    ctx.save();
    ctx.translate(eqX, eqY);
    ctx.rotate(Math.sin(time * 1.5 + e) * 0.2);
    ctx.fillText(equations[e], 0, 0);
    ctx.restore();
  }
}

function drawProfessorEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  // ARCHLICH PROFESSOR - Ancient undead lecturer with arcane knowledge
  const hover = Math.sin(time * 2) * 3 * zoom + (isAttacking ? attackIntensity * size * 0.12 : 0);
  const powerPulse = 0.6 + Math.sin(time * 3) * 0.4 + attackIntensity * 0.4;
  const lectureGesture = Math.sin(time * 2.5) * 0.2 + (isAttacking ? attackIntensity * 0.5 : 0);

  // Red/crimson power aura
  const auraGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.75);
  auraGrad.addColorStop(0, `rgba(239, 68, 68, ${powerPulse * 0.3})`);
  auraGrad.addColorStop(0.5, `rgba(185, 28, 28, ${powerPulse * 0.15})`);
  auraGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.75, 0, Math.PI * 2);
  ctx.fill();

  // Floating lecture notes (spectral)
  for (let i = 0; i < 4; i++) {
    const noteAngle = time * 1 + i * Math.PI * 0.5;
    const noteDist = size * 0.5;
    const nx = x + Math.cos(noteAngle) * noteDist;
    const ny = y - size * 0.1 + Math.sin(noteAngle) * noteDist * 0.35 + hover;
    ctx.save();
    ctx.translate(nx, ny);
    ctx.rotate(Math.sin(time * 2 + i) * 0.15);
    ctx.fillStyle = `rgba(254, 243, 199, ${
      0.5 + Math.sin(time * 3 + i) * 0.2
    })`;
    ctx.fillRect(-size * 0.06, -size * 0.08, size * 0.12, size * 0.16);
    // Arcane equations
    ctx.strokeStyle = `rgba(185, 28, 28, ${powerPulse})`;
    ctx.lineWidth = 1 * zoom;
    ctx.beginPath();
    ctx.moveTo(-size * 0.04, -size * 0.04);
    ctx.lineTo(size * 0.04, -size * 0.04);
    ctx.moveTo(-size * 0.03, 0);
    ctx.lineTo(size * 0.03, 0);
    ctx.stroke();
    ctx.restore();
  }

  // Shadow (weakened by undeath)
  ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.52, size * 0.35, size * 0.1, 0, 0, Math.PI * 2);
  ctx.fill();

  // Ancient tweed robes (tattered, elegant)
  const robeGrad = ctx.createLinearGradient(
    x - size * 0.4,
    y,
    x + size * 0.4,
    y
  );
  robeGrad.addColorStop(0, "#44403c");
  robeGrad.addColorStop(0.3, "#78716c");
  robeGrad.addColorStop(0.5, "#a8a29e");
  robeGrad.addColorStop(0.7, "#78716c");
  robeGrad.addColorStop(1, "#44403c");
  ctx.fillStyle = robeGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.38, y + size * 0.5);
  // Tattered bottom
  for (let i = 0; i < 6; i++) {
    const jagX = x - size * 0.38 + i * size * 0.152;
    const jagY =
      y +
      size * 0.5 +
      Math.sin(time * 3 + i) * size * 0.03 +
      (i % 2) * size * 0.04;
    ctx.lineTo(jagX, jagY);
  }
  ctx.quadraticCurveTo(
    x + size * 0.45,
    y,
    x + size * 0.22,
    y - size * 0.32 + hover * 0.2
  );
  ctx.lineTo(x - size * 0.22, y - size * 0.32 + hover * 0.2);
  ctx.quadraticCurveTo(x - size * 0.45, y, x - size * 0.38, y + size * 0.5);
  ctx.fill();

  // Elbow patches (leather, worn)
  ctx.fillStyle = "#57534e";
  ctx.beginPath();
  ctx.ellipse(
    x - size * 0.38,
    y + size * 0.08 + hover * 0.1,
    size * 0.07,
    size * 0.1,
    0.2,
    0,
    Math.PI * 2
  );
  ctx.ellipse(
    x + size * 0.38,
    y + size * 0.08 + hover * 0.1,
    size * 0.07,
    size * 0.1,
    -0.2,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Crimson academic hood/collar
  ctx.fillStyle = "#b91c1c";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.15, y - size * 0.28 + hover * 0.2);
  ctx.quadraticCurveTo(
    x,
    y - size * 0.15 + hover * 0.2,
    x + size * 0.15,
    y - size * 0.28 + hover * 0.2
  );
  ctx.lineTo(x + size * 0.12, y + size * 0.1);
  ctx.quadraticCurveTo(x, y + size * 0.2, x - size * 0.12, y + size * 0.1);
  ctx.fill();
  // Ancient sigil on collar
  ctx.fillStyle = `rgba(254, 243, 199, ${powerPulse})`;
  ctx.font = `${size * 0.1}px serif`;
  ctx.textAlign = "center";
  ctx.fillText("", x, y - size * 0.05 + hover * 0.2);

  // Bow tie (crimson, ethereal)
  ctx.fillStyle = "#dc2626";
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.22 + hover * 0.2);
  ctx.lineTo(x - size * 0.1, y - size * 0.26 + hover * 0.2);
  ctx.lineTo(x - size * 0.1, y - size * 0.18 + hover * 0.2);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.22 + hover * 0.2);
  ctx.lineTo(x + size * 0.1, y - size * 0.26 + hover * 0.2);
  ctx.lineTo(x + size * 0.1, y - size * 0.18 + hover * 0.2);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x, y - size * 0.22 + hover * 0.2, size * 0.025, 0, Math.PI * 2);
  ctx.fill();

  // Skeletal face with preserved flesh
  ctx.fillStyle = "#d6d3d1";
  ctx.beginPath();
  ctx.arc(x, y - size * 0.48 + hover, size * 0.22, 0, Math.PI * 2);
  ctx.fill();

  // Sunken, preserved features
  ctx.fillStyle = "rgba(68, 64, 60, 0.3)";
  ctx.beginPath();
  ctx.ellipse(
    x - size * 0.1,
    y - size * 0.42 + hover,
    size * 0.04,
    size * 0.06,
    0,
    0,
    Math.PI * 2
  );
  ctx.ellipse(
    x + size * 0.1,
    y - size * 0.42 + hover,
    size * 0.04,
    size * 0.06,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Ancient spectacles (gold, ornate)
  ctx.strokeStyle = "#b8860b";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.1, y - size * 0.5 + hover, size * 0.07, 0, Math.PI * 2);
  ctx.arc(x + size * 0.1, y - size * 0.5 + hover, size * 0.07, 0, Math.PI * 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x - size * 0.03, y - size * 0.5 + hover);
  ctx.lineTo(x + size * 0.03, y - size * 0.5 + hover);
  ctx.moveTo(x - size * 0.17, y - size * 0.5 + hover);
  ctx.lineTo(x - size * 0.22, y - size * 0.48 + hover);
  ctx.moveTo(x + size * 0.17, y - size * 0.5 + hover);
  ctx.lineTo(x + size * 0.22, y - size * 0.48 + hover);
  ctx.stroke();

  // Glowing red eyes behind spectacles
  ctx.fillStyle = "#ef4444";
  ctx.shadowColor = "#ef4444";
  ctx.shadowBlur = 8 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.1, y - size * 0.5 + hover, size * 0.035, 0, Math.PI * 2);
  ctx.arc(x + size * 0.1, y - size * 0.5 + hover, size * 0.035, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Distinguished but wispy white hair
  ctx.fillStyle = "#e7e5e4";
  ctx.beginPath();
  ctx.ellipse(
    x,
    y - size * 0.62 + hover,
    size * 0.18,
    size * 0.08,
    0,
    0,
    Math.PI
  );
  ctx.fill();
  // Side tufts
  ctx.beginPath();
  ctx.ellipse(
    x - size * 0.2,
    y - size * 0.48 + hover,
    size * 0.06,
    size * 0.12,
    0.3,
    0,
    Math.PI * 2
  );
  ctx.ellipse(
    x + size * 0.2,
    y - size * 0.48 + hover,
    size * 0.06,
    size * 0.12,
    -0.3,
    0,
    Math.PI * 2
  );
  ctx.fill();
  // Wispy strands
  ctx.strokeStyle = "#d6d3d1";
  ctx.lineWidth = 1.5 * zoom;
  for (let i = 0; i < 5; i++) {
    ctx.beginPath();
    ctx.moveTo(x - size * 0.1 + i * size * 0.05, y - size * 0.64 + hover);
    ctx.quadraticCurveTo(
      x - size * 0.1 + i * size * 0.05 + Math.sin(time * 2 + i) * size * 0.03,
      y - size * 0.72 + hover,
      x - size * 0.08 + i * size * 0.05,
      y - size * 0.7 + hover
    );
    ctx.stroke();
  }

  // Bushy ethereal eyebrows
  ctx.fillStyle = "#d6d3d1";
  ctx.beginPath();
  ctx.ellipse(
    x - size * 0.1,
    y - size * 0.58 + hover,
    size * 0.06,
    size * 0.025,
    -0.15,
    0,
    Math.PI * 2
  );
  ctx.ellipse(
    x + size * 0.1,
    y - size * 0.58 + hover,
    size * 0.06,
    size * 0.025,
    0.15,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Knowing skeletal smile
  ctx.fillStyle = "#44403c";
  ctx.beginPath();
  ctx.arc(
    x,
    y - size * 0.38 + hover,
    size * 0.06,
    0.1 * Math.PI,
    0.9 * Math.PI
  );
  ctx.fill();
  ctx.fillStyle = "#e7e5e4";
  ctx.fillRect(
    x - size * 0.05,
    y - size * 0.38 + hover,
    size * 0.1,
    size * 0.02
  );

  // Lecturing skeletal hand
  ctx.save();
  ctx.translate(x - size * 0.45, y - size * 0.1 + hover);
  ctx.rotate(-0.4 + lectureGesture);
  // Skeletal hand
  ctx.fillStyle = "#d6d3d1";
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.07, size * 0.05, 0, 0, Math.PI * 2);
  ctx.fill();
  // Pointing finger bone
  ctx.fillRect(-size * 0.02, -size * 0.18, size * 0.04, size * 0.18);
  // Magical spark at fingertip
  ctx.fillStyle = `rgba(239, 68, 68, ${powerPulse})`;
  ctx.shadowColor = "#ef4444";
  ctx.shadowBlur = 6 * zoom;
  ctx.beginPath();
  ctx.arc(0, -size * 0.2, size * 0.03, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // Ancient tome floating beside
  ctx.save();
  ctx.translate(
    x + size * 0.42,
    y - size * 0.15 + hover + Math.sin(time * 2.5) * 3
  );
  ctx.rotate(Math.sin(time * 1.5) * 0.1);
  ctx.fillStyle = "#7f1d1d";
  ctx.fillRect(-size * 0.08, -size * 0.1, size * 0.16, size * 0.2);
  ctx.fillStyle = "#fef3c7";
  ctx.fillRect(-size * 0.06, -size * 0.08, size * 0.12, size * 0.16);
  // Glowing text
  ctx.fillStyle = `rgba(239, 68, 68, ${powerPulse})`;
  ctx.font = `${size * 0.06}px serif`;
  ctx.textAlign = "center";
  ctx.fillText("", 0, size * 0.02);
  ctx.restore();
}

function drawDeanEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  // VOID ARCHON DEAN - Reality-bending administrator with absolute authority over space
  const hover = Math.sin(time * 1.5) * 5 * zoom + (isAttacking ? attackIntensity * size * 0.18 : 0);
  const powerPulse = 0.6 + Math.sin(time * 3) * 0.4 + attackIntensity * 0.4;
  const realityWarp = Math.sin(time * 2) * 0.06 + (isAttacking ? attackIntensity * 0.15 : 0);
  const voidTear = 0.5 + Math.sin(time * 4) * 0.3 + attackIntensity * 0.4;
  const authorityAura = 0.7 + Math.sin(time * 5) * 0.2 + attackIntensity * 0.3;

  // Reality fracturing around the dean
  ctx.save();
  for (let fracture = 0; fracture < 8; fracture++) {
    const fractureAngle = fracture * Math.PI / 4 + time * 0.3;
    const fractureLen = size * (0.4 + Math.sin(time * 2 + fracture) * 0.15);
    ctx.strokeStyle = `rgba(168, 85, 247, ${voidTear * 0.3})`;
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(x, y);
    let fx = x, fy = y;
    for (let seg = 0; seg < 5; seg++) {
      fx += Math.cos(fractureAngle + (Math.random() - 0.5) * 0.8) * fractureLen * 0.2;
      fy += Math.sin(fractureAngle + (Math.random() - 0.5) * 0.8) * fractureLen * 0.15;
      ctx.lineTo(fx, fy);
    }
    ctx.stroke();
  }
  ctx.restore();

  // Reality distortion aura - more dramatic warping
  ctx.strokeStyle = `rgba(168, 85, 247, ${powerPulse * 0.6})`;
  ctx.lineWidth = 3 * zoom;
  for (let i = 0; i < 4; i++) {
    const warpPhase = (time * 0.5 + i * 0.4) % 2;
    const warpSize = size * 0.45 + warpPhase * size * 0.45;
    ctx.globalAlpha = 0.6 * (1 - warpPhase / 2);
    ctx.beginPath();
    for (let a = 0; a < Math.PI * 2; a += 0.08) {
      const r = warpSize + Math.sin(a * 8 + time * 4) * size * 0.06;
      const wx = x + Math.cos(a) * r;
      const wy = y + Math.sin(a) * r * 0.55;
      if (a === 0) ctx.moveTo(wx, wy);
      else ctx.lineTo(wx, wy);
    }
    ctx.closePath();
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Deep void aura with multiple layers
  const auraGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.95);
  auraGrad.addColorStop(0, `rgba(139, 92, 246, ${powerPulse * 0.4})`);
  auraGrad.addColorStop(0.3, `rgba(168, 85, 247, ${powerPulse * 0.3})`);
  auraGrad.addColorStop(0.6, `rgba(91, 33, 182, ${powerPulse * 0.18})`);
  auraGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.95, 0, Math.PI * 2);
  ctx.fill();

  // Orbiting void shards with trails
  for (let i = 0; i < 8; i++) {
    const shardAngle = time * 0.9 + (i * Math.PI) / 4;
    const shardDist = size * 0.6 + Math.sin(time * 2.5 + i) * size * 0.1;
    const sx = x + Math.cos(shardAngle) * shardDist;
    const sy = y - size * 0.08 + Math.sin(shardAngle) * shardDist * 0.4 + hover * 0.4;
    // Trail
    ctx.strokeStyle = `rgba(168, 85, 247, ${0.2})`;
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(
      sx - Math.cos(shardAngle) * size * 0.08,
      sy - Math.sin(shardAngle) * size * 0.04
    );
    ctx.stroke();
    // Shard
    ctx.save();
    ctx.translate(sx, sy);
    ctx.rotate(time * 2.5 + i);
    ctx.fillStyle = `rgba(168, 85, 247, ${0.6 + Math.sin(time * 4 + i) * 0.3})`;
    ctx.shadowColor = "#a855f7";
    ctx.shadowBlur = 6 * zoom;
    ctx.beginPath();
    ctx.moveTo(0, -size * 0.05);
    ctx.lineTo(size * 0.025, 0);
    ctx.lineTo(0, size * 0.05);
    ctx.lineTo(-size * 0.025, 0);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();
  }

  // Void shadow beneath - reality warped
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.58, 0, x, y + size * 0.58, size * 0.55);
  shadowGrad.addColorStop(0, "rgba(30, 10, 60, 0.7)");
  shadowGrad.addColorStop(0.5, "rgba(0, 0, 0, 0.4)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.58, size * 0.5, size * 0.16, 0, 0, Math.PI * 2);
  ctx.fill();

  // Magnificent flowing robes with reality-warping edges
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(realityWarp);
  const robeGrad = ctx.createLinearGradient(-size * 0.5, -size * 0.45, size * 0.5, size * 0.6);
  robeGrad.addColorStop(0, "#0f0a2a");
  robeGrad.addColorStop(0.2, "#1e1b4b");
  robeGrad.addColorStop(0.4, "#312e81");
  robeGrad.addColorStop(0.5, "#3730a3");
  robeGrad.addColorStop(0.6, "#312e81");
  robeGrad.addColorStop(0.8, "#1e1b4b");
  robeGrad.addColorStop(1, "#0f0a2a");
  ctx.fillStyle = robeGrad;
  ctx.beginPath();
  ctx.moveTo(-size * 0.48, size * 0.58);
  // Dramatically flowing bottom edge with void wisps
  for (let i = 0; i < 10; i++) {
    const waveX = -size * 0.48 + i * size * 0.096;
    const waveY = size * 0.58 + Math.sin(time * 4 + i * 1.2) * size * 0.05 + (i % 2) * size * 0.04 + (i % 3) * size * 0.02;
    ctx.lineTo(waveX, waveY);
  }
  ctx.quadraticCurveTo(size * 0.6, 0, size * 0.3, -size * 0.42 + hover * 0.15);
  ctx.lineTo(-size * 0.3, -size * 0.42 + hover * 0.15);
  ctx.quadraticCurveTo(-size * 0.6, 0, -size * 0.48, size * 0.58);
  ctx.fill();
  ctx.restore();

  // Void energy patterns on robe
  ctx.strokeStyle = `rgba(168, 85, 247, ${voidTear * 0.5})`;
  ctx.lineWidth = 2 * zoom;
  for (let v = 0; v < 6; v++) {
    const veinX = x - size * 0.3 + v * size * 0.12;
    ctx.beginPath();
    ctx.moveTo(veinX, y - size * 0.2 + hover * 0.1);
    ctx.quadraticCurveTo(
      veinX + Math.sin(time * 2 + v) * size * 0.05,
      y + size * 0.1,
      veinX + Math.cos(v) * size * 0.08,
      y + size * 0.4
    );
    ctx.stroke();
  }

  // Ornate gold and purple trim with gems
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 4.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.2, y - size * 0.36 + hover * 0.15);
  ctx.lineTo(x - size * 0.25, y + size * 0.48);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.2, y - size * 0.36 + hover * 0.15);
  ctx.lineTo(x + size * 0.25, y + size * 0.48);
  ctx.stroke();
  // Gem accents on trim
  ctx.fillStyle = "#a855f7";
  ctx.shadowColor = "#a855f7";
  ctx.shadowBlur = 4 * zoom;
  for (let g = 0; g < 3; g++) {
    ctx.beginPath();
    ctx.arc(x - size * 0.225, y + size * 0.05 + g * size * 0.15, size * 0.02, 0, Math.PI * 2);
    ctx.arc(x + size * 0.225, y + size * 0.05 + g * size * 0.15, size * 0.02, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.shadowBlur = 0;

  // Magnificent academic collar with massive central gem
  const collarGrad = ctx.createLinearGradient(x - size * 0.25, y - size * 0.35, x + size * 0.25, y);
  collarGrad.addColorStop(0, "#b8860b");
  collarGrad.addColorStop(0.5, "#c9a227");
  collarGrad.addColorStop(1, "#b8860b");
  ctx.fillStyle = collarGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.25, y - size * 0.36 + hover * 0.15);
  ctx.quadraticCurveTo(x, y - size * 0.2 + hover * 0.15, x + size * 0.25, y - size * 0.36 + hover * 0.15);
  ctx.lineTo(x + size * 0.2, y - size * 0.08 + hover * 0.15);
  ctx.quadraticCurveTo(x, y + size * 0.05 + hover * 0.15, x - size * 0.2, y - size * 0.08 + hover * 0.15);
  ctx.fill();
  // Central void gem
  ctx.fillStyle = "#a855f7";
  ctx.shadowColor = "#a855f7";
  ctx.shadowBlur = 12 * zoom;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.3 + hover * 0.15);
  ctx.lineTo(x + size * 0.07, y - size * 0.18 + hover * 0.15);
  ctx.lineTo(x, y - size * 0.08 + hover * 0.15);
  ctx.lineTo(x - size * 0.07, y - size * 0.18 + hover * 0.15);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Inner gem glow
  ctx.fillStyle = "#e9d5ff";
  ctx.beginPath();
  ctx.arc(x, y - size * 0.19 + hover * 0.15, size * 0.02, 0, Math.PI * 2);
  ctx.fill();

  // Commanding face - otherworldly beauty
  const faceGrad = ctx.createRadialGradient(x, y - size * 0.55 + hover, 0, x, y - size * 0.55 + hover, size * 0.26);
  faceGrad.addColorStop(0, "#f3e8ff");
  faceGrad.addColorStop(0.5, "#e9d5ff");
  faceGrad.addColorStop(1, "#d8b4fe");
  ctx.fillStyle = faceGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.55 + hover, size * 0.26, 0, Math.PI * 2);
  ctx.fill();

  // Distinguished but otherworldly features - sunken cheeks
  ctx.fillStyle = "rgba(91, 33, 182, 0.2)";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.13, y - size * 0.48 + hover, size * 0.045, size * 0.07, 0.1, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.13, y - size * 0.48 + hover, size * 0.045, size * 0.07, -0.1, 0, Math.PI * 2);
  ctx.fill();

  // Intense glowing eyes of absolute authority
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.09, y - size * 0.57 + hover, size * 0.055, size * 0.065, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.09, y - size * 0.57 + hover, size * 0.055, size * 0.065, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#a855f7";
  ctx.shadowColor = "#a855f7";
  ctx.shadowBlur = 12 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.09, y - size * 0.57 + hover, size * 0.035, 0, Math.PI * 2);
  ctx.arc(x + size * 0.09, y - size * 0.57 + hover, size * 0.035, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Void pupils
  ctx.fillStyle = "#1e0a3a";
  ctx.beginPath();
  ctx.arc(x - size * 0.09, y - size * 0.57 + hover, size * 0.015, 0, Math.PI * 2);
  ctx.arc(x + size * 0.09, y - size * 0.57 + hover, size * 0.015, 0, Math.PI * 2);
  ctx.fill();

  // Stern furrowed brows
  ctx.strokeStyle = "#581c87";
  ctx.lineWidth = 3.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.17, y - size * 0.62 + hover);
  ctx.quadraticCurveTo(x - size * 0.09, y - size * 0.67, x - size * 0.02, y - size * 0.63 + hover);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.17, y - size * 0.62 + hover);
  ctx.quadraticCurveTo(x + size * 0.09, y - size * 0.67, x + size * 0.02, y - size * 0.63 + hover);
  ctx.stroke();

  // Stern authoritative mouth
  ctx.strokeStyle = "#6b21a8";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.09, y - size * 0.43 + hover);
  ctx.lineTo(x + size * 0.09, y - size * 0.43 + hover);
  ctx.stroke();

  // Distinguished hair/crown of void energy
  ctx.fillStyle = "#1e1b4b";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.72 + hover, size * 0.2, size * 0.1, 0, 0, Math.PI);
  ctx.fill();
  // Void energy tendrils from head
  ctx.strokeStyle = `rgba(168, 85, 247, ${authorityAura * 0.5})`;
  ctx.lineWidth = 2 * zoom;
  for (let t = 0; t < 5; t++) {
    const tendrilAngle = -Math.PI * 0.4 + t * Math.PI * 0.2;
    ctx.beginPath();
    ctx.moveTo(x + Math.cos(tendrilAngle) * size * 0.15, y - size * 0.72 + hover);
    ctx.quadraticCurveTo(
      x + Math.cos(tendrilAngle) * size * 0.25 + Math.sin(time * 3 + t) * size * 0.05,
      y - size * 0.85 + hover,
      x + Math.cos(tendrilAngle) * size * 0.2,
      y - size * 0.92 + hover + Math.sin(time * 4 + t) * size * 0.03
    );
    ctx.stroke();
  }

  // Elaborate mortarboard floating with void energy
  ctx.save();
  ctx.translate(x, y - size * 0.78 + hover + Math.sin(time * 2.5) * 4);
  ctx.rotate(Math.sin(time * 1.8) * 0.04);
  // Cap base
  ctx.fillStyle = "#1e1b4b";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.05, size * 0.22, size * 0.09, 0, 0, Math.PI * 2);
  ctx.fill();
  // Diamond-shaped board with ornate edges
  ctx.fillStyle = "#312e81";
  ctx.beginPath();
  ctx.moveTo(-size * 0.28, 0);
  ctx.lineTo(0, -size * 0.12);
  ctx.lineTo(size * 0.28, 0);
  ctx.lineTo(0, size * 0.12);
  ctx.closePath();
  ctx.fill();
  // Golden ornate border
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 3 * zoom;
  ctx.stroke();
  // Corner gems
  ctx.fillStyle = "#a855f7";
  ctx.beginPath();
  ctx.arc(-size * 0.28, 0, size * 0.025, 0, Math.PI * 2);
  ctx.arc(size * 0.28, 0, size * 0.025, 0, Math.PI * 2);
  ctx.arc(0, -size * 0.12, size * 0.025, 0, Math.PI * 2);
  ctx.arc(0, size * 0.12, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  // Central power gem
  ctx.fillStyle = "#a855f7";
  ctx.shadowColor = "#a855f7";
  ctx.shadowBlur = 10 * zoom;
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.04, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Ornate golden tassel
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 4 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.bezierCurveTo(
    size * 0.15 + Math.sin(time * 5) * size * 0.06,
    size * 0.1,
    size * 0.2 + Math.cos(time * 4) * size * 0.04,
    size * 0.2,
    size * 0.17,
    size * 0.3
  );
  ctx.stroke();
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.arc(size * 0.17, size * 0.32, size * 0.045, 0, Math.PI * 2);
  ctx.fill();
  // Tassel threads
  for (let i = 0; i < 7; i++) {
    ctx.strokeStyle = "#c9a227";
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(size * 0.17, size * 0.34);
    ctx.lineTo(
      size * 0.13 + i * size * 0.013 + Math.sin(time * 6 + i) * size * 0.012,
      size * 0.45
    );
    ctx.stroke();
  }
  ctx.restore();

  // Staff of absolute office - scepter of void authority
  ctx.save();
  ctx.translate(x + size * 0.5, y - size * 0.12 + hover);
  ctx.rotate(0.18 + Math.sin(time * 2.2) * 0.06);
  // Ornate staff body
  const staffGrad = ctx.createLinearGradient(0, -size * 0.4, 0, size * 0.4);
  staffGrad.addColorStop(0, "#1e1b4b");
  staffGrad.addColorStop(0.5, "#312e81");
  staffGrad.addColorStop(1, "#1e1b4b");
  ctx.fillStyle = staffGrad;
  ctx.fillRect(-size * 0.03, -size * 0.4, size * 0.06, size * 0.8);
  // Gold rings and decorations
  ctx.fillStyle = "#c9a227";
  ctx.fillRect(-size * 0.04, -size * 0.35, size * 0.08, size * 0.05);
  ctx.fillRect(-size * 0.04, -size * 0.05, size * 0.08, size * 0.05);
  ctx.fillRect(-size * 0.04, size * 0.25, size * 0.08, size * 0.05);
  // Spiral gold inlay
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.5 * zoom;
  for (let s = 0; s < 10; s++) {
    ctx.beginPath();
    ctx.moveTo(-size * 0.03, -size * 0.28 + s * size * 0.06);
    ctx.lineTo(size * 0.03, -size * 0.25 + s * size * 0.06);
    ctx.stroke();
  }
  // Crown top
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.moveTo(-size * 0.07, -size * 0.4);
  ctx.lineTo(-size * 0.05, -size * 0.52);
  ctx.lineTo(-size * 0.02, -size * 0.45);
  ctx.lineTo(0, -size * 0.55);
  ctx.lineTo(size * 0.02, -size * 0.45);
  ctx.lineTo(size * 0.05, -size * 0.52);
  ctx.lineTo(size * 0.07, -size * 0.4);
  ctx.closePath();
  ctx.fill();
  // Massive void power orb
  ctx.fillStyle = "#a855f7";
  ctx.shadowColor = "#a855f7";
  ctx.shadowBlur = 15 * zoom;
  ctx.beginPath();
  ctx.arc(0, -size * 0.62, size * 0.08, 0, Math.PI * 2);
  ctx.fill();
  // Inner orb details
  ctx.fillStyle = "#e9d5ff";
  ctx.beginPath();
  ctx.arc(-size * 0.02, -size * 0.64, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  // Void energy swirling in orb
  ctx.strokeStyle = "#1e1b4b";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.arc(0, -size * 0.62, size * 0.05, time * 3, time * 3 + Math.PI);
  ctx.stroke();
  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawMascotEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  isFlying: boolean,
  attackPhase: number = 0
) {
  // TEMPEST GRIFFIN - Elemental chaos beast with storm wings and lightning breath
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const swoop = Math.sin(time * 4) * 5 * zoom + (isAttacking ? attackIntensity * size * 0.2 : 0);
  const wingFlap = Math.sin(time * 12) * 0.55;
  const stormPulse = 0.6 + Math.sin(time * 6) * 0.4;
  const lightningFlash = Math.sin(time * 15) > 0.7 ? 1 : 0.3;

  // Storm cloud aura
  ctx.save();
  for (let cloud = 0; cloud < 5; cloud++) {
    const cloudAngle = time * 0.5 + cloud * Math.PI * 0.4;
    const cloudDist = size * 0.6 + Math.sin(time * 2 + cloud) * size * 0.1;
    const cx = x + Math.cos(cloudAngle) * cloudDist;
    const cy = y - size * 0.1 + Math.sin(cloudAngle) * cloudDist * 0.4;
    ctx.fillStyle = `rgba(55, 65, 81, ${0.3 - cloud * 0.05})`;
    ctx.beginPath();
    ctx.arc(cx, cy, size * 0.1, 0, Math.PI * 2);
    ctx.arc(cx + size * 0.05, cy - size * 0.03, size * 0.07, 0, Math.PI * 2);
    ctx.arc(cx - size * 0.04, cy + size * 0.02, size * 0.06, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();

  // Lightning bolts in aura
  if (lightningFlash > 0.5) {
    ctx.strokeStyle = `rgba(103, 232, 249, ${lightningFlash})`;
    ctx.lineWidth = 2 * zoom;
    for (let bolt = 0; bolt < 3; bolt++) {
      const boltAngle = time * 2 + bolt * Math.PI * 0.67;
      ctx.beginPath();
      let bx = x + Math.cos(boltAngle) * size * 0.3;
      let by = y + Math.sin(boltAngle) * size * 0.25;
      ctx.moveTo(bx, by);
      for (let seg = 0; seg < 3; seg++) {
        bx += (Math.random() - 0.5) * size * 0.15;
        by += size * 0.08;
        ctx.lineTo(bx, by);
      }
      ctx.stroke();
    }
  }

  // Blazing chaos aura - more intense
  const auraGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.9);
  auraGrad.addColorStop(0, `rgba(34, 211, 238, ${stormPulse * 0.4})`);
  auraGrad.addColorStop(0.3, `rgba(6, 182, 212, ${stormPulse * 0.3})`);
  auraGrad.addColorStop(0.6, `rgba(8, 145, 178, ${stormPulse * 0.15})`);
  auraGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.9, 0, Math.PI * 2);
  ctx.fill();

  // Spectral fire particles - more numerous
  for (let i = 0; i < 12; i++) {
    const particlePhase = (time * 2.5 + i * 0.25) % 1.5;
    const px = x + Math.sin(time * 3.5 + i * 1.0) * size * 0.45;
    const py = y + size * 0.25 - particlePhase * size * 0.6;
    ctx.fillStyle = `rgba(34, 211, 238, ${(1 - particlePhase / 1.5) * 0.7})`;
    ctx.shadowColor = "#22d3ee";
    ctx.shadowBlur = 4 * zoom;
    ctx.beginPath();
    ctx.arc(px, py, size * 0.035 * (1 - particlePhase / 2), 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Magnificent storm wings
  if (isFlying) {
    // Left wing - feathered with lightning veins
    ctx.save();
    ctx.translate(x - size * 0.28, y - size * 0.12 + swoop * 0.3);
    ctx.rotate(-0.45 - wingFlap);
    const wingGradL = ctx.createLinearGradient(0, 0, -size * 0.9, 0);
    wingGradL.addColorStop(0, "#0e7490");
    wingGradL.addColorStop(0.3, "#0891b2");
    wingGradL.addColorStop(0.6, "#06b6d4");
    wingGradL.addColorStop(1, "#22d3ee");
    ctx.fillStyle = wingGradL;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.quadraticCurveTo(-size * 0.35, -size * 0.45, -size * 0.8, -size * 0.3);
    ctx.lineTo(-size * 0.9, -size * 0.18);
    ctx.lineTo(-size * 0.72, -size * 0.06);
    ctx.lineTo(-size * 0.85, size * 0.06);
    ctx.lineTo(-size * 0.62, size * 0.1);
    ctx.lineTo(-size * 0.68, size * 0.22);
    ctx.lineTo(-size * 0.4, size * 0.15);
    ctx.quadraticCurveTo(-size * 0.18, size * 0.18, 0, size * 0.12);
    ctx.closePath();
    ctx.fill();
    // Wing feather details with lightning
    ctx.strokeStyle = "#67e8f9";
    ctx.lineWidth = 2 * zoom;
    for (let f = 0; f < 6; f++) {
      ctx.beginPath();
      ctx.moveTo(-size * 0.12 - f * size * 0.13, size * 0.06);
      ctx.lineTo(-size * 0.22 - f * size * 0.15, -size * 0.18);
      ctx.stroke();
    }
    // Lightning veins on wing
    ctx.strokeStyle = `rgba(165, 243, 252, ${lightningFlash * 0.6})`;
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(-size * 0.2, 0);
    ctx.lineTo(-size * 0.35, -size * 0.1);
    ctx.lineTo(-size * 0.5, -size * 0.08);
    ctx.lineTo(-size * 0.65, -size * 0.15);
    ctx.stroke();
    ctx.restore();

    // Right wing
    ctx.save();
    ctx.translate(x + size * 0.28, y - size * 0.12 + swoop * 0.3);
    ctx.rotate(0.45 + wingFlap);
    const wingGradR = ctx.createLinearGradient(0, 0, size * 0.9, 0);
    wingGradR.addColorStop(0, "#0e7490");
    wingGradR.addColorStop(0.3, "#0891b2");
    wingGradR.addColorStop(0.6, "#06b6d4");
    wingGradR.addColorStop(1, "#22d3ee");
    ctx.fillStyle = wingGradR;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.quadraticCurveTo(size * 0.35, -size * 0.45, size * 0.8, -size * 0.3);
    ctx.lineTo(size * 0.9, -size * 0.18);
    ctx.lineTo(size * 0.72, -size * 0.06);
    ctx.lineTo(size * 0.85, size * 0.06);
    ctx.lineTo(size * 0.62, size * 0.1);
    ctx.lineTo(size * 0.68, size * 0.22);
    ctx.lineTo(size * 0.4, size * 0.15);
    ctx.quadraticCurveTo(size * 0.18, size * 0.18, 0, size * 0.12);
    ctx.closePath();
    ctx.fill();
    // Wing feather details
    ctx.strokeStyle = "#67e8f9";
    ctx.lineWidth = 2 * zoom;
    for (let f = 0; f < 6; f++) {
      ctx.beginPath();
      ctx.moveTo(size * 0.12 + f * size * 0.13, size * 0.06);
      ctx.lineTo(size * 0.22 + f * size * 0.15, -size * 0.18);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Storm tail with lightning
  ctx.save();
  ctx.translate(x + size * 0.28, y + size * 0.22 + swoop * 0.2);
  ctx.rotate(Math.sin(time * 5) * 0.35);
  // Tail base
  const tailGrad = ctx.createLinearGradient(0, 0, size * 0.6, 0);
  tailGrad.addColorStop(0, "#0e7490");
  tailGrad.addColorStop(0.5, "#0891b2");
  tailGrad.addColorStop(1, "#22d3ee");
  ctx.fillStyle = tailGrad;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.04);
  ctx.quadraticCurveTo(size * 0.35, -size * 0.08, size * 0.55, 0);
  ctx.quadraticCurveTo(size * 0.35, size * 0.08, 0, size * 0.04);
  ctx.fill();
  // Tail flames - more elaborate
  for (let i = 0; i < 4; i++) {
    const flameY = Math.sin(time * 8 + i * 1.2) * size * 0.06;
    ctx.fillStyle = `rgba(103, 232, 249, ${0.7 - i * 0.12})`;
    ctx.shadowColor = "#67e8f9";
    ctx.shadowBlur = 4 * zoom;
    ctx.beginPath();
    ctx.moveTo(size * 0.5 + i * size * 0.1, flameY);
    ctx.quadraticCurveTo(
      size * 0.6 + i * size * 0.12,
      flameY - size * 0.1,
      size * 0.68 + i * size * 0.14,
      flameY
    );
    ctx.quadraticCurveTo(
      size * 0.6 + i * size * 0.12,
      flameY + size * 0.08,
      size * 0.5 + i * size * 0.1,
      flameY
    );
    ctx.fill();
    ctx.shadowBlur = 0;
  }
  ctx.restore();

  // Powerful leonine body with armored scales
  const bodyGrad = ctx.createRadialGradient(x, y + swoop * 0.2, 0, x, y + swoop * 0.2, size * 0.48);
  bodyGrad.addColorStop(0, "#155e75");
  bodyGrad.addColorStop(0.4, "#0e7490");
  bodyGrad.addColorStop(0.7, "#0891b2");
  bodyGrad.addColorStop(1, "#06b6d4");
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.06 + swoop * 0.2, size * 0.38, size * 0.44, 0, 0, Math.PI * 2);
  ctx.fill();
  // Scale pattern
  ctx.strokeStyle = "rgba(6, 182, 212, 0.4)";
  ctx.lineWidth = 1 * zoom;
  for (let row = 0; row < 4; row++) {
    for (let col = 0; col < 5; col++) {
      const sx = x - size * 0.2 + col * size * 0.1 + (row % 2) * size * 0.05;
      const sy = y - size * 0.1 + row * size * 0.12 + swoop * 0.2;
      ctx.beginPath();
      ctx.arc(sx, sy, size * 0.04, 0.5 * Math.PI, 1.5 * Math.PI);
      ctx.stroke();
    }
  }

  // Chest feathers with luminescence
  const chestGrad = ctx.createRadialGradient(x, y - size * 0.08 + swoop * 0.2, 0, x, y - size * 0.08 + swoop * 0.2, size * 0.24);
  chestGrad.addColorStop(0, "#cffafe");
  chestGrad.addColorStop(0.5, "#a5f3fc");
  chestGrad.addColorStop(1, "#67e8f9");
  ctx.fillStyle = chestGrad;
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.08 + swoop * 0.2, size * 0.2, size * 0.25, 0, 0, Math.PI * 2);
  ctx.fill();
  // Feather texture - more detailed
  ctx.strokeStyle = "#22d3ee";
  ctx.lineWidth = 1.5 * zoom;
  for (let i = 0; i < 6; i++) {
    ctx.beginPath();
    ctx.arc(x, y + size * 0.06 + swoop * 0.2, size * 0.09 + i * size * 0.028, 0.55 * Math.PI, 0.45 * Math.PI, true);
    ctx.stroke();
  }

  // Majestic eagle head with crest
  const headGrad = ctx.createRadialGradient(x, y - size * 0.4 + swoop, 0, x, y - size * 0.4 + swoop, size * 0.28);
  headGrad.addColorStop(0, "#0e7490");
  headGrad.addColorStop(0.6, "#0891b2");
  headGrad.addColorStop(1, "#06b6d4");
  ctx.fillStyle = headGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.4 + swoop, size * 0.26, 0, Math.PI * 2);
  ctx.fill();

  // Crown crest feathers - more elaborate
  ctx.fillStyle = "#22d3ee";
  ctx.shadowColor = "#22d3ee";
  ctx.shadowBlur = 4 * zoom;
  for (let i = 0; i < 9; i++) {
    const crestAngle = -Math.PI * 0.45 + i * Math.PI * 0.11;
    const crestLen = size * (0.18 + Math.sin(time * 6 + i * 0.8) * 0.04);
    ctx.save();
    ctx.translate(x + Math.cos(crestAngle) * size * 0.2, y - size * 0.55 + swoop);
    ctx.rotate(crestAngle + Math.PI * 0.5);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-size * 0.035, -crestLen);
    ctx.lineTo(0, -crestLen * 1.1);
    ctx.lineTo(size * 0.035, -crestLen);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
  ctx.shadowBlur = 0;

  // Fierce glowing eyes with lightning reflection
  ctx.fillStyle = "#fef08a";
  ctx.shadowColor = "#fef08a";
  ctx.shadowBlur = 12 * zoom;
  ctx.beginPath();
  ctx.ellipse(x - size * 0.1, y - size * 0.42 + swoop, size * 0.072, size * 0.055, -0.15, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.1, y - size * 0.42 + swoop, size * 0.072, size * 0.055, 0.15, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Predator slit pupils
  ctx.fillStyle = "#1c1917";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.1, y - size * 0.42 + swoop, size * 0.022, size * 0.045, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.1, y - size * 0.42 + swoop, size * 0.022, size * 0.045, 0, 0, Math.PI * 2);
  ctx.fill();
  // Lightning reflection in eyes
  ctx.fillStyle = `rgba(103, 232, 249, ${lightningFlash * 0.5})`;
  ctx.beginPath();
  ctx.arc(x - size * 0.12, y - size * 0.44 + swoop, size * 0.015, 0, Math.PI * 2);
  ctx.arc(x + size * 0.08, y - size * 0.44 + swoop, size * 0.015, 0, Math.PI * 2);
  ctx.fill();

  // Sharp hooked beak with golden sheen
  const beakGrad = ctx.createLinearGradient(x - size * 0.1, y - size * 0.35, x + size * 0.1, y - size * 0.2);
  beakGrad.addColorStop(0, "#f59e0b");
  beakGrad.addColorStop(0.5, "#fbbf24");
  beakGrad.addColorStop(1, "#f59e0b");
  ctx.fillStyle = beakGrad;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.37 + swoop);
  ctx.quadraticCurveTo(x - size * 0.1, y - size * 0.34 + swoop, x - size * 0.06, y - size * 0.22 + swoop);
  ctx.lineTo(x, y - size * 0.17 + swoop);
  ctx.lineTo(x + size * 0.06, y - size * 0.22 + swoop);
  ctx.quadraticCurveTo(x + size * 0.1, y - size * 0.34 + swoop, x, y - size * 0.37 + swoop);
  ctx.fill();
  // Beak detail
  ctx.strokeStyle = "#d97706";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.37 + swoop);
  ctx.lineTo(x, y - size * 0.19 + swoop);
  ctx.stroke();
  // Beak hook
  ctx.fillStyle = "#d97706";
  ctx.beginPath();
  ctx.arc(x, y - size * 0.18 + swoop, size * 0.02, 0, Math.PI);
  ctx.fill();

  // Powerful talons with golden claws
  for (let side of [-1, 1]) {
    ctx.save();
    ctx.translate(x + side * size * 0.22, y + size * 0.44 + swoop * 0.1);
    // Feathered leg
    const legGrad = ctx.createLinearGradient(0, -size * 0.18, 0, 0);
    legGrad.addColorStop(0, "#0891b2");
    legGrad.addColorStop(1, "#0e7490");
    ctx.fillStyle = legGrad;
    ctx.fillRect(-size * 0.045, -size * 0.18, size * 0.09, size * 0.18);
    // Leg scales
    ctx.strokeStyle = "#06b6d4";
    ctx.lineWidth = 1 * zoom;
    for (let s = 0; s < 4; s++) {
      ctx.beginPath();
      ctx.moveTo(-size * 0.04, -size * 0.15 + s * size * 0.04);
      ctx.lineTo(size * 0.04, -size * 0.13 + s * size * 0.04);
      ctx.stroke();
    }
    // Golden talons
    ctx.fillStyle = "#fbbf24";
    ctx.shadowColor = "#fbbf24";
    ctx.shadowBlur = 2 * zoom;
    for (let t = 0; t < 3; t++) {
      ctx.beginPath();
      ctx.moveTo(-size * 0.045 + t * size * 0.045, 0);
      ctx.lineTo(-size * 0.055 + t * size * 0.055, size * 0.14);
      ctx.lineTo(-size * 0.02 + t * size * 0.045, 0);
      ctx.fill();
    }
    ctx.shadowBlur = 0;
    ctx.restore();
  }

  // Blazing trail effect (for flying) - more dramatic
  if (isFlying) {
    ctx.globalAlpha = 0.5;
    for (let t = 1; t < 5; t++) {
      ctx.fillStyle = `rgba(34, 211, 238, ${0.35 - t * 0.07})`;
      ctx.beginPath();
      ctx.ellipse(
        x + t * 7,
        y + t * 5 + swoop * 0.2,
        size * 0.28 - t * size * 0.045,
        size * 0.34 - t * size * 0.06,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
}

function drawDefaultEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // VOID ACOLYTE - Mysterious shadowy figure with dark energy
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const bob = Math.sin(time * 4) * 3 * zoom + (isAttacking ? attackIntensity * size * 0.1 : 0);
  const voidPulse = 0.5 + Math.sin(time * 5) * 0.3;

  // Dark void aura
  const auraGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.6);
  auraGrad.addColorStop(0, `rgba(55, 48, 163, ${voidPulse * 0.3})`);
  auraGrad.addColorStop(0.6, `rgba(30, 27, 75, ${voidPulse * 0.15})`);
  auraGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.6, 0, Math.PI * 2);
  ctx.fill();

  // Floating dark particles
  for (let i = 0; i < 4; i++) {
    const particleAngle = time * 2 + i * Math.PI * 0.5;
    const particleDist = size * 0.35 + Math.sin(time * 3 + i) * size * 0.08;
    const px = x + Math.cos(particleAngle) * particleDist;
    const py = y + Math.sin(particleAngle) * particleDist * 0.5;
    ctx.fillStyle = `rgba(99, 102, 241, ${0.4 + Math.sin(time * 4 + i) * 0.2})`;
    ctx.beginPath();
    ctx.arc(px, py, size * 0.02, 0, Math.PI * 2);
    ctx.fill();
  }

  // Shadow beneath
  ctx.fillStyle = "rgba(0, 0, 0, 0.35)";
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.48, size * 0.28, size * 0.09, 0, 0, Math.PI * 2);
  ctx.fill();

  // Shadowy robes
  const robeGrad = ctx.createLinearGradient(
    x - size * 0.3,
    y,
    x + size * 0.3,
    y
  );
  robeGrad.addColorStop(0, "#1e1b4b");
  robeGrad.addColorStop(0.3, "#312e81");
  robeGrad.addColorStop(0.5, "#3730a3");
  robeGrad.addColorStop(0.7, "#312e81");
  robeGrad.addColorStop(1, "#1e1b4b");
  ctx.fillStyle = robeGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.32, y + size * 0.45);
  ctx.quadraticCurveTo(
    x - size * 0.35,
    y,
    x - size * 0.12,
    y - size * 0.28 + bob * 0.3
  );
  ctx.lineTo(x + size * 0.12, y - size * 0.28 + bob * 0.3);
  ctx.quadraticCurveTo(x + size * 0.35, y, x + size * 0.32, y + size * 0.45);
  // Tattered bottom
  for (let i = 0; i < 4; i++) {
    const jagX = x - size * 0.32 + i * size * 0.16;
    const jagY = y + size * 0.45 + (i % 2) * size * 0.04;
    ctx.lineTo(jagX, jagY);
  }
  ctx.closePath();
  ctx.fill();

  // Arcane trim
  ctx.strokeStyle = `rgba(99, 102, 241, ${voidPulse * 0.7})`;
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.2 + bob * 0.3);
  ctx.lineTo(x, y + size * 0.35);
  ctx.stroke();

  // Hood
  ctx.fillStyle = "#1e1b4b";
  ctx.beginPath();
  ctx.ellipse(
    x,
    y - size * 0.3 + bob * 0.3,
    size * 0.18,
    size * 0.12,
    0,
    Math.PI,
    0
  );
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x - size * 0.18, y - size * 0.3 + bob * 0.3);
  ctx.quadraticCurveTo(x - size * 0.22, y - size * 0.1, x - size * 0.15, y);
  ctx.lineTo(x - size * 0.1, y - size * 0.15);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.18, y - size * 0.3 + bob * 0.3);
  ctx.quadraticCurveTo(x + size * 0.22, y - size * 0.1, x + size * 0.15, y);
  ctx.lineTo(x + size * 0.1, y - size * 0.15);
  ctx.fill();

  // Pale face in shadow
  ctx.fillStyle = "#c7d2fe";
  ctx.beginPath();
  ctx.arc(x, y - size * 0.35 + bob, size * 0.14, 0, Math.PI * 2);
  ctx.fill();

  // Glowing eyes
  ctx.fillStyle = "#6366f1";
  ctx.shadowColor = "#6366f1";
  ctx.shadowBlur = 6 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.05, y - size * 0.37 + bob, size * 0.025, 0, Math.PI * 2);
  ctx.arc(x + size * 0.05, y - size * 0.37 + bob, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Mysterious smile
  ctx.strokeStyle = "#4338ca";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.arc(
    x,
    y - size * 0.28 + bob,
    size * 0.04,
    0.15 * Math.PI,
    0.85 * Math.PI
  );
  ctx.stroke();

  // Small floating orb in hand
  ctx.fillStyle = `rgba(99, 102, 241, ${voidPulse})`;
  ctx.shadowColor = "#6366f1";
  ctx.shadowBlur = 8 * zoom;
  ctx.beginPath();
  ctx.arc(
    x + size * 0.22,
    y + size * 0.05 + bob * 0.5,
    size * 0.05,
    0,
    Math.PI * 2
  );
  ctx.fill();
  ctx.shadowBlur = 0;
}

// ============================================================================
// NEW ENEMY TYPES - Fantasy-style detailed sprites
// ============================================================================

function drawTrusteeEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // MAMMON'S CHOSEN - Corruption incarnate with gold-blood veins and wealth magic
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const float = Math.sin(time * 1.5) * 5 * zoom + (isAttacking ? attackIntensity * size * 0.15 : 0);
  const goldPulse = 0.7 + Math.sin(time * 4) * 0.3;
  const wealthAura = 0.5 + Math.sin(time * 3) * 0.3;
  const corruptionPulse = 0.6 + Math.sin(time * 5) * 0.3;
  const greedAura = 0.5 + Math.sin(time * 2.5) * 0.4;

  // Golden corruption tendrils reaching outward
  ctx.save();
  for (let tendril = 0; tendril < 6; tendril++) {
    const tendrilAngle = tendril * Math.PI / 3 + time * 0.2;
    ctx.strokeStyle = `rgba(251, 191, 36, ${wealthAura * 0.4})`;
    ctx.lineWidth = 2.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(x, y);
    let tx = x, ty = y;
    for (let seg = 0; seg < 4; seg++) {
      tx += Math.cos(tendrilAngle + Math.sin(time * 2 + seg) * 0.3) * size * 0.15;
      ty += Math.sin(tendrilAngle + Math.sin(time * 2 + seg) * 0.3) * size * 0.12;
      ctx.lineTo(tx, ty);
    }
    ctx.stroke();
  }
  ctx.restore();

  // Golden reality distortion field - more elaborate
  ctx.strokeStyle = `rgba(234, 179, 8, ${wealthAura * 0.6})`;
  ctx.lineWidth = 2.5 * zoom;
  for (let i = 0; i < 4; i++) {
    const ringPhase = (time * 0.6 + i * 0.35) % 2;
    const ringSize = size * 0.4 + ringPhase * size * 0.4;
    ctx.globalAlpha = 0.6 * (1 - ringPhase / 2);
    ctx.beginPath();
    // Irregular ring shape
    for (let a = 0; a < Math.PI * 2; a += 0.1) {
      const r = ringSize + Math.sin(a * 5 + time * 3) * size * 0.03;
      const rx = x + Math.cos(a) * r;
      const ry = y + Math.sin(a) * r * 0.6;
      if (a === 0) ctx.moveTo(rx, ry);
      else ctx.lineTo(rx, ry);
    }
    ctx.closePath();
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Radiant wealth aura with corruption undertones
  const auraGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.95);
  auraGrad.addColorStop(0, `rgba(251, 191, 36, ${goldPulse * 0.45})`);
  auraGrad.addColorStop(0.3, `rgba(234, 179, 8, ${goldPulse * 0.3})`);
  auraGrad.addColorStop(0.6, `rgba(146, 64, 14, ${goldPulse * 0.15})`);
  auraGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.95, 0, Math.PI * 2);
  ctx.fill();

  // Orbiting treasure - elaborate display of wealth with magical auras
  for (let i = 0; i < 10; i++) {
    const itemAngle = time * 1.2 + i * Math.PI * 0.2;
    const itemDist = size * 0.58 + Math.sin(time * 2.5 + i) * size * 0.1;
    const itemX = x + Math.cos(itemAngle) * itemDist;
    const itemY = y - size * 0.05 + Math.sin(itemAngle) * itemDist * 0.38 + float * 0.25;
    ctx.save();
    ctx.translate(itemX, itemY);
    ctx.rotate(time * 2.5 + i);
    if (i % 4 === 0) {
      // Ancient gold coin with skull
      ctx.fillStyle = "#ffd700";
      ctx.shadowColor = "#ffd700";
      ctx.shadowBlur = 4 * zoom;
      ctx.beginPath();
      ctx.ellipse(0, 0, size * 0.055, size * 0.04, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#b8860b";
      ctx.lineWidth = 1.5 * zoom;
      ctx.stroke();
      ctx.fillStyle = "#78350f";
      ctx.beginPath();
      ctx.arc(0, -size * 0.005, size * 0.015, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    } else if (i % 4 === 1) {
      // Ruby gem with inner fire
      ctx.fillStyle = "#dc2626";
      ctx.shadowColor = "#dc2626";
      ctx.shadowBlur = 5 * zoom;
      ctx.beginPath();
      ctx.moveTo(0, -size * 0.045);
      ctx.lineTo(size * 0.035, 0);
      ctx.lineTo(0, size * 0.045);
      ctx.lineTo(-size * 0.035, 0);
      ctx.fill();
      ctx.fillStyle = "#fca5a5";
      ctx.beginPath();
      ctx.arc(-size * 0.008, -size * 0.012, size * 0.012, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    } else if (i % 4 === 2) {
      // Emerald with corruption
      ctx.fillStyle = "#059669";
      ctx.shadowColor = "#10b981";
      ctx.shadowBlur = 4 * zoom;
      ctx.fillRect(-size * 0.028, -size * 0.04, size * 0.056, size * 0.08);
      ctx.fillStyle = "#6ee7b7";
      ctx.fillRect(-size * 0.015, -size * 0.028, size * 0.015, size * 0.022);
      ctx.shadowBlur = 0;
    } else {
      // Sapphire
      ctx.fillStyle = "#2563eb";
      ctx.shadowColor = "#3b82f6";
      ctx.shadowBlur = 4 * zoom;
      ctx.beginPath();
      ctx.moveTo(0, -size * 0.04);
      ctx.lineTo(size * 0.03, -size * 0.01);
      ctx.lineTo(size * 0.02, size * 0.03);
      ctx.lineTo(-size * 0.02, size * 0.03);
      ctx.lineTo(-size * 0.03, -size * 0.01);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    ctx.restore();
  }

  // Lavish shadow with gold tint
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.58, 0, x, y + size * 0.58, size * 0.5);
  shadowGrad.addColorStop(0, "rgba(120, 80, 0, 0.5)");
  shadowGrad.addColorStop(0.5, "rgba(60, 40, 0, 0.3)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.58, size * 0.5, size * 0.16, 0, 0, Math.PI * 2);
  ctx.fill();

  // Magnificent golden robes with purple velvet lining and corruption veins
  const robeGrad = ctx.createLinearGradient(x - size * 0.5, y, x + size * 0.5, y);
  robeGrad.addColorStop(0, "#78350f");
  robeGrad.addColorStop(0.15, "#92400e");
  robeGrad.addColorStop(0.3, "#d97706");
  robeGrad.addColorStop(0.45, "#fbbf24");
  robeGrad.addColorStop(0.55, "#fcd34d");
  robeGrad.addColorStop(0.7, "#fbbf24");
  robeGrad.addColorStop(0.85, "#d97706");
  robeGrad.addColorStop(1, "#78350f");
  ctx.fillStyle = robeGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.52, y + size * 0.58);
  // Dramatically flowing bottom with tendrils
  for (let i = 0; i < 8; i++) {
    const waveX = x - size * 0.52 + i * size * 0.13;
    const waveY = y + size * 0.58 + Math.sin(time * 4 + i * 1.1) * size * 0.04 + (i % 2) * size * 0.025;
    ctx.lineTo(waveX, waveY);
  }
  ctx.quadraticCurveTo(x + size * 0.6, y - size * 0.1, x + size * 0.25, y - size * 0.42 + float);
  ctx.lineTo(x - size * 0.25, y - size * 0.42 + float);
  ctx.quadraticCurveTo(x - size * 0.6, y - size * 0.1, x - size * 0.52, y + size * 0.58);
  ctx.fill();

  // Gold-blood veins on robe
  ctx.strokeStyle = `rgba(251, 191, 36, ${corruptionPulse * 0.6})`;
  ctx.lineWidth = 1.5 * zoom;
  for (let v = 0; v < 5; v++) {
    const veinX = x - size * 0.35 + v * size * 0.175;
    ctx.beginPath();
    ctx.moveTo(veinX, y - size * 0.3 + float * 0.1);
    ctx.bezierCurveTo(
      veinX + Math.sin(time * 2 + v) * size * 0.06,
      y,
      veinX - Math.cos(time * 2 + v) * size * 0.04,
      y + size * 0.2,
      veinX + Math.sin(v) * size * 0.08,
      y + size * 0.45
    );
    ctx.stroke();
  }

  // Purple velvet inner lining with ornate pattern
  const innerGrad = ctx.createLinearGradient(x - size * 0.15, y, x + size * 0.15, y);
  innerGrad.addColorStop(0, "#3b0764");
  innerGrad.addColorStop(0.5, "#581c87");
  innerGrad.addColorStop(1, "#3b0764");
  ctx.fillStyle = innerGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.17, y - size * 0.36 + float);
  ctx.quadraticCurveTo(x, y - size * 0.18 + float, x + size * 0.17, y - size * 0.36 + float);
  ctx.lineTo(x + size * 0.14, y + size * 0.35);
  ctx.quadraticCurveTo(x, y + size * 0.45, x - size * 0.14, y + size * 0.35);
  ctx.fill();

  // Ornate gold collar with massive gems - more elaborate
  const collarGrad = ctx.createLinearGradient(x - size * 0.22, y - size * 0.35, x + size * 0.22, y - size * 0.1);
  collarGrad.addColorStop(0, "#b8860b");
  collarGrad.addColorStop(0.3, "#fbbf24");
  collarGrad.addColorStop(0.5, "#fcd34d");
  collarGrad.addColorStop(0.7, "#fbbf24");
  collarGrad.addColorStop(1, "#b8860b");
  ctx.fillStyle = collarGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.22, y - size * 0.36 + float);
  ctx.quadraticCurveTo(x, y - size * 0.22 + float, x + size * 0.22, y - size * 0.36 + float);
  ctx.lineTo(x + size * 0.2, y - size * 0.12 + float);
  ctx.quadraticCurveTo(x, y - size * 0.02 + float, x - size * 0.2, y - size * 0.12 + float);
  ctx.fill();
  // Collar filigree
  ctx.strokeStyle = "#78350f";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.15, y - size * 0.28 + float);
  ctx.quadraticCurveTo(x, y - size * 0.18 + float, x + size * 0.15, y - size * 0.28 + float);
  ctx.stroke();
  // Central diamond - massive
  ctx.fillStyle = "#e0f2fe";
  ctx.shadowColor = "#e0f2fe";
  ctx.shadowBlur = 14 * zoom;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.32 + float);
  ctx.lineTo(x + size * 0.08, y - size * 0.22 + float);
  ctx.lineTo(x, y - size * 0.1 + float);
  ctx.lineTo(x - size * 0.08, y - size * 0.22 + float);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Diamond inner gleam
  ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
  ctx.beginPath();
  ctx.arc(x - size * 0.02, y - size * 0.24 + float, size * 0.02, 0, Math.PI * 2);
  ctx.fill();
  // Side rubies
  ctx.fillStyle = "#dc2626";
  ctx.shadowColor = "#dc2626";
  ctx.shadowBlur = 6 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.14, y - size * 0.26 + float, size * 0.03, 0, Math.PI * 2);
  ctx.arc(x + size * 0.14, y - size * 0.26 + float, size * 0.03, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Distinguished aged face with corruption hints
  const faceGrad = ctx.createRadialGradient(x, y - size * 0.5 + float, 0, x, y - size * 0.5 + float, size * 0.24);
  faceGrad.addColorStop(0, "#fef9e7");
  faceGrad.addColorStop(0.6, "#fef3c7");
  faceGrad.addColorStop(1, "#fde68a");
  ctx.fillStyle = faceGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.5 + float, size * 0.24, 0, Math.PI * 2);
  ctx.fill();

  // Gold-blood veins on face
  ctx.strokeStyle = `rgba(251, 191, 36, ${greedAura * 0.4})`;
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.15, y - size * 0.55 + float);
  ctx.quadraticCurveTo(x - size * 0.12, y - size * 0.45 + float, x - size * 0.18, y - size * 0.38 + float);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.15, y - size * 0.55 + float);
  ctx.quadraticCurveTo(x + size * 0.12, y - size * 0.45 + float, x + size * 0.18, y - size * 0.38 + float);
  ctx.stroke();

  // Wrinkles of experience and greed
  ctx.strokeStyle = "rgba(180, 140, 100, 0.35)";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.13, y - size * 0.44 + float, size * 0.045, 0.3, Math.PI - 0.3);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(x + size * 0.13, y - size * 0.44 + float, size * 0.045, 0.3, Math.PI - 0.3);
  ctx.stroke();

  // Ornate golden monocle with magic lens
  ctx.strokeStyle = "#fbbf24";
  ctx.lineWidth = 3 * zoom;
  ctx.beginPath();
  ctx.arc(x + size * 0.11, y - size * 0.52 + float, size * 0.09, 0, Math.PI * 2);
  ctx.stroke();
  // Monocle lens with gold gleam
  ctx.fillStyle = `rgba(251, 191, 36, ${goldPulse * 0.3})`;
  ctx.beginPath();
  ctx.arc(x + size * 0.11, y - size * 0.52 + float, size * 0.08, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
  ctx.beginPath();
  ctx.arc(x + size * 0.09, y - size * 0.54 + float, size * 0.03, 0, Math.PI * 2);
  ctx.fill();
  // Ornate gold chain
  ctx.strokeStyle = "#d97706";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(x + size * 0.2, y - size * 0.52 + float);
  ctx.bezierCurveTo(
    x + size * 0.28, y - size * 0.42 + float,
    x + size * 0.26, y - size * 0.28 + float,
    x + size * 0.22, y - size * 0.18 + float
  );
  ctx.stroke();

  // Piercing calculating eyes with greed glow
  ctx.fillStyle = "#fef9e7";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.09, y - size * 0.52 + float, size * 0.05, size * 0.055, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.11, y - size * 0.52 + float, size * 0.045, size * 0.05, 0, 0, Math.PI * 2);
  ctx.fill();
  // Gold-touched irises
  ctx.fillStyle = "#b8860b";
  ctx.beginPath();
  ctx.arc(x - size * 0.09, y - size * 0.52 + float, size * 0.028, 0, Math.PI * 2);
  ctx.arc(x + size * 0.11, y - size * 0.52 + float, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  // Pupils with gold gleam
  ctx.fillStyle = "#1c1917";
  ctx.beginPath();
  ctx.arc(x - size * 0.09, y - size * 0.52 + float, size * 0.012, 0, Math.PI * 2);
  ctx.arc(x + size * 0.11, y - size * 0.52 + float, size * 0.01, 0, Math.PI * 2);
  ctx.fill();
  // Eye gleam (greed)
  ctx.fillStyle = `rgba(251, 191, 36, ${goldPulse})`;
  ctx.shadowColor = "#fbbf24";
  ctx.shadowBlur = 6 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.09, y - size * 0.52 + float, size * 0.014, 0, Math.PI * 2);
  ctx.arc(x + size * 0.11, y - size * 0.52 + float, size * 0.012, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Cruel mouth
  ctx.strokeStyle = "#78350f";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.08, y - size * 0.38 + float);
  ctx.quadraticCurveTo(x, y - size * 0.35 + float, x + size * 0.08, y - size * 0.38 + float);
  ctx.stroke();

  // Silver streaked hair/receding hairline
  ctx.fillStyle = "#6b7280";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.68 + float, size * 0.18, size * 0.08, 0, 0, Math.PI);
  ctx.fill();
  ctx.strokeStyle = "#9ca3af";
  ctx.lineWidth = 1.5 * zoom;
  for (let h = 0; h < 5; h++) {
    ctx.beginPath();
    ctx.moveTo(x - size * 0.12 + h * size * 0.06, y - size * 0.68 + float);
    ctx.lineTo(x - size * 0.1 + h * size * 0.05 + Math.sin(h) * size * 0.02, y - size * 0.75 + float);
    ctx.stroke();
  }

  // Magnificent top hat with jeweled band - even more elaborate
  ctx.fillStyle = "#0f0f0f";
  // Brim with gold edge
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.72 + float, size * 0.26, size * 0.07, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = "#fbbf24";
  ctx.lineWidth = 2 * zoom;
  ctx.stroke();
  // Crown
  const hatGrad = ctx.createLinearGradient(x - size * 0.17, y - size * 1.0, x + size * 0.17, y - size * 1.0);
  hatGrad.addColorStop(0, "#1c1917");
  hatGrad.addColorStop(0.5, "#374151");
  hatGrad.addColorStop(1, "#1c1917");
  ctx.fillStyle = hatGrad;
  ctx.fillRect(x - size * 0.17, y - size * 1.0 + float, size * 0.34, size * 0.3);
  // Top
  ctx.fillStyle = "#1c1917";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 1.0 + float, size * 0.17, size * 0.05, 0, 0, Math.PI * 2);
  ctx.fill();
  // Jeweled gold band
  const bandGrad = ctx.createLinearGradient(x - size * 0.18, y - size * 0.82, x + size * 0.18, y - size * 0.82);
  bandGrad.addColorStop(0, "#b8860b");
  bandGrad.addColorStop(0.5, "#fbbf24");
  bandGrad.addColorStop(1, "#b8860b");
  ctx.fillStyle = bandGrad;
  ctx.fillRect(x - size * 0.18, y - size * 0.82 + float, size * 0.36, size * 0.07);
  // Gems on band - larger and more elaborate
  ctx.fillStyle = "#dc2626";
  ctx.shadowColor = "#dc2626";
  ctx.shadowBlur = 4 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.1, y - size * 0.785 + float, size * 0.028, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = "#059669";
  ctx.shadowColor = "#10b981";
  ctx.shadowBlur = 4 * zoom;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.785 + float, size * 0.028, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = "#2563eb";
  ctx.shadowColor = "#3b82f6";
  ctx.shadowBlur = 4 * zoom;
  ctx.beginPath();
  ctx.arc(x + size * 0.1, y - size * 0.785 + float, size * 0.028, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Ornate staff of wealth (scepter) - more elaborate
  ctx.save();
  ctx.translate(x - size * 0.5, y - size * 0.15 + float);
  ctx.rotate(-0.22 + Math.sin(time * 2.2) * 0.06);
  // Staff body (ebony with gold inlay)
  const staffBodyGrad = ctx.createLinearGradient(-size * 0.035, 0, size * 0.035, 0);
  staffBodyGrad.addColorStop(0, "#1c1917");
  staffBodyGrad.addColorStop(0.5, "#374151");
  staffBodyGrad.addColorStop(1, "#1c1917");
  ctx.fillStyle = staffBodyGrad;
  ctx.fillRect(-size * 0.035, -size * 0.45, size * 0.07, size * 0.9);
  // Gold spiral inlay
  ctx.strokeStyle = "#fbbf24";
  ctx.lineWidth = 2 * zoom;
  for (let i = 0; i < 10; i++) {
    ctx.beginPath();
    ctx.moveTo(-size * 0.035, -size * 0.4 + i * size * 0.09);
    ctx.lineTo(size * 0.035, -size * 0.35 + i * size * 0.09);
    ctx.stroke();
  }
  // Gold rings
  ctx.fillStyle = "#fbbf24";
  ctx.fillRect(-size * 0.045, -size * 0.45, size * 0.09, size * 0.04);
  ctx.fillRect(-size * 0.045, size * 0.35, size * 0.09, size * 0.04);
  // Crown top with elaborate design
  ctx.fillStyle = "#fbbf24";
  ctx.beginPath();
  ctx.moveTo(-size * 0.09, -size * 0.45);
  ctx.lineTo(-size * 0.07, -size * 0.58);
  ctx.lineTo(-size * 0.03, -size * 0.52);
  ctx.lineTo(0, -size * 0.62);
  ctx.lineTo(size * 0.03, -size * 0.52);
  ctx.lineTo(size * 0.07, -size * 0.58);
  ctx.lineTo(size * 0.09, -size * 0.45);
  ctx.closePath();
  ctx.fill();
  // Legendary gem - soul-capturing
  ctx.fillStyle = "#fbbf24";
  ctx.shadowColor = "#fbbf24";
  ctx.shadowBlur = 15 * zoom;
  ctx.beginPath();
  ctx.arc(0, -size * 0.68, size * 0.08, 0, Math.PI * 2);
  ctx.fill();
  // Inner glow
  ctx.fillStyle = "#fef3c7";
  ctx.beginPath();
  ctx.arc(-size * 0.025, -size * 0.7, size * 0.03, 0, Math.PI * 2);
  ctx.fill();
  // Swirling souls inside gem
  ctx.strokeStyle = `rgba(120, 53, 15, ${corruptionPulse * 0.6})`;
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.arc(0, -size * 0.68, size * 0.05, time * 4, time * 4 + Math.PI);
  ctx.stroke();
  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawArcherEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // PHANTOM DEADEYE - Spectral hunter with soul-piercing arrows and shadow magic
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const stance = Math.sin(time * 2.5) * 2.5 * zoom + (isAttacking ? attackIntensity * size * 0.12 : 0);
  const drawPull = 0.35 + Math.sin(time * 1.8) * 0.3;
  const shadowPulse = 0.6 + Math.sin(time * 4) * 0.4;
  const deathAura = 0.5 + Math.sin(time * 5) * 0.3;
  const soulFlicker = Math.sin(time * 8) > 0.3 ? 1 : 0.7;

  // Shadow tendrils reaching out
  ctx.save();
  for (let tendril = 0; tendril < 5; tendril++) {
    const tendrilAngle = tendril * Math.PI * 0.4 - Math.PI * 0.5 + Math.sin(time * 0.5) * 0.2;
    ctx.strokeStyle = `rgba(6, 78, 59, ${deathAura * 0.4})`;
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.moveTo(x, y + size * 0.3);
    let tx = x, ty = y + size * 0.3;
    for (let seg = 0; seg < 4; seg++) {
      tx += Math.cos(tendrilAngle + Math.sin(time * 2 + seg) * 0.4) * size * 0.12;
      ty += Math.sin(tendrilAngle + Math.sin(time * 2 + seg) * 0.3) * size * 0.08;
      ctx.lineTo(tx, ty);
    }
    ctx.stroke();
  }
  ctx.restore();

  // Death magic aura - more ominous
  const auraGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.8);
  auraGrad.addColorStop(0, `rgba(16, 185, 129, ${shadowPulse * 0.3})`);
  auraGrad.addColorStop(0.3, `rgba(5, 150, 105, ${shadowPulse * 0.2})`);
  auraGrad.addColorStop(0.6, `rgba(6, 78, 59, ${shadowPulse * 0.1})`);
  auraGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.8, 0, Math.PI * 2);
  ctx.fill();

  // Floating soul wisps/death leaves
  for (let i = 0; i < 8; i++) {
    const leafAngle = time * 1.2 + i * Math.PI * 0.25;
    const leafDist = size * 0.5 + Math.sin(time * 2.5 + i) * size * 0.12;
    const lx = x + Math.cos(leafAngle) * leafDist;
    const ly = y + Math.sin(leafAngle) * leafDist * 0.5;
    ctx.save();
    ctx.translate(lx, ly);
    ctx.rotate(time * 2.5 + i);
    ctx.fillStyle = `rgba(52, 211, 153, ${0.4 + Math.sin(time * 3.5 + i) * 0.25})`;
    ctx.shadowColor = "#34d399";
    ctx.shadowBlur = 3 * zoom;
    ctx.beginPath();
    ctx.moveTo(0, -size * 0.02);
    ctx.quadraticCurveTo(size * 0.03, 0, 0, size * 0.02);
    ctx.quadraticCurveTo(-size * 0.03, 0, 0, -size * 0.02);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();
  }

  // Shadow beneath - darker
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.52, 0, x, y + size * 0.52, size * 0.35);
  shadowGrad.addColorStop(0, "rgba(0, 0, 0, 0.5)");
  shadowGrad.addColorStop(0.6, "rgba(0, 0, 0, 0.25)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.52, size * 0.35, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  // Enchanted quiver with soul-bound arrows
  ctx.save();
  ctx.translate(x + size * 0.28, y - size * 0.06 + stance * 0.3);
  ctx.rotate(0.28);
  // Quiver body with runes
  const quiverGrad = ctx.createLinearGradient(-size * 0.08, 0, size * 0.08, 0);
  quiverGrad.addColorStop(0, "#1c1917");
  quiverGrad.addColorStop(0.5, "#292524");
  quiverGrad.addColorStop(1, "#1c1917");
  ctx.fillStyle = quiverGrad;
  ctx.fillRect(-size * 0.08, -size * 0.4, size * 0.16, size * 0.5);
  // Leather straps
  ctx.strokeStyle = "#78350f";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(-size * 0.06, -size * 0.38);
  ctx.lineTo(-size * 0.06, size * 0.08);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(size * 0.06, -size * 0.38);
  ctx.lineTo(size * 0.06, size * 0.08);
  ctx.stroke();
  // Soul runes on quiver
  ctx.strokeStyle = `rgba(52, 211, 153, ${shadowPulse * 0.6})`;
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.3);
  ctx.lineTo(-size * 0.03, -size * 0.2);
  ctx.lineTo(size * 0.03, -size * 0.1);
  ctx.lineTo(0, 0);
  ctx.stroke();
  // Soul arrows
  for (let i = 0; i < 6; i++) {
    ctx.strokeStyle = "#047857";
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.moveTo(-size * 0.05 + i * size * 0.02, -size * 0.38);
    ctx.lineTo(-size * 0.05 + i * size * 0.02, -size * 0.6);
    ctx.stroke();
    // Soul-fire arrowhead
    ctx.fillStyle = `rgba(52, 211, 153, ${soulFlicker})`;
    ctx.shadowColor = "#34d399";
    ctx.shadowBlur = 5 * zoom;
    ctx.beginPath();
    ctx.moveTo(-size * 0.05 + i * size * 0.02, -size * 0.6);
    ctx.lineTo(-size * 0.065 + i * size * 0.02, -size * 0.66);
    ctx.lineTo(-size * 0.035 + i * size * 0.02, -size * 0.66);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
  ctx.restore();

  // Flowing phantom cloak - more tattered and ghostly
  const cloakGrad = ctx.createLinearGradient(x - size * 0.4, y, x + size * 0.4, y);
  cloakGrad.addColorStop(0, "#022c22");
  cloakGrad.addColorStop(0.2, "#064e3b");
  cloakGrad.addColorStop(0.4, "#047857");
  cloakGrad.addColorStop(0.5, "#059669");
  cloakGrad.addColorStop(0.6, "#047857");
  cloakGrad.addColorStop(0.8, "#064e3b");
  cloakGrad.addColorStop(1, "#022c22");
  ctx.fillStyle = cloakGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.42, y + size * 0.55);
  // Tattered flowing bottom edge
  for (let i = 0; i < 7; i++) {
    const waveX = x - size * 0.42 + i * size * 0.14;
    const waveY = y + size * 0.55 + Math.sin(time * 5 + i * 1.3) * size * 0.05 + (i % 2) * size * 0.04 + (i % 3) * size * 0.02;
    ctx.lineTo(waveX, waveY);
  }
  ctx.quadraticCurveTo(x + size * 0.48, y - size * 0.15 + stance, x, y - size * 0.56 + stance);
  ctx.quadraticCurveTo(x - size * 0.48, y - size * 0.15 + stance, x - size * 0.42, y + size * 0.55);
  ctx.fill();

  // Soul threads on cloak
  ctx.strokeStyle = `rgba(52, 211, 153, ${shadowPulse * 0.5})`;
  ctx.lineWidth = 1.5 * zoom;
  for (let i = 0; i < 4; i++) {
    ctx.beginPath();
    ctx.moveTo(x - size * 0.15 + i * size * 0.1, y + size * 0.08 + i * size * 0.06);
    ctx.bezierCurveTo(
      x - size * 0.1 + i * size * 0.1 + Math.sin(time * 2 + i) * size * 0.03,
      y + size * 0.15 + i * size * 0.06,
      x - size * 0.05 + i * size * 0.1,
      y + size * 0.2 + i * size * 0.08,
      x + i * size * 0.1 + Math.cos(time * 2 + i) * size * 0.02,
      y + size * 0.25 + i * size * 0.08
    );
    ctx.stroke();
  }

  // Spectral leather armor
  const armorGrad = ctx.createLinearGradient(x - size * 0.2, y, x + size * 0.2, y);
  armorGrad.addColorStop(0, "#44403c");
  armorGrad.addColorStop(0.5, "#78350f");
  armorGrad.addColorStop(1, "#44403c");
  ctx.fillStyle = armorGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.2, y + size * 0.38);
  ctx.lineTo(x - size * 0.22, y - size * 0.18 + stance);
  ctx.lineTo(x, y - size * 0.28 + stance);
  ctx.lineTo(x + size * 0.22, y - size * 0.18 + stance);
  ctx.lineTo(x + size * 0.2, y + size * 0.38);
  ctx.fill();
  // Armor details
  ctx.strokeStyle = "#57534e";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.2 + stance);
  ctx.lineTo(x, y + size * 0.3);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x - size * 0.15, y + size * 0.05);
  ctx.lineTo(x + size * 0.15, y + size * 0.05);
  ctx.stroke();

  // Spectral elven face
  const faceGrad = ctx.createRadialGradient(x, y - size * 0.42 + stance, 0, x, y - size * 0.42 + stance, size * 0.18);
  faceGrad.addColorStop(0, "#e7e5e4");
  faceGrad.addColorStop(0.6, "#d6d3d1");
  faceGrad.addColorStop(1, "#a8a29e");
  ctx.fillStyle = faceGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.42 + stance, size * 0.18, 0, Math.PI * 2);
  ctx.fill();

  // Pointed elven ears - longer
  ctx.fillStyle = "#d6d3d1";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.16, y - size * 0.44 + stance);
  ctx.quadraticCurveTo(x - size * 0.22, y - size * 0.52 + stance, x - size * 0.3, y - size * 0.58 + stance);
  ctx.quadraticCurveTo(x - size * 0.22, y - size * 0.48 + stance, x - size * 0.18, y - size * 0.4 + stance);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.16, y - size * 0.44 + stance);
  ctx.quadraticCurveTo(x + size * 0.22, y - size * 0.52 + stance, x + size * 0.3, y - size * 0.58 + stance);
  ctx.quadraticCurveTo(x + size * 0.22, y - size * 0.48 + stance, x + size * 0.18, y - size * 0.4 + stance);
  ctx.fill();

  // Glowing death-green eyes
  ctx.fillStyle = "#10b981";
  ctx.shadowColor = "#10b981";
  ctx.shadowBlur = 10 * zoom;
  ctx.beginPath();
  ctx.ellipse(x - size * 0.06, y - size * 0.44 + stance, size * 0.035, size * 0.028, -0.1, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.06, y - size * 0.44 + stance, size * 0.035, size * 0.028, 0.1, 0, Math.PI * 2);
  ctx.fill();
  // Pupil slits
  ctx.fillStyle = "#022c22";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.06, y - size * 0.44 + stance, size * 0.01, size * 0.022, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.06, y - size * 0.44 + stance, size * 0.01, size * 0.022, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Hood shadow - deeper
  ctx.fillStyle = "rgba(2, 44, 34, 0.7)";
  ctx.beginPath();
  ctx.arc(x, y - size * 0.56 + stance, size * 0.2, 0, Math.PI, true);
  ctx.fill();
  // Hood edge details
  ctx.strokeStyle = "#064e3b";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.56 + stance, size * 0.2, 0.1, Math.PI - 0.1, true);
  ctx.stroke();

  // Magnificent spectral bow - bone and soul magic
  ctx.save();
  ctx.translate(x - size * 0.38, y + stance);
  // Bow body - bone-like with soul energy
  const bowGrad = ctx.createLinearGradient(-size * 0.12, -size * 0.45, size * 0.12, size * 0.45);
  bowGrad.addColorStop(0, "#047857");
  bowGrad.addColorStop(0.3, "#059669");
  bowGrad.addColorStop(0.5, "#10b981");
  bowGrad.addColorStop(0.7, "#059669");
  bowGrad.addColorStop(1, "#047857");
  ctx.strokeStyle = bowGrad;
  ctx.shadowColor = "#10b981";
  ctx.shadowBlur = 12 * zoom;
  ctx.lineWidth = 5 * zoom;
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.46, -Math.PI * 0.48, Math.PI * 0.48);
  ctx.stroke();
  ctx.shadowBlur = 0;
  // Bone spurs on bow
  ctx.fillStyle = "#a8a29e";
  for (let spur = 0; spur < 4; spur++) {
    const spurAngle = -Math.PI * 0.35 + spur * Math.PI * 0.23;
    ctx.save();
    ctx.translate(Math.cos(spurAngle) * size * 0.46, Math.sin(spurAngle) * size * 0.46);
    ctx.rotate(spurAngle);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(size * 0.04, -size * 0.02);
    ctx.lineTo(size * 0.08, 0);
    ctx.lineTo(size * 0.04, size * 0.02);
    ctx.fill();
    ctx.restore();
  }
  // Soul runes on bow
  ctx.fillStyle = `rgba(52, 211, 153, ${shadowPulse})`;
  ctx.shadowColor = "#34d399";
  ctx.shadowBlur = 4 * zoom;
  ctx.font = `${size * 0.07}px serif`;
  ctx.textAlign = "center";
  ctx.fillText("", Math.cos(-0.25) * size * 0.4, Math.sin(-0.25) * size * 0.4);
  ctx.fillText("", Math.cos(0.25) * size * 0.4, Math.sin(0.25) * size * 0.4);
  ctx.shadowBlur = 0;
  ctx.restore();

  // Soul-string (pulsing ethereal energy)
  ctx.strokeStyle = `rgba(52, 211, 153, ${shadowPulse})`;
  ctx.lineWidth = 2 * zoom;
  const bowTopX = x - size * 0.38 + Math.cos(-Math.PI * 0.48) * size * 0.46;
  const bowTopY = y + stance + Math.sin(-Math.PI * 0.48) * size * 0.46;
  const bowBotX = x - size * 0.38 + Math.cos(Math.PI * 0.48) * size * 0.46;
  const bowBotY = y + stance + Math.sin(Math.PI * 0.48) * size * 0.46;
  const pullX = x - size * 0.15 - drawPull * size * 0.22;
  ctx.beginPath();
  ctx.moveTo(bowTopX, bowTopY);
  ctx.lineTo(pullX, y + stance);
  ctx.lineTo(bowBotX, bowBotY);
  ctx.stroke();

  // Soul-piercing arrow
  ctx.save();
  ctx.translate(pullX, y + stance);
  ctx.rotate(Math.PI);
  // Arrow shaft - spectral
  ctx.strokeStyle = "#047857";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(size * 0.45, 0);
  ctx.stroke();
  // Soul energy along shaft
  ctx.strokeStyle = `rgba(52, 211, 153, ${soulFlicker * 0.5})`;
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(size * 0.05, 0);
  for (let w = 0; w < 8; w++) {
    ctx.lineTo(size * 0.08 + w * size * 0.045, Math.sin(time * 10 + w) * size * 0.015);
  }
  ctx.stroke();
  // Soul-fire arrowhead
  ctx.fillStyle = "#10b981";
  ctx.shadowColor = "#10b981";
  ctx.shadowBlur = 10 * zoom;
  ctx.beginPath();
  ctx.moveTo(size * 0.45, 0);
  ctx.lineTo(size * 0.52, -size * 0.04);
  ctx.lineTo(size * 0.58, 0);
  ctx.lineTo(size * 0.52, size * 0.04);
  ctx.fill();
  // Inner glow
  ctx.fillStyle = "#34d399";
  ctx.beginPath();
  ctx.arc(size * 0.5, 0, size * 0.015, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Arrow fletching - spectral feathers
  ctx.fillStyle = `rgba(16, 185, 129, ${shadowPulse})`;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.quadraticCurveTo(-size * 0.04, -size * 0.06, -size * 0.08, -size * 0.05);
  ctx.lineTo(-size * 0.02, 0);
  ctx.lineTo(-size * 0.08, size * 0.05);
  ctx.quadraticCurveTo(-size * 0.04, size * 0.06, 0, 0);
  ctx.fill();
  ctx.restore();
}

function drawMageEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // MAGE PROFESSOR - Arcane wizard with floating tome and magic orbs
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const float = Math.sin(time * 2.5) * 4 * zoom + (isAttacking ? attackIntensity * size * 0.15 : 0);
  const magicPulse = 0.6 + Math.sin(time * 4) * 0.4;

  // Magic aura
  const auraGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.7);
  auraGrad.addColorStop(0, `rgba(139, 92, 246, ${magicPulse * 0.25})`);
  auraGrad.addColorStop(0.6, `rgba(139, 92, 246, ${magicPulse * 0.1})`);
  auraGrad.addColorStop(1, "rgba(139, 92, 246, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.7, 0, Math.PI * 2);
  ctx.fill();

  // Floating arcane orbs
  for (let i = 0; i < 3; i++) {
    const orbAngle = time * 1.5 + i * Math.PI * 0.67;
    const orbX = x + Math.cos(orbAngle) * size * 0.55;
    const orbY = y - size * 0.2 + Math.sin(orbAngle) * size * 0.3;
    ctx.fillStyle = `rgba(167, 139, 250, ${
      0.6 + Math.sin(time * 3 + i) * 0.3
    })`;
    ctx.shadowColor = "#8b5cf6";
    ctx.shadowBlur = 8 * zoom;
    ctx.beginPath();
    ctx.arc(orbX, orbY, size * 0.06, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Shadow
  ctx.fillStyle = "rgba(0, 0, 0, 0.35)";
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.5, size * 0.32, size * 0.1, 0, 0, Math.PI * 2);
  ctx.fill();

  // Arcane robes
  const robeGrad = ctx.createLinearGradient(
    x,
    y - size * 0.4,
    x,
    y + size * 0.5
  );
  robeGrad.addColorStop(0, "#4c1d95");
  robeGrad.addColorStop(0.5, "#6d28d9");
  robeGrad.addColorStop(1, "#3b0764");
  ctx.fillStyle = robeGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.4, y + size * 0.5);
  ctx.quadraticCurveTo(
    x - size * 0.45,
    y,
    x - size * 0.15,
    y - size * 0.4 + float
  );
  ctx.lineTo(x + size * 0.15, y - size * 0.4 + float);
  ctx.quadraticCurveTo(x + size * 0.45, y, x + size * 0.4, y + size * 0.5);
  ctx.closePath();
  ctx.fill();

  // Rune patterns on robe
  ctx.strokeStyle = `rgba(167, 139, 250, ${magicPulse})`;
  ctx.lineWidth = 1.5 * zoom;
  for (let i = 0; i < 4; i++) {
    ctx.beginPath();
    ctx.arc(x, y + size * 0.1 + i * size * 0.08, size * 0.08, 0, Math.PI);
    ctx.stroke();
  }

  // Wizard beard
  ctx.fillStyle = "#9ca3af";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.1, y - size * 0.28 + float);
  ctx.quadraticCurveTo(x - size * 0.15, y + float, x, y + size * 0.1 + float);
  ctx.quadraticCurveTo(
    x + size * 0.15,
    y + float,
    x + size * 0.1,
    y - size * 0.28 + float
  );
  ctx.fill();

  // Face
  ctx.fillStyle = "#e0d4c4";
  ctx.beginPath();
  ctx.arc(x, y - size * 0.35 + float, size * 0.18, 0, Math.PI * 2);
  ctx.fill();

  // Glowing eyes
  ctx.fillStyle = "#8b5cf6";
  ctx.shadowColor = "#8b5cf6";
  ctx.shadowBlur = 6 * zoom;
  ctx.beginPath();
  ctx.arc(
    x - size * 0.06,
    y - size * 0.37 + float,
    size * 0.03,
    0,
    Math.PI * 2
  );
  ctx.arc(
    x + size * 0.06,
    y - size * 0.37 + float,
    size * 0.03,
    0,
    Math.PI * 2
  );
  ctx.fill();
  ctx.shadowBlur = 0;

  // Wizard hat
  ctx.fillStyle = "#4c1d95";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.2, y - size * 0.5 + float);
  ctx.lineTo(x, y - size * 0.9 + float);
  ctx.lineTo(x + size * 0.2, y - size * 0.5 + float);
  ctx.closePath();
  ctx.fill();
  // Hat brim
  ctx.beginPath();
  ctx.ellipse(
    x,
    y - size * 0.5 + float,
    size * 0.25,
    size * 0.08,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();
  // Star on hat
  ctx.fillStyle = "#fbbf24";
  ctx.font = `${size * 0.12}px serif`;
  ctx.textAlign = "center";
  ctx.fillText("", x, y - size * 0.65 + float);

  // Floating spellbook
  ctx.fillStyle = "#7c2d12";
  ctx.save();
  ctx.translate(
    x - size * 0.35,
    y - size * 0.1 + float + Math.sin(time * 3) * 3
  );
  ctx.rotate(Math.sin(time * 2) * 0.1);
  ctx.fillRect(-size * 0.1, -size * 0.12, size * 0.2, size * 0.24);
  ctx.fillStyle = "#fef3c7";
  ctx.fillRect(-size * 0.08, -size * 0.1, size * 0.16, size * 0.2);
  // Glowing runes on book
  ctx.fillStyle = `rgba(139, 92, 246, ${magicPulse})`;
  ctx.font = `${size * 0.08}px serif`;
  ctx.fillText("", 0, 0);
  ctx.restore();
}

function drawCatapultEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // INFERNAL SIEGE ENGINE - Demonic war machine powered by hellfire and dark souls
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const armAngle = Math.sin(time * 1.5) * 0.35 + (isAttacking ? attackIntensity * 0.8 : 0);
  const hellGlow = 0.6 + Math.sin(time * 4) * 0.3;
  const soulWisp = 0.5 + Math.sin(time * 5) * 0.3;

  // Hellfire aura beneath
  const fireGrad = ctx.createRadialGradient(x, y + size * 0.3, 0, x, y + size * 0.3, size * 0.6);
  fireGrad.addColorStop(0, `rgba(220, 38, 38, ${hellGlow * 0.3})`);
  fireGrad.addColorStop(0.5, `rgba(180, 30, 30, ${hellGlow * 0.15})`);
  fireGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = fireGrad;
  ctx.beginPath();
  ctx.arc(x, y + size * 0.3, size * 0.6, 0, Math.PI * 2);
  ctx.fill();

  // Shadow with hell-cracks
  ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.48, size * 0.55, size * 0.18, 0, 0, Math.PI * 2);
  ctx.fill();
  // Hell cracks in ground
  ctx.strokeStyle = `rgba(220, 38, 38, ${hellGlow * 0.5})`;
  ctx.lineWidth = 1.5 * zoom;
  for (let crack = 0; crack < 5; crack++) {
    const crackAngle = crack * Math.PI / 2.5 - Math.PI * 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y + size * 0.48);
    let cx = x, cy = y + size * 0.48;
    for (let seg = 0; seg < 3; seg++) {
      cx += Math.cos(crackAngle) * size * 0.12;
      cy += size * 0.02;
      ctx.lineTo(cx + Math.sin(seg) * size * 0.03, cy);
    }
    ctx.stroke();
  }

  // Demonic bone wheels
  for (let w = 0; w < 2; w++) {
    const wheelX = w === 0 ? x - size * 0.38 : x + size * 0.38;
    // Wheel outer ring with teeth
    ctx.fillStyle = "#292524";
    ctx.strokeStyle = "#1c1917";
    ctx.lineWidth = 3 * zoom;
    ctx.beginPath();
    ctx.arc(wheelX, y + size * 0.38, size * 0.17, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    // Bone spokes
    ctx.strokeStyle = "#78716c";
    ctx.lineWidth = 3 * zoom;
    for (let i = 0; i < 6; i++) {
      const angle = (i * Math.PI) / 3 + time * 0.6;
      ctx.beginPath();
      ctx.moveTo(wheelX, y + size * 0.38);
      ctx.lineTo(wheelX + Math.cos(angle) * size * 0.14, y + size * 0.38 + Math.sin(angle) * size * 0.14);
      ctx.stroke();
    }
    // Hub skull
    ctx.fillStyle = "#a8a29e";
    ctx.beginPath();
    ctx.arc(wheelX, y + size * 0.38, size * 0.05, 0, Math.PI * 2);
    ctx.fill();
    // Skull eyes
    ctx.fillStyle = `rgba(220, 38, 38, ${hellGlow})`;
    ctx.beginPath();
    ctx.arc(wheelX - size * 0.02, y + size * 0.37, size * 0.012, 0, Math.PI * 2);
    ctx.arc(wheelX + size * 0.02, y + size * 0.37, size * 0.012, 0, Math.PI * 2);
    ctx.fill();
    // Wheel spikes
    ctx.fillStyle = "#1c1917";
    for (let spike = 0; spike < 8; spike++) {
      const spikeAngle = spike * Math.PI / 4;
      ctx.beginPath();
      ctx.moveTo(wheelX + Math.cos(spikeAngle) * size * 0.15, y + size * 0.38 + Math.sin(spikeAngle) * size * 0.15);
      ctx.lineTo(wheelX + Math.cos(spikeAngle) * size * 0.22, y + size * 0.38 + Math.sin(spikeAngle) * size * 0.22);
      ctx.lineTo(wheelX + Math.cos(spikeAngle + 0.1) * size * 0.15, y + size * 0.38 + Math.sin(spikeAngle + 0.1) * size * 0.15);
      ctx.fill();
    }
  }

  // Main frame - demonic construction with bone and iron
  const frameGrad = ctx.createLinearGradient(x - size * 0.45, y, x + size * 0.45, y);
  frameGrad.addColorStop(0, "#292524");
  frameGrad.addColorStop(0.3, "#44403c");
  frameGrad.addColorStop(0.5, "#57534e");
  frameGrad.addColorStop(0.7, "#44403c");
  frameGrad.addColorStop(1, "#292524");
  ctx.fillStyle = frameGrad;
  ctx.fillRect(x - size * 0.45, y + size * 0.08, size * 0.9, size * 0.24);
  // Iron bands with runes
  ctx.fillStyle = "#3f3f46";
  ctx.fillRect(x - size * 0.4, y + size * 0.1, size * 0.1, size * 0.2);
  ctx.fillRect(x + size * 0.3, y + size * 0.1, size * 0.1, size * 0.2);
  ctx.fillRect(x - size * 0.05, y + size * 0.1, size * 0.1, size * 0.2);
  // Glowing runes on bands
  ctx.fillStyle = `rgba(220, 38, 38, ${hellGlow})`;
  ctx.font = `${size * 0.06}px serif`;
  ctx.textAlign = "center";
  ctx.fillText("", x - size * 0.35, y + size * 0.22);
  ctx.fillText("", x, y + size * 0.22);
  ctx.fillText("", x + size * 0.35, y + size * 0.22);

  // Throwing arm - bone reinforced with hellfire veins
  ctx.save();
  ctx.translate(x, y + size * 0.18);
  ctx.rotate(-0.85 + armAngle);
  // Arm structure
  const armGrad = ctx.createLinearGradient(0, 0, 0, -size * 0.65);
  armGrad.addColorStop(0, "#44403c");
  armGrad.addColorStop(0.5, "#78716c");
  armGrad.addColorStop(1, "#57534e");
  ctx.fillStyle = armGrad;
  ctx.fillRect(-size * 0.06, -size * 0.65, size * 0.12, size * 0.65);
  // Bone reinforcement
  ctx.strokeStyle = "#a8a29e";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(-size * 0.04, 0);
  ctx.lineTo(-size * 0.04, -size * 0.6);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(size * 0.04, 0);
  ctx.lineTo(size * 0.04, -size * 0.6);
  ctx.stroke();
  // Hellfire veins
  ctx.strokeStyle = `rgba(220, 38, 38, ${hellGlow * 0.7})`;
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.1);
  ctx.quadraticCurveTo(-size * 0.03, -size * 0.35, 0, -size * 0.55);
  ctx.stroke();
  // Arm metal cap with skull
  ctx.fillStyle = "#3f3f46";
  ctx.fillRect(-size * 0.08, -size * 0.68, size * 0.16, size * 0.1);
  ctx.fillStyle = "#a8a29e";
  ctx.beginPath();
  ctx.arc(0, -size * 0.72, size * 0.05, 0, Math.PI * 2);
  ctx.fill();
  // Soul-catching bucket
  ctx.fillStyle = "#292524";
  ctx.beginPath();
  ctx.arc(0, -size * 0.64, size * 0.14, 0, Math.PI);
  ctx.fill();
  // Soul flames in bucket
  ctx.fillStyle = `rgba(220, 38, 38, ${hellGlow})`;
  ctx.shadowColor = "#dc2626";
  ctx.shadowBlur = 8 * zoom;
  ctx.beginPath();
  ctx.arc(0, -size * 0.6, size * 0.1, 0, Math.PI * 2);
  ctx.fill();
  // Skull projectile
  ctx.fillStyle = "#e7e5e4";
  ctx.beginPath();
  ctx.arc(0, -size * 0.58, size * 0.07, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#1c1917";
  ctx.beginPath();
  ctx.arc(-size * 0.02, -size * 0.6, size * 0.015, 0, Math.PI * 2);
  ctx.arc(size * 0.02, -size * 0.6, size * 0.015, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // Soul-chain tension ropes
  ctx.strokeStyle = `rgba(220, 38, 38, ${soulWisp * 0.7})`;
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.32, y + size * 0.22);
  ctx.quadraticCurveTo(x - size * 0.2, y - size * 0.05, x, y - size * 0.15);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.32, y + size * 0.22);
  ctx.quadraticCurveTo(x + size * 0.2, y - size * 0.05, x, y - size * 0.15);
  ctx.stroke();
  // Chain links
  ctx.strokeStyle = "#57534e";
  ctx.lineWidth = 1 * zoom;
  for (let link = 0; link < 4; link++) {
    const linkX = x - size * 0.28 + link * size * 0.08;
    const linkY = y + size * 0.15 - link * size * 0.08;
    ctx.beginPath();
    ctx.ellipse(linkX, linkY, size * 0.025, size * 0.015, 0.5, 0, Math.PI * 2);
    ctx.stroke();
  }

  // Undead crew member
  ctx.fillStyle = "#1c1917";
  ctx.beginPath();
  ctx.ellipse(x + size * 0.18, y - size * 0.06, size * 0.1, size * 0.14, 0, 0, Math.PI * 2);
  ctx.fill();
  // Skeletal head
  ctx.fillStyle = "#a8a29e";
  ctx.beginPath();
  ctx.arc(x + size * 0.18, y - size * 0.24, size * 0.08, 0, Math.PI * 2);
  ctx.fill();
  // Helmet (rusted and spiked)
  ctx.fillStyle = "#44403c";
  ctx.beginPath();
  ctx.arc(x + size * 0.18, y - size * 0.28, size * 0.09, Math.PI, 0);
  ctx.fill();
  // Helmet spike
  ctx.fillStyle = "#292524";
  ctx.beginPath();
  ctx.moveTo(x + size * 0.18, y - size * 0.36);
  ctx.lineTo(x + size * 0.15, y - size * 0.28);
  ctx.lineTo(x + size * 0.21, y - size * 0.28);
  ctx.fill();
  // Glowing eyes
  ctx.fillStyle = `rgba(220, 38, 38, ${hellGlow})`;
  ctx.shadowColor = "#dc2626";
  ctx.shadowBlur = 4 * zoom;
  ctx.beginPath();
  ctx.arc(x + size * 0.16, y - size * 0.25, size * 0.015, 0, Math.PI * 2);
  ctx.arc(x + size * 0.2, y - size * 0.25, size * 0.015, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
}

function drawWarlockEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // VOID ARCHLICH - Ancient undead sorcerer channeling the abyss itself
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const hover = Math.sin(time * 2) * 5 * zoom + (isAttacking ? attackIntensity * size * 0.2 : 0);
  const darkPulse = 0.5 + Math.sin(time * 3) * 0.35;
  const voidRip = 0.6 + Math.sin(time * 4) * 0.3;
  const soulDrain = Math.sin(time * 6) > 0.5 ? 1 : 0.6;

  // Reality-tearing void portal beneath
  ctx.save();
  for (let ring = 0; ring < 3; ring++) {
    const ringSize = size * (0.3 + ring * 0.15) + Math.sin(time * 2 + ring) * size * 0.05;
    ctx.strokeStyle = `rgba(76, 29, 149, ${voidRip * (0.5 - ring * 0.15)})`;
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.ellipse(x, y + size * 0.45, ringSize, ringSize * 0.25, 0, 0, Math.PI * 2);
    ctx.stroke();
  }
  ctx.restore();

  // Dark void aura - more intense
  const voidGrad = ctx.createRadialGradient(x, y, size * 0.08, x, y, size * 0.85);
  voidGrad.addColorStop(0, `rgba(88, 28, 135, ${darkPulse * 0.5})`);
  voidGrad.addColorStop(0.3, `rgba(76, 29, 149, ${darkPulse * 0.35})`);
  voidGrad.addColorStop(0.6, `rgba(30, 10, 60, ${darkPulse * 0.2})`);
  voidGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = voidGrad;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.85, 0, Math.PI * 2);
  ctx.fill();

  // Captured soul wisps orbiting
  for (let soul = 0; soul < 6; soul++) {
    const soulAngle = time * 1.5 + soul * Math.PI / 3;
    const soulDist = size * 0.5 + Math.sin(time * 2 + soul) * size * 0.08;
    const sx = x + Math.cos(soulAngle) * soulDist;
    const sy = y + Math.sin(soulAngle) * soulDist * 0.4;
    ctx.fillStyle = `rgba(167, 139, 250, ${0.4 + Math.sin(time * 4 + soul) * 0.25})`;
    ctx.shadowColor = "#a78bfa";
    ctx.shadowBlur = 6 * zoom;
    ctx.beginPath();
    ctx.arc(sx, sy, size * 0.03, 0, Math.PI * 2);
    ctx.fill();
    // Soul trail
    ctx.strokeStyle = `rgba(167, 139, 250, 0.2)`;
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(sx - Math.cos(soulAngle) * size * 0.08, sy - Math.sin(soulAngle) * size * 0.03);
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  // Shadow tendrils - more elaborate
  ctx.strokeStyle = `rgba(88, 28, 135, ${darkPulse * 0.7})`;
  ctx.lineWidth = 2.5 * zoom;
  for (let i = 0; i < 7; i++) {
    const tendrilAngle = time * 0.6 + i * Math.PI * 0.285;
    ctx.beginPath();
    ctx.moveTo(x, y + size * 0.32);
    let tx = x, ty = y + size * 0.32;
    for (let seg = 0; seg < 4; seg++) {
      tx += Math.cos(tendrilAngle + Math.sin(time * 2 + seg) * 0.4) * size * 0.12;
      ty += size * 0.05 + Math.sin(time * 3 + i + seg) * size * 0.03;
      ctx.lineTo(tx, ty);
    }
    ctx.stroke();
  }

  // Deeper shadow
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.52, 0, x, y + size * 0.52, size * 0.4);
  shadowGrad.addColorStop(0, "rgba(30, 10, 60, 0.7)");
  shadowGrad.addColorStop(0.6, "rgba(30, 10, 60, 0.3)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.52, size * 0.4, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  // Dark robes - more tattered and flowing
  const robeGrad = ctx.createLinearGradient(x - size * 0.45, y, x + size * 0.45, y);
  robeGrad.addColorStop(0, "#0f0520");
  robeGrad.addColorStop(0.3, "#1e0a3c");
  robeGrad.addColorStop(0.5, "#2d1450");
  robeGrad.addColorStop(0.7, "#1e0a3c");
  robeGrad.addColorStop(1, "#0f0520");
  ctx.fillStyle = robeGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.45, y + size * 0.55);
  for (let i = 0; i < 8; i++) {
    const waveX = x - size * 0.45 + i * size * 0.1125;
    const waveY = y + size * 0.55 + Math.sin(time * 4 + i * 1.2) * size * 0.06 + (i % 2) * size * 0.04;
    ctx.lineTo(waveX, waveY);
  }
  ctx.quadraticCurveTo(x + size * 0.5, y, x + size * 0.18, y - size * 0.45 + hover);
  ctx.lineTo(x - size * 0.18, y - size * 0.45 + hover);
  ctx.quadraticCurveTo(x - size * 0.5, y, x - size * 0.45, y + size * 0.55);
  ctx.fill();

  // Void symbols on robe
  ctx.strokeStyle = `rgba(147, 51, 234, ${voidRip * 0.5})`;
  ctx.lineWidth = 1.5 * zoom;
  for (let sym = 0; sym < 4; sym++) {
    const symX = x - size * 0.2 + sym * size * 0.13;
    const symY = y + size * 0.1 + sym * size * 0.08;
    ctx.beginPath();
    ctx.arc(symX, symY, size * 0.03, 0, Math.PI * 2);
    ctx.moveTo(symX, symY - size * 0.04);
    ctx.lineTo(symX, symY + size * 0.04);
    ctx.stroke();
  }

  // Ancient skull face
  const skullGrad = ctx.createRadialGradient(x, y - size * 0.38 + hover, 0, x, y - size * 0.38 + hover, size * 0.2);
  skullGrad.addColorStop(0, "#f5f5f4");
  skullGrad.addColorStop(0.6, "#e8e0d0");
  skullGrad.addColorStop(1, "#d6d3d1");
  ctx.fillStyle = skullGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.38 + hover, size * 0.2, 0, Math.PI * 2);
  ctx.fill();
  // Skull cracks
  ctx.strokeStyle = "#a8a29e";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.05, y - size * 0.5 + hover);
  ctx.lineTo(x - size * 0.08, y - size * 0.42 + hover);
  ctx.lineTo(x - size * 0.03, y - size * 0.35 + hover);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.1, y - size * 0.48 + hover);
  ctx.lineTo(x + size * 0.06, y - size * 0.38 + hover);
  ctx.stroke();
  // Hollow eye sockets
  ctx.fillStyle = "#0f0520";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.08, y - size * 0.4 + hover, size * 0.055, size * 0.065, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.08, y - size * 0.4 + hover, size * 0.055, size * 0.065, 0, 0, Math.PI * 2);
  ctx.fill();
  // Void-fire eyes
  ctx.fillStyle = "#9333ea";
  ctx.shadowColor = "#9333ea";
  ctx.shadowBlur = 12 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.08, y - size * 0.4 + hover, size * 0.03, 0, Math.PI * 2);
  ctx.arc(x + size * 0.08, y - size * 0.4 + hover, size * 0.03, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Skeletal nose hole
  ctx.fillStyle = "#1e0a3c";
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.34 + hover);
  ctx.lineTo(x - size * 0.025, y - size * 0.28 + hover);
  ctx.lineTo(x + size * 0.025, y - size * 0.28 + hover);
  ctx.fill();
  // Grinning teeth
  ctx.fillStyle = "#e8e0d0";
  ctx.fillRect(x - size * 0.08, y - size * 0.26 + hover, size * 0.16, size * 0.045);
  ctx.strokeStyle = "#1e0a3c";
  ctx.lineWidth = 1 * zoom;
  for (let i = 0; i < 6; i++) {
    ctx.beginPath();
    ctx.moveTo(x - size * 0.07 + i * size * 0.028, y - size * 0.26 + hover);
    ctx.lineTo(x - size * 0.07 + i * size * 0.028, y - size * 0.215 + hover);
    ctx.stroke();
  }

  // Ornate hood with runes
  ctx.fillStyle = "#0a0315";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.52 + hover, size * 0.25, size * 0.14, 0, Math.PI, 0);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x - size * 0.25, y - size * 0.52 + hover);
  ctx.quadraticCurveTo(x - size * 0.3, y - size * 0.25 + hover, x - size * 0.22, y - size * 0.1 + hover);
  ctx.lineTo(x - size * 0.18, y - size * 0.35 + hover);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.25, y - size * 0.52 + hover);
  ctx.quadraticCurveTo(x + size * 0.3, y - size * 0.25 + hover, x + size * 0.22, y - size * 0.1 + hover);
  ctx.lineTo(x + size * 0.18, y - size * 0.35 + hover);
  ctx.fill();
  // Hood runes
  ctx.strokeStyle = `rgba(147, 51, 234, ${darkPulse})`;
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.58 + hover, size * 0.06, 0, Math.PI * 2);
  ctx.stroke();

  // Void orb in hand - more detailed
  ctx.fillStyle = "#4c1d95";
  ctx.shadowColor = "#9333ea";
  ctx.shadowBlur = 15 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.35, y + size * 0.02 + hover, size * 0.14, 0, Math.PI * 2);
  ctx.fill();
  // Dark energy swirls in orb
  ctx.strokeStyle = "#1e0a3c";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.35, y + size * 0.02 + hover, size * 0.1, time * 2, time * 2 + Math.PI);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(x - size * 0.35, y + size * 0.02 + hover, size * 0.06, time * 3 + Math.PI, time * 3 + Math.PI * 2);
  ctx.stroke();
  // Inner glow
  ctx.fillStyle = `rgba(167, 139, 250, ${soulDrain * 0.6})`;
  ctx.beginPath();
  ctx.arc(x - size * 0.35, y + hover, size * 0.04, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Skeletal hand holding orb
  ctx.fillStyle = "#a8a29e";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.28, y + size * 0.08 + hover, size * 0.04, size * 0.02, 0.3, 0, Math.PI * 2);
  ctx.fill();
}

function drawCrossbowmanEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // DOOM ARBALIST - Cursed siege specialist with soul-piercing siege crossbow
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const aim = Math.sin(time * 2) * 0.06 + (isAttacking ? attackIntensity * 0.15 : 0);
  const stance = Math.sin(time * 4) * 2.5 * zoom;
  const curseGlow = 0.5 + Math.sin(time * 3) * 0.3;
  const boltCharge = 0.6 + Math.sin(time * 5) * 0.3;

  // Cursed ground aura
  ctx.fillStyle = `rgba(127, 29, 29, ${curseGlow * 0.2})`;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.45, size * 0.4, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  // Shadow with curse marks
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.5, 0, x, y + size * 0.5, size * 0.35);
  shadowGrad.addColorStop(0, "rgba(0, 0, 0, 0.5)");
  shadowGrad.addColorStop(0.6, "rgba(0, 0, 0, 0.25)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.5, size * 0.35, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  // Heavy cursed armor body
  const armorGrad = ctx.createLinearGradient(x - size * 0.35, y, x + size * 0.35, y);
  armorGrad.addColorStop(0, "#292524");
  armorGrad.addColorStop(0.2, "#44403c");
  armorGrad.addColorStop(0.5, "#57534e");
  armorGrad.addColorStop(0.8, "#44403c");
  armorGrad.addColorStop(1, "#292524");
  ctx.fillStyle = armorGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.35, y + size * 0.48);
  ctx.lineTo(x - size * 0.38, y - size * 0.12);
  ctx.quadraticCurveTo(x, y - size * 0.38, x + size * 0.38, y - size * 0.12);
  ctx.lineTo(x + size * 0.35, y + size * 0.48);
  ctx.closePath();
  ctx.fill();

  // Spiked pauldrons
  ctx.fillStyle = "#3f3f46";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.32, y - size * 0.12 + stance * 0.2, size * 0.1, size * 0.06, -0.3, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.32, y - size * 0.12 + stance * 0.2, size * 0.1, size * 0.06, 0.3, 0, Math.PI * 2);
  ctx.fill();
  // Shoulder spikes
  ctx.fillStyle = "#27272a";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.35, y - size * 0.14 + stance * 0.2);
  ctx.lineTo(x - size * 0.42, y - size * 0.28 + stance * 0.2);
  ctx.lineTo(x - size * 0.32, y - size * 0.12 + stance * 0.2);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.35, y - size * 0.14 + stance * 0.2);
  ctx.lineTo(x + size * 0.42, y - size * 0.28 + stance * 0.2);
  ctx.lineTo(x + size * 0.32, y - size * 0.12 + stance * 0.2);
  ctx.fill();

  // Runed chest plate
  const plateGrad = ctx.createLinearGradient(x - size * 0.22, y - size * 0.2, x + size * 0.22, y + size * 0.2);
  plateGrad.addColorStop(0, "#52525b");
  plateGrad.addColorStop(0.5, "#71717a");
  plateGrad.addColorStop(1, "#52525b");
  ctx.fillStyle = plateGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.22, y + size * 0.22);
  ctx.lineTo(x - size * 0.24, y - size * 0.18);
  ctx.quadraticCurveTo(x, y - size * 0.28, x + size * 0.24, y - size * 0.18);
  ctx.lineTo(x + size * 0.22, y + size * 0.22);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "#3f3f46";
  ctx.lineWidth = 2.5 * zoom;
  ctx.stroke();
  // Curse runes on plate
  ctx.strokeStyle = `rgba(127, 29, 29, ${curseGlow * 0.6})`;
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.2);
  ctx.lineTo(x, y + size * 0.15);
  ctx.moveTo(x - size * 0.12, y - size * 0.05);
  ctx.lineTo(x + size * 0.12, y - size * 0.05);
  ctx.stroke();
  // Skull emblem
  ctx.fillStyle = "#a8a29e";
  ctx.beginPath();
  ctx.arc(x, y - size * 0.02, size * 0.04, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#1c1917";
  ctx.beginPath();
  ctx.arc(x - size * 0.012, y - size * 0.025, size * 0.008, 0, Math.PI * 2);
  ctx.arc(x + size * 0.012, y - size * 0.025, size * 0.008, 0, Math.PI * 2);
  ctx.fill();

  // Metal rivets with glow
  ctx.fillStyle = "#71717a";
  for (let i = 0; i < 4; i++) {
    ctx.beginPath();
    ctx.arc(x - size * 0.15 + i * size * 0.1, y - size * 0.12, size * 0.022, 0, Math.PI * 2);
    ctx.fill();
  }

  // Partially visible face under helmet
  ctx.fillStyle = "#78716c";
  ctx.beginPath();
  ctx.arc(x, y - size * 0.4, size * 0.15, 0.35 * Math.PI, 2.65 * Math.PI);
  ctx.fill();

  // Menacing sallet helmet with horn
  const helmGrad = ctx.createLinearGradient(x - size * 0.2, y - size * 0.5, x + size * 0.2, y - size * 0.35);
  helmGrad.addColorStop(0, "#3f3f46");
  helmGrad.addColorStop(0.5, "#52525b");
  helmGrad.addColorStop(1, "#3f3f46");
  ctx.fillStyle = helmGrad;
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.48, size * 0.2, size * 0.14, 0, Math.PI, 0);
  ctx.fill();
  // Helmet tail (longer, more menacing)
  ctx.beginPath();
  ctx.moveTo(x + size * 0.14, y - size * 0.45);
  ctx.quadraticCurveTo(x + size * 0.3, y - size * 0.4, x + size * 0.25, y - size * 0.28);
  ctx.lineTo(x + size * 0.12, y - size * 0.38);
  ctx.fill();
  // Single horn
  ctx.fillStyle = "#27272a";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.05, y - size * 0.58);
  ctx.lineTo(x, y - size * 0.72);
  ctx.lineTo(x + size * 0.05, y - size * 0.58);
  ctx.fill();
  // Visor with T-slit
  ctx.fillStyle = "#27272a";
  ctx.fillRect(x - size * 0.14, y - size * 0.46, size * 0.28, size * 0.08);
  // T-shaped eye slit with red glow
  ctx.fillStyle = `rgba(127, 29, 29, ${curseGlow})`;
  ctx.shadowColor = "#7f1d1d";
  ctx.shadowBlur = 4 * zoom;
  ctx.fillRect(x - size * 0.12, y - size * 0.44, size * 0.24, size * 0.025);
  ctx.fillRect(x - size * 0.015, y - size * 0.44, size * 0.03, size * 0.05);
  ctx.shadowBlur = 0;

  // Massive siege crossbow with soul mechanism
  ctx.save();
  ctx.translate(x - size * 0.18, y + size * 0.06);
  ctx.rotate(aim);
  // Reinforced stock with bone inlay
  const stockGrad = ctx.createLinearGradient(-size * 0.45, 0, size * 0.05, 0);
  stockGrad.addColorStop(0, "#292524");
  stockGrad.addColorStop(0.5, "#44403c");
  stockGrad.addColorStop(1, "#292524");
  ctx.fillStyle = stockGrad;
  ctx.fillRect(-size * 0.45, -size * 0.05, size * 0.5, size * 0.1);
  // Bone decorations
  ctx.fillStyle = "#a8a29e";
  ctx.fillRect(-size * 0.35, -size * 0.04, size * 0.06, size * 0.08);
  ctx.fillRect(-size * 0.15, -size * 0.04, size * 0.06, size * 0.08);
  // Heavy metal parts with runes
  ctx.fillStyle = "#3f3f46";
  ctx.fillRect(-size * 0.48, -size * 0.06, size * 0.1, size * 0.12);
  // Curse rune on metal
  ctx.strokeStyle = `rgba(127, 29, 29, ${boltCharge})`;
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.arc(-size * 0.43, 0, size * 0.025, 0, Math.PI * 2);
  ctx.stroke();
  // Reinforced bow limbs with spikes
  ctx.strokeStyle = "#1c1917";
  ctx.lineWidth = 5 * zoom;
  ctx.beginPath();
  ctx.moveTo(-size * 0.45, 0);
  ctx.quadraticCurveTo(-size * 0.62, -size * 0.22, -size * 0.52, -size * 0.4);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-size * 0.45, 0);
  ctx.quadraticCurveTo(-size * 0.62, size * 0.22, -size * 0.52, size * 0.4);
  ctx.stroke();
  // Limb spikes
  ctx.fillStyle = "#1c1917";
  ctx.beginPath();
  ctx.moveTo(-size * 0.52, -size * 0.4);
  ctx.lineTo(-size * 0.48, -size * 0.5);
  ctx.lineTo(-size * 0.55, -size * 0.42);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(-size * 0.52, size * 0.4);
  ctx.lineTo(-size * 0.48, size * 0.5);
  ctx.lineTo(-size * 0.55, size * 0.42);
  ctx.fill();
  // Soul-chain bowstring
  ctx.strokeStyle = `rgba(127, 29, 29, ${boltCharge * 0.8})`;
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(-size * 0.52, -size * 0.4);
  ctx.lineTo(-size * 0.18, 0);
  ctx.lineTo(-size * 0.52, size * 0.4);
  ctx.stroke();
  // Soul-piercing bolt
  ctx.fillStyle = "#1c1917";
  ctx.fillRect(-size * 0.62, -size * 0.018, size * 0.35, size * 0.036);
  // Glowing bolt head
  ctx.fillStyle = `rgba(127, 29, 29, ${boltCharge})`;
  ctx.shadowColor = "#7f1d1d";
  ctx.shadowBlur = 6 * zoom;
  ctx.beginPath();
  ctx.moveTo(-size * 0.68, 0);
  ctx.lineTo(-size * 0.58, -size * 0.04);
  ctx.lineTo(-size * 0.58, size * 0.04);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Bolt fletching
  ctx.fillStyle = "#44403c";
  ctx.beginPath();
  ctx.moveTo(-size * 0.28, 0);
  ctx.lineTo(-size * 0.22, -size * 0.03);
  ctx.lineTo(-size * 0.22, size * 0.03);
  ctx.fill();
  ctx.restore();
}

function drawHexerEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // HEX WITCH - Malevolent Curse Weaver with Forbidden Magic
  // A dark sorceress wreathed in swirling hex runes and cursed energy
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase;
  const sway = Math.sin(time * 3) * 3 * zoom + (isAttacking ? attackIntensity * size * 0.15 : 0);
  const hexPulse = 0.6 + Math.sin(time * 5) * 0.4;
  const breathe = Math.sin(time * 2.5) * size * 0.015;
  const curseIntensity = isAttacking ? 0.7 + attackIntensity * 0.3 : 0.4 + Math.sin(time * 4) * 0.2;
  const hover = Math.sin(time * 2) * size * 0.02;

  // === LAYER 1: CURSE DOMAIN AURA ===
  // Dark magic ground pool
  const poolGrad = ctx.createRadialGradient(x, y + size * 0.5, 0, x, y + size * 0.5, size * 0.55);
  poolGrad.addColorStop(0, `rgba(190, 24, 93, ${curseIntensity * 0.35})`);
  poolGrad.addColorStop(0.4, `rgba(131, 24, 67, ${curseIntensity * 0.2})`);
  poolGrad.addColorStop(0.7, `rgba(76, 29, 149, ${curseIntensity * 0.1})`);
  poolGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = poolGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.5, size * 0.55, size * 0.18, 0, 0, Math.PI * 2);
  ctx.fill();

  // Rippling curse rings on ground
  for (let ring = 0; ring < 3; ring++) {
    const ringPhase = (time * 0.8 + ring * 0.4) % 1;
    const ringSize = size * (0.2 + ringPhase * 0.35);
    const ringAlpha = (0.4 - ringPhase * 0.35) * curseIntensity;
    ctx.strokeStyle = `rgba(190, 24, 93, ${ringAlpha})`;
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.ellipse(x, y + size * 0.5, ringSize, ringSize * 0.3, 0, 0, Math.PI * 2);
    ctx.stroke();
  }

  // === LAYER 2: FLOATING HEX CIRCLES - ORBITAL CURSE RUNES ===
  for (let i = 0; i < 5; i++) {
    const orbitAngle = time * 1.2 + i * Math.PI * 0.4;
    const orbitDist = size * 0.55 + Math.sin(time * 2 + i) * size * 0.08;
    const orbitX = x + Math.cos(orbitAngle) * orbitDist;
    const orbitY = y - size * 0.1 + Math.sin(orbitAngle) * orbitDist * 0.4 + hover;
    const runeSize = size * 0.1 + Math.sin(time * 4 + i * 2) * size * 0.015;
    
    // Hex rune glow (gradient instead of shadowBlur)
    const runeGlow = ctx.createRadialGradient(orbitX, orbitY, 0, orbitX, orbitY, runeSize * 2.5);
    runeGlow.addColorStop(0, `rgba(190, 24, 93, ${hexPulse * 0.5})`);
    runeGlow.addColorStop(0.4, `rgba(190, 24, 93, ${hexPulse * 0.2})`);
    runeGlow.addColorStop(1, "rgba(190, 24, 93, 0)");
    ctx.fillStyle = runeGlow;
    ctx.beginPath();
    ctx.arc(orbitX, orbitY, runeSize * 2.5, 0, Math.PI * 2);
    ctx.fill();

    // Hex circle outer ring
    ctx.strokeStyle = `rgba(236, 72, 153, ${hexPulse * 0.8})`;
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.arc(orbitX, orbitY, runeSize, 0, Math.PI * 2);
    ctx.stroke();

    // Inner hex circle
    ctx.strokeStyle = `rgba(190, 24, 93, ${hexPulse})`;
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.arc(orbitX, orbitY, runeSize * 0.65, 0, Math.PI * 2);
    ctx.stroke();

    // Hex rune symbol (6-pointed star)
    ctx.fillStyle = `rgba(251, 113, 133, ${hexPulse})`;
    for (let p = 0; p < 6; p++) {
      const starAngle = time * 0.5 + p * Math.PI / 3;
      ctx.beginPath();
      ctx.moveTo(orbitX, orbitY);
      ctx.lineTo(
        orbitX + Math.cos(starAngle) * runeSize * 0.5,
        orbitY + Math.sin(starAngle) * runeSize * 0.5
      );
      ctx.lineTo(
        orbitX + Math.cos(starAngle + Math.PI / 6) * runeSize * 0.25,
        orbitY + Math.sin(starAngle + Math.PI / 6) * runeSize * 0.25
      );
      ctx.fill();
    }

    // Connecting energy thread to witch
    ctx.strokeStyle = `rgba(190, 24, 93, ${0.15 + Math.sin(time * 3 + i) * 0.1})`;
    ctx.lineWidth = 1 * zoom;
    ctx.beginPath();
    ctx.moveTo(orbitX, orbitY);
    ctx.quadraticCurveTo(
      x + Math.cos(orbitAngle) * orbitDist * 0.5,
      y - size * 0.2 + hover,
      x,
      y - size * 0.15 + hover
    );
    ctx.stroke();
  }

  // === LAYER 3: CURSE PARTICLES ===
  for (let p = 0; p < 12; p++) {
    const particlePhase = (time * 0.6 + p * 0.15) % 1;
    const particleAngle = p * Math.PI / 6 + time * 0.3;
    const particleDist = size * (0.2 + particlePhase * 0.5);
    const px = x + Math.cos(particleAngle) * particleDist;
    const py = y - size * 0.1 - particlePhase * size * 0.4 + hover;
    const particleAlpha = (1 - particlePhase) * 0.5 * curseIntensity;
    const particleSize = size * 0.02 * (1 - particlePhase * 0.5);
    
    ctx.fillStyle = `rgba(236, 72, 153, ${particleAlpha})`;
    ctx.beginPath();
    ctx.arc(px, py, particleSize, 0, Math.PI * 2);
    ctx.fill();
  }

  // === LAYER 4: SHADOW ===
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.52, 0, x, y + size * 0.52, size * 0.35);
  shadowGrad.addColorStop(0, "rgba(76, 29, 149, 0.5)");
  shadowGrad.addColorStop(0.5, "rgba(0, 0, 0, 0.3)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.52, size * 0.35, size * 0.1, 0, 0, Math.PI * 2);
  ctx.fill();

  // === LAYER 5: TATTERED DRESS WITH MAGICAL THREADS ===
  const dressGrad = ctx.createLinearGradient(x - size * 0.4, y, x + size * 0.4, y);
  dressGrad.addColorStop(0, "#6b21a8");
  dressGrad.addColorStop(0.3, "#9d174d");
  dressGrad.addColorStop(0.5, "#be185d");
  dressGrad.addColorStop(0.7, "#9d174d");
  dressGrad.addColorStop(1, "#6b21a8");
  ctx.fillStyle = dressGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.4, y + size * 0.52);
  // Ragged bottom edge with more detail
  for (let i = 0; i < 9; i++) {
    const jagX = x - size * 0.4 + i * size * 0.1;
    const jagY = y + size * 0.52 + Math.sin(time * 4 + i * 0.8) * size * 0.04 + (i % 2) * size * 0.08;
    ctx.lineTo(jagX, jagY);
  }
  ctx.quadraticCurveTo(x + size * 0.42, y + size * 0.1, x + size * 0.18, y - size * 0.32 + sway + breathe);
  ctx.lineTo(x - size * 0.18, y - size * 0.32 + sway + breathe);
  ctx.quadraticCurveTo(x - size * 0.42, y + size * 0.1, x - size * 0.4, y + size * 0.52);
  ctx.fill();

  // Dress inner shading
  const innerDressGrad = ctx.createLinearGradient(x, y - size * 0.2, x, y + size * 0.5);
  innerDressGrad.addColorStop(0, "rgba(0, 0, 0, 0)");
  innerDressGrad.addColorStop(0.5, "rgba(0, 0, 0, 0.2)");
  innerDressGrad.addColorStop(1, "rgba(0, 0, 0, 0.4)");
  ctx.fillStyle = innerDressGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.15, size * 0.25, size * 0.35, 0, 0, Math.PI * 2);
  ctx.fill();

  // Magical thread patterns on dress
  ctx.strokeStyle = `rgba(236, 72, 153, ${hexPulse * 0.4})`;
  ctx.lineWidth = 1 * zoom;
  for (let thread = 0; thread < 5; thread++) {
    const threadX = x - size * 0.2 + thread * size * 0.1;
    ctx.beginPath();
    ctx.moveTo(threadX, y - size * 0.1 + sway * 0.3);
    ctx.bezierCurveTo(
      threadX + Math.sin(time * 2 + thread) * size * 0.05,
      y + size * 0.1,
      threadX - Math.cos(time * 2 + thread) * size * 0.04,
      y + size * 0.3,
      threadX + Math.sin(thread) * size * 0.06,
      y + size * 0.48
    );
    ctx.stroke();
  }

  // Belt with curse gems
  ctx.fillStyle = "#1a1a2e";
  ctx.fillRect(x - size * 0.22, y - size * 0.12 + sway * 0.5, size * 0.44, size * 0.05);
  // Gem centerpiece
  const gemGrad = ctx.createRadialGradient(x, y - size * 0.1 + sway * 0.5, 0, x, y - size * 0.1 + sway * 0.5, size * 0.04);
  gemGrad.addColorStop(0, "#fb7185");
  gemGrad.addColorStop(0.5, "#be185d");
  gemGrad.addColorStop(1, "#831843");
  ctx.fillStyle = gemGrad;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.14 + sway * 0.5);
  ctx.lineTo(x - size * 0.035, y - size * 0.1 + sway * 0.5);
  ctx.lineTo(x, y - size * 0.06 + sway * 0.5);
  ctx.lineTo(x + size * 0.035, y - size * 0.1 + sway * 0.5);
  ctx.fill();

  // === LAYER 6: WILD FLOWING HAIR ===
  // Multiple hair strands for detail
  const hairColors = ["#1a1a2e", "#2d1f3d", "#1e1b4b"];
  for (let strand = 0; strand < 6; strand++) {
    const strandSide = strand < 3 ? -1 : 1;
    const strandOffset = (strand % 3) * 0.1;
    ctx.fillStyle = hairColors[strand % 3];
    ctx.beginPath();
    ctx.moveTo(x + strandSide * (size * 0.12 + strandOffset * size), y - size * 0.45 + sway);
    ctx.quadraticCurveTo(
      x + strandSide * (size * 0.35 + strandOffset * size * 0.5),
      y - size * 0.25 + Math.sin(time * 3 + strand) * size * 0.05,
      x + strandSide * (size * 0.32 + strandOffset * size * 0.3),
      y + size * 0.15 + Math.sin(time * 2.5 + strand * 0.5) * size * 0.08
    );
    ctx.quadraticCurveTo(
      x + strandSide * (size * 0.22 + strandOffset * size * 0.2),
      y - size * 0.05,
      x + strandSide * (size * 0.08 + strandOffset * size * 0.1),
      y - size * 0.4 + sway
    );
    ctx.fill();
  }

  // Hair highlights
  ctx.strokeStyle = "rgba(139, 92, 246, 0.3)";
  ctx.lineWidth = 1 * zoom;
  for (let hl = 0; hl < 4; hl++) {
    const hlSide = hl < 2 ? -1 : 1;
    ctx.beginPath();
    ctx.moveTo(x + hlSide * size * (0.15 + hl * 0.05), y - size * 0.43 + sway);
    ctx.quadraticCurveTo(
      x + hlSide * size * 0.25,
      y - size * 0.1,
      x + hlSide * size * 0.28,
      y + size * 0.05
    );
    ctx.stroke();
  }

  // === LAYER 7: PALE FACE WITH DETAILS ===
  // Face glow effect (gradient)
  const faceGlow = ctx.createRadialGradient(x, y - size * 0.42 + sway, 0, x, y - size * 0.42 + sway, size * 0.22);
  faceGlow.addColorStop(0, "rgba(251, 207, 232, 0.3)");
  faceGlow.addColorStop(1, "rgba(251, 207, 232, 0)");
  ctx.fillStyle = faceGlow;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.42 + sway, size * 0.22, 0, Math.PI * 2);
  ctx.fill();

  // Face base
  const faceGrad = ctx.createRadialGradient(x, y - size * 0.44 + sway, 0, x, y - size * 0.4 + sway, size * 0.16);
  faceGrad.addColorStop(0, "#fdf4ff");
  faceGrad.addColorStop(0.7, "#f5f5f5");
  faceGrad.addColorStop(1, "#e5e5e5");
  ctx.fillStyle = faceGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.42 + sway, size * 0.16, 0, Math.PI * 2);
  ctx.fill();

  // Cheek shadows
  ctx.fillStyle = "rgba(190, 24, 93, 0.15)";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.08, y - size * 0.38 + sway, size * 0.04, size * 0.025, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.08, y - size * 0.38 + sway, size * 0.04, size * 0.025, 0, 0, Math.PI * 2);
  ctx.fill();

  // Eye sockets (darker)
  ctx.fillStyle = "rgba(88, 28, 135, 0.3)";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.06, y - size * 0.44 + sway, size * 0.05, size * 0.03, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.06, y - size * 0.44 + sway, size * 0.05, size * 0.03, 0, 0, Math.PI * 2);
  ctx.fill();

  // Sinister eyes with glow (gradient instead of shadowBlur)
  const eyeGlow = ctx.createRadialGradient(x - size * 0.06, y - size * 0.44 + sway, 0, x - size * 0.06, y - size * 0.44 + sway, size * 0.06);
  eyeGlow.addColorStop(0, "#f472b6");
  eyeGlow.addColorStop(0.4, "rgba(236, 72, 153, 0.6)");
  eyeGlow.addColorStop(1, "rgba(236, 72, 153, 0)");
  ctx.fillStyle = eyeGlow;
  ctx.beginPath();
  ctx.arc(x - size * 0.06, y - size * 0.44 + sway, size * 0.06, 0, Math.PI * 2);
  ctx.arc(x + size * 0.06, y - size * 0.44 + sway, size * 0.06, 0, Math.PI * 2);
  ctx.fill();

  // Eye cores
  ctx.fillStyle = "#be185d";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.06, y - size * 0.44 + sway, size * 0.035, size * 0.025, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.06, y - size * 0.44 + sway, size * 0.035, size * 0.025, 0, 0, Math.PI * 2);
  ctx.fill();

  // Eye pupils
  ctx.fillStyle = "#1a1a2e";
  ctx.beginPath();
  ctx.arc(x - size * 0.055, y - size * 0.445 + sway, size * 0.012, 0, Math.PI * 2);
  ctx.arc(x + size * 0.055, y - size * 0.445 + sway, size * 0.012, 0, Math.PI * 2);
  ctx.fill();

  // Eye highlights
  ctx.fillStyle = "#fdf4ff";
  ctx.beginPath();
  ctx.arc(x - size * 0.07, y - size * 0.45 + sway, size * 0.008, 0, Math.PI * 2);
  ctx.arc(x + size * 0.05, y - size * 0.45 + sway, size * 0.008, 0, Math.PI * 2);
  ctx.fill();

  // Wicked smile
  ctx.strokeStyle = "#4a1942";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.34 + sway, size * 0.07, 0.1 * Math.PI, 0.9 * Math.PI);
  ctx.stroke();
  // Smile corners
  ctx.beginPath();
  ctx.moveTo(x - size * 0.06, y - size * 0.33 + sway);
  ctx.lineTo(x - size * 0.075, y - size * 0.35 + sway);
  ctx.moveTo(x + size * 0.06, y - size * 0.33 + sway);
  ctx.lineTo(x + size * 0.075, y - size * 0.35 + sway);
  ctx.stroke();

  // Nose
  ctx.strokeStyle = "rgba(0, 0, 0, 0.2)";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.42 + sway);
  ctx.lineTo(x, y - size * 0.37 + sway);
  ctx.stroke();

  // === LAYER 8: ORNATE WITCH HAT ===
  // Hat body
  const hatGrad = ctx.createLinearGradient(x - size * 0.2, y - size * 0.9 + sway, x + size * 0.2, y - size * 0.5 + sway);
  hatGrad.addColorStop(0, "#0f0f23");
  hatGrad.addColorStop(0.5, "#1a1a2e");
  hatGrad.addColorStop(1, "#2d2d44");
  ctx.fillStyle = hatGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.2, y - size * 0.54 + sway);
  ctx.quadraticCurveTo(x - size * 0.08, y - size * 0.72 + sway, x + size * 0.12, y - size * 0.92 + sway + Math.sin(time * 2) * size * 0.02);
  ctx.lineTo(x + size * 0.2, y - size * 0.54 + sway);
  ctx.closePath();
  ctx.fill();

  // Hat brim
  ctx.fillStyle = "#1a1a2e";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.54 + sway, size * 0.24, size * 0.07, 0, 0, Math.PI * 2);
  ctx.fill();

  // Hat band with rune pattern
  ctx.fillStyle = "#9d174d";
  ctx.fillRect(x - size * 0.17, y - size * 0.62 + sway, size * 0.28, size * 0.05);
  // Rune symbols on band
  ctx.fillStyle = "#fb7185";
  for (let r = 0; r < 4; r++) {
    const runeX = x - size * 0.12 + r * size * 0.08;
    ctx.beginPath();
    ctx.arc(runeX, y - size * 0.595 + sway, size * 0.015, 0, Math.PI * 2);
    ctx.fill();
  }

  // Hat gem
  const hatGem = ctx.createRadialGradient(x + size * 0.08, y - size * 0.88 + sway, 0, x + size * 0.08, y - size * 0.88 + sway, size * 0.04);
  hatGem.addColorStop(0, "#fb7185");
  hatGem.addColorStop(0.5, "#be185d");
  hatGem.addColorStop(1, "#831843");
  ctx.fillStyle = hatGem;
  ctx.beginPath();
  ctx.arc(x + size * 0.1, y - size * 0.85 + sway, size * 0.035, 0, Math.PI * 2);
  ctx.fill();

  // === LAYER 9: CURSE STAFF ===
  // Staff body
  ctx.strokeStyle = "#1c1917";
  ctx.lineWidth = 4 * zoom;
  ctx.beginPath();
  ctx.moveTo(x + size * 0.22, y - size * 0.12 + sway);
  ctx.lineTo(x + size * 0.48, y + size * 0.35);
  ctx.stroke();

  // Staff grip wrapping
  ctx.strokeStyle = "#581c87";
  ctx.lineWidth = 2 * zoom;
  for (let w = 0; w < 5; w++) {
    const wrapY = y + size * 0.1 + w * size * 0.06;
    ctx.beginPath();
    ctx.moveTo(x + size * 0.34 - w * 0.02, wrapY);
    ctx.lineTo(x + size * 0.38 - w * 0.02, wrapY + size * 0.03);
    ctx.stroke();
  }

  // Crystal mounting
  ctx.fillStyle = "#1a1a2e";
  ctx.beginPath();
  ctx.moveTo(x + size * 0.18, y - size * 0.08 + sway);
  ctx.lineTo(x + size * 0.26, y - size * 0.08 + sway);
  ctx.lineTo(x + size * 0.24, y - size * 0.14 + sway);
  ctx.lineTo(x + size * 0.2, y - size * 0.14 + sway);
  ctx.fill();

  // Hex crystal with glow effect (gradient instead of shadowBlur)
  const crystalGlow = ctx.createRadialGradient(x + size * 0.22, y - size * 0.22 + sway, 0, x + size * 0.22, y - size * 0.22 + sway, size * 0.12);
  crystalGlow.addColorStop(0, `rgba(236, 72, 153, ${hexPulse * 0.6})`);
  crystalGlow.addColorStop(0.5, `rgba(190, 24, 93, ${hexPulse * 0.3})`);
  crystalGlow.addColorStop(1, "rgba(190, 24, 93, 0)");
  ctx.fillStyle = crystalGlow;
  ctx.beginPath();
  ctx.arc(x + size * 0.22, y - size * 0.22 + sway, size * 0.12, 0, Math.PI * 2);
  ctx.fill();

  // Crystal body
  const crystalGrad = ctx.createLinearGradient(x + size * 0.18, y - size * 0.32 + sway, x + size * 0.26, y - size * 0.14 + sway);
  crystalGrad.addColorStop(0, "#f472b6");
  crystalGrad.addColorStop(0.3, "#be185d");
  crystalGrad.addColorStop(0.7, "#9d174d");
  crystalGrad.addColorStop(1, "#831843");
  ctx.fillStyle = crystalGrad;
  ctx.beginPath();
  ctx.moveTo(x + size * 0.22, y - size * 0.32 + sway);
  ctx.lineTo(x + size * 0.16, y - size * 0.2 + sway);
  ctx.lineTo(x + size * 0.19, y - size * 0.14 + sway);
  ctx.lineTo(x + size * 0.25, y - size * 0.14 + sway);
  ctx.lineTo(x + size * 0.28, y - size * 0.2 + sway);
  ctx.closePath();
  ctx.fill();

  // Crystal inner glow
  ctx.fillStyle = `rgba(251, 113, 133, ${hexPulse})`;
  ctx.beginPath();
  ctx.arc(x + size * 0.22, y - size * 0.21 + sway, size * 0.03, 0, Math.PI * 2);
  ctx.fill();

  // Crystal energy beam (when attacking)
  if (isAttacking) {
    ctx.strokeStyle = `rgba(236, 72, 153, ${attackIntensity * 0.8})`;
    ctx.lineWidth = 3 * zoom;
    ctx.beginPath();
    ctx.moveTo(x + size * 0.22, y - size * 0.32 + sway);
    ctx.lineTo(x + size * 0.22, y - size * 0.6 + sway);
    ctx.stroke();
    // Energy particles at beam tip
    for (let ep = 0; ep < 3; ep++) {
      const epAngle = time * 8 + ep * Math.PI * 0.67;
      ctx.fillStyle = `rgba(251, 113, 133, ${attackIntensity * 0.6})`;
      ctx.beginPath();
      ctx.arc(
        x + size * 0.22 + Math.cos(epAngle) * size * 0.04,
        y - size * 0.6 + sway + Math.sin(epAngle) * size * 0.04,
        size * 0.015,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }
  }

  // === LAYER 10: HAND HOLDING STAFF ===
  ctx.fillStyle = "#fdf4ff";
  ctx.beginPath();
  ctx.ellipse(x + size * 0.2, y - size * 0.08 + sway, size * 0.045, size * 0.03, -0.3, 0, Math.PI * 2);
  ctx.fill();
  // Fingers
  for (let f = 0; f < 4; f++) {
    ctx.beginPath();
    ctx.ellipse(
      x + size * 0.2 + f * size * 0.015 - size * 0.02,
      y - size * 0.06 + sway,
      size * 0.012,
      size * 0.025,
      0.2,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }
}

function drawHarpyEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // HARPY - Storm Fury, Aerial Predator of the Tempest
  // A terrifying avian huntress with iridescent plumage and deadly talons
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase;
  const wingFlap = Math.sin(time * 10) * 0.5 + (isAttacking ? attackIntensity * 0.4 : 0);
  const swoop = Math.sin(time * 3) * 4 * zoom;
  const breathe = Math.sin(time * 4) * size * 0.01;
  const featherRuffle = Math.sin(time * 6) * 0.1;
  const windIntensity = 0.3 + Math.sin(time * 2) * 0.15;

  // === LAYER 1: WIND CURRENTS / AERIAL AURA ===
  // Swirling wind trails
  ctx.strokeStyle = `rgba(167, 139, 250, ${windIntensity * 0.3})`;
  ctx.lineWidth = 2 * zoom;
  for (let w = 0; w < 4; w++) {
    const windPhase = (time * 1.5 + w * 0.5) % 2;
    const windY = y + size * 0.3 - windPhase * size * 0.6;
    const windAlpha = windPhase < 1 ? windPhase : 2 - windPhase;
    ctx.strokeStyle = `rgba(167, 139, 250, ${windAlpha * 0.25})`;
    ctx.beginPath();
    ctx.moveTo(x - size * 0.6 + Math.sin(time * 3 + w) * size * 0.2, windY);
    ctx.quadraticCurveTo(
      x + Math.cos(time * 2 + w) * size * 0.3,
      windY - size * 0.1,
      x + size * 0.6 + Math.sin(time * 3 + w + 1) * size * 0.2,
      windY + size * 0.05
    );
    ctx.stroke();
  }

  // Feather particles floating in air
  for (let f = 0; f < 6; f++) {
    const featherPhase = (time * 0.4 + f * 0.3) % 1;
    const featherX = x + Math.sin(time * 2 + f * 1.5) * size * 0.7;
    const featherY = y + size * 0.5 - featherPhase * size * 1.2;
    const featherAlpha = (1 - Math.abs(featherPhase - 0.5) * 2) * 0.4;
    const featherRot = time * 3 + f;
    
    ctx.save();
    ctx.translate(featherX, featherY);
    ctx.rotate(featherRot);
    ctx.fillStyle = `rgba(139, 92, 246, ${featherAlpha})`;
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 0.015, size * 0.04, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // === LAYER 2: WING SHADOW ON GROUND ===
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.65, 0, x, y + size * 0.65, size * 0.6);
  shadowGrad.addColorStop(0, "rgba(76, 29, 149, 0.35)");
  shadowGrad.addColorStop(0.5, "rgba(0, 0, 0, 0.2)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.65, size * (0.5 + Math.abs(wingFlap) * 0.2), size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  // === LAYER 3: MAGNIFICENT LEFT WING ===
  ctx.save();
  ctx.translate(x - size * 0.18, y - size * 0.08 + swoop);
  ctx.rotate(-0.35 - wingFlap);

  // Wing base gradient
  const leftWingGrad = ctx.createLinearGradient(0, 0, -size * 0.9, -size * 0.2);
  leftWingGrad.addColorStop(0, "#8b5cf6");
  leftWingGrad.addColorStop(0.3, "#7c3aed");
  leftWingGrad.addColorStop(0.6, "#6d28d9");
  leftWingGrad.addColorStop(1, "#4c1d95");
  ctx.fillStyle = leftWingGrad;

  // Detailed wing shape with multiple feather sections
  ctx.beginPath();
  ctx.moveTo(0, 0);
  // Primary flight feathers
  ctx.lineTo(-size * 0.15, -size * 0.25);
  ctx.lineTo(-size * 0.35, -size * 0.42);
  ctx.lineTo(-size * 0.55, -size * 0.48);
  ctx.lineTo(-size * 0.75, -size * 0.45);
  ctx.lineTo(-size * 0.9, -size * 0.35);
  // Wing tip feathers (jagged)
  ctx.lineTo(-size * 0.95, -size * 0.25);
  ctx.lineTo(-size * 0.88, -size * 0.18);
  ctx.lineTo(-size * 0.92, -size * 0.1);
  ctx.lineTo(-size * 0.82, -size * 0.05);
  ctx.lineTo(-size * 0.85, size * 0.05);
  ctx.lineTo(-size * 0.72, size * 0.02);
  // Secondary feathers
  ctx.lineTo(-size * 0.65, size * 0.12);
  ctx.lineTo(-size * 0.5, size * 0.08);
  ctx.lineTo(-size * 0.45, size * 0.18);
  ctx.lineTo(-size * 0.3, size * 0.12);
  ctx.lineTo(-size * 0.25, size * 0.2);
  ctx.lineTo(-size * 0.1, size * 0.15);
  ctx.quadraticCurveTo(0, size * 0.12, 0, size * 0.08);
  ctx.closePath();
  ctx.fill();

  // Wing bone structure
  ctx.strokeStyle = "#5b21b6";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-size * 0.35, -size * 0.18);
  ctx.lineTo(-size * 0.6, -size * 0.25);
  ctx.stroke();

  // Wing finger bones
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(-size * 0.35, -size * 0.18);
  ctx.lineTo(-size * 0.35, -size * 0.42);
  ctx.moveTo(-size * 0.6, -size * 0.25);
  ctx.lineTo(-size * 0.75, -size * 0.45);
  ctx.moveTo(-size * 0.6, -size * 0.25);
  ctx.lineTo(-size * 0.9, -size * 0.32);
  ctx.stroke();

  // Feather detail lines
  ctx.strokeStyle = "rgba(124, 58, 237, 0.5)";
  ctx.lineWidth = 1 * zoom;
  for (let i = 0; i < 8; i++) {
    ctx.beginPath();
    ctx.moveTo(-size * 0.15 - i * size * 0.09, size * 0.02 - i * size * 0.02);
    ctx.lineTo(-size * 0.2 - i * size * 0.1, -size * 0.15 - i * size * 0.025);
    ctx.stroke();
  }

  // Iridescent highlights on feathers
  ctx.fillStyle = `rgba(196, 181, 253, ${0.3 + featherRuffle * 0.2})`;
  ctx.beginPath();
  ctx.ellipse(-size * 0.5, -size * 0.2, size * 0.08, size * 0.15, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(-size * 0.75, -size * 0.25, size * 0.06, size * 0.12, -0.2, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();

  // === LAYER 4: MAGNIFICENT RIGHT WING ===
  ctx.save();
  ctx.translate(x + size * 0.18, y - size * 0.08 + swoop);
  ctx.rotate(0.35 + wingFlap);

  // Wing gradient (mirrored)
  const rightWingGrad = ctx.createLinearGradient(0, 0, size * 0.9, -size * 0.2);
  rightWingGrad.addColorStop(0, "#8b5cf6");
  rightWingGrad.addColorStop(0.3, "#7c3aed");
  rightWingGrad.addColorStop(0.6, "#6d28d9");
  rightWingGrad.addColorStop(1, "#4c1d95");
  ctx.fillStyle = rightWingGrad;

  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(size * 0.15, -size * 0.25);
  ctx.lineTo(size * 0.35, -size * 0.42);
  ctx.lineTo(size * 0.55, -size * 0.48);
  ctx.lineTo(size * 0.75, -size * 0.45);
  ctx.lineTo(size * 0.9, -size * 0.35);
  ctx.lineTo(size * 0.95, -size * 0.25);
  ctx.lineTo(size * 0.88, -size * 0.18);
  ctx.lineTo(size * 0.92, -size * 0.1);
  ctx.lineTo(size * 0.82, -size * 0.05);
  ctx.lineTo(size * 0.85, size * 0.05);
  ctx.lineTo(size * 0.72, size * 0.02);
  ctx.lineTo(size * 0.65, size * 0.12);
  ctx.lineTo(size * 0.5, size * 0.08);
  ctx.lineTo(size * 0.45, size * 0.18);
  ctx.lineTo(size * 0.3, size * 0.12);
  ctx.lineTo(size * 0.25, size * 0.2);
  ctx.lineTo(size * 0.1, size * 0.15);
  ctx.quadraticCurveTo(0, size * 0.12, 0, size * 0.08);
  ctx.closePath();
  ctx.fill();

  // Wing bones
  ctx.strokeStyle = "#5b21b6";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(size * 0.35, -size * 0.18);
  ctx.lineTo(size * 0.6, -size * 0.25);
  ctx.stroke();

  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(size * 0.35, -size * 0.18);
  ctx.lineTo(size * 0.35, -size * 0.42);
  ctx.moveTo(size * 0.6, -size * 0.25);
  ctx.lineTo(size * 0.75, -size * 0.45);
  ctx.moveTo(size * 0.6, -size * 0.25);
  ctx.lineTo(size * 0.9, -size * 0.32);
  ctx.stroke();

  // Feather details
  ctx.strokeStyle = "rgba(124, 58, 237, 0.5)";
  ctx.lineWidth = 1 * zoom;
  for (let i = 0; i < 8; i++) {
    ctx.beginPath();
    ctx.moveTo(size * 0.15 + i * size * 0.09, size * 0.02 - i * size * 0.02);
    ctx.lineTo(size * 0.2 + i * size * 0.1, -size * 0.15 - i * size * 0.025);
    ctx.stroke();
  }

  // Iridescent highlights
  ctx.fillStyle = `rgba(196, 181, 253, ${0.3 + featherRuffle * 0.2})`;
  ctx.beginPath();
  ctx.ellipse(size * 0.5, -size * 0.2, size * 0.08, size * 0.15, 0.3, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();

  // === LAYER 5: ELEGANT AVIAN BODY ===
  // Body gradient with feather pattern
  const bodyGrad = ctx.createRadialGradient(x, y - size * 0.05 + swoop, 0, x, y + size * 0.1 + swoop, size * 0.35);
  bodyGrad.addColorStop(0, "#a78bfa");
  bodyGrad.addColorStop(0.4, "#8b5cf6");
  bodyGrad.addColorStop(0.7, "#7c3aed");
  bodyGrad.addColorStop(1, "#6d28d9");
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.02 + swoop + breathe, size * 0.22, size * 0.32, 0, 0, Math.PI * 2);
  ctx.fill();

  // Body feather texture
  ctx.strokeStyle = "rgba(91, 33, 182, 0.4)";
  ctx.lineWidth = 1 * zoom;
  for (let row = 0; row < 4; row++) {
    for (let col = 0; col < 3; col++) {
      const fX = x - size * 0.1 + col * size * 0.1;
      const fY = y - size * 0.1 + row * size * 0.1 + swoop;
      ctx.beginPath();
      ctx.arc(fX, fY, size * 0.04, Math.PI * 0.8, Math.PI * 0.2, true);
      ctx.stroke();
    }
  }

  // Feathered chest plumage (layered)
  const chestGrad = ctx.createRadialGradient(x, y - size * 0.08 + swoop, 0, x, y + size * 0.05 + swoop, size * 0.18);
  chestGrad.addColorStop(0, "#f5f3ff");
  chestGrad.addColorStop(0.5, "#ede9fe");
  chestGrad.addColorStop(1, "#ddd6fe");
  ctx.fillStyle = chestGrad;
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.02 + swoop, size * 0.14, size * 0.18, 0, 0, Math.PI * 2);
  ctx.fill();

  // Chest feather details
  ctx.strokeStyle = "rgba(139, 92, 246, 0.25)";
  ctx.lineWidth = 1 * zoom;
  for (let cf = 0; cf < 5; cf++) {
    ctx.beginPath();
    ctx.arc(x, y - size * 0.12 + cf * size * 0.05 + swoop, size * 0.08, Math.PI * 0.7, Math.PI * 0.3, true);
    ctx.stroke();
  }

  // === LAYER 6: FIERCE HEAD AND FACE ===
  // Neck feathers
  ctx.fillStyle = "#8b5cf6";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.22 + swoop, size * 0.12, size * 0.1, 0, 0, Math.PI * 2);
  ctx.fill();

  // Head base
  const headGrad = ctx.createRadialGradient(x, y - size * 0.36 + swoop, 0, x, y - size * 0.32 + swoop, size * 0.16);
  headGrad.addColorStop(0, "#fef3c7");
  headGrad.addColorStop(0.6, "#fde68a");
  headGrad.addColorStop(1, "#fcd34d");
  ctx.fillStyle = headGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.34 + swoop, size * 0.15, 0, Math.PI * 2);
  ctx.fill();

  // Face markings (fierce pattern)
  ctx.strokeStyle = "#92400e";
  ctx.lineWidth = 1.5 * zoom;
  // Eye stripes
  ctx.beginPath();
  ctx.moveTo(x - size * 0.12, y - size * 0.38 + swoop);
  ctx.lineTo(x - size * 0.06, y - size * 0.36 + swoop);
  ctx.moveTo(x + size * 0.12, y - size * 0.38 + swoop);
  ctx.lineTo(x + size * 0.06, y - size * 0.36 + swoop);
  ctx.stroke();

  // Crown feathers (elaborate crest)
  const crownColors = ["#7c3aed", "#8b5cf6", "#a78bfa", "#7c3aed", "#6d28d9"];
  for (let c = 0; c < 5; c++) {
    const crownAngle = -Math.PI * 0.7 + c * Math.PI * 0.1;
    const crownLen = size * (0.2 + (c === 2 ? 0.1 : 0)) + Math.sin(time * 5 + c) * size * 0.02;
    ctx.fillStyle = crownColors[c];
    ctx.beginPath();
    ctx.moveTo(x + Math.cos(crownAngle) * size * 0.1, y - size * 0.44 + swoop + Math.sin(crownAngle) * size * 0.05);
    ctx.quadraticCurveTo(
      x + Math.cos(crownAngle - 0.2) * crownLen * 0.6,
      y - size * 0.5 + swoop + Math.sin(crownAngle) * crownLen * 0.3,
      x + Math.cos(crownAngle) * crownLen,
      y - size * 0.44 - crownLen * 0.8 + swoop
    );
    ctx.quadraticCurveTo(
      x + Math.cos(crownAngle + 0.2) * crownLen * 0.6,
      y - size * 0.5 + swoop + Math.sin(crownAngle) * crownLen * 0.3,
      x + Math.cos(crownAngle + 0.15) * size * 0.1,
      y - size * 0.44 + swoop + Math.sin(crownAngle + 0.15) * size * 0.05
    );
    ctx.fill();
  }

  // Fierce eyes (predator gaze)
  // Eye glow (gradient instead of shadow)
  const eyeGlowL = ctx.createRadialGradient(x - size * 0.06, y - size * 0.36 + swoop, 0, x - size * 0.06, y - size * 0.36 + swoop, size * 0.06);
  eyeGlowL.addColorStop(0, "#fbbf24");
  eyeGlowL.addColorStop(0.5, "rgba(251, 191, 36, 0.4)");
  eyeGlowL.addColorStop(1, "rgba(251, 191, 36, 0)");
  ctx.fillStyle = eyeGlowL;
  ctx.beginPath();
  ctx.arc(x - size * 0.06, y - size * 0.36 + swoop, size * 0.06, 0, Math.PI * 2);
  ctx.arc(x + size * 0.06, y - size * 0.36 + swoop, size * 0.06, 0, Math.PI * 2);
  ctx.fill();

  // Eye whites
  ctx.fillStyle = "#fef3c7";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.06, y - size * 0.36 + swoop, size * 0.04, size * 0.03, -0.25, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.06, y - size * 0.36 + swoop, size * 0.04, size * 0.03, 0.25, 0, Math.PI * 2);
  ctx.fill();

  // Iris
  ctx.fillStyle = "#f59e0b";
  ctx.beginPath();
  ctx.arc(x - size * 0.055, y - size * 0.36 + swoop, size * 0.025, 0, Math.PI * 2);
  ctx.arc(x + size * 0.055, y - size * 0.36 + swoop, size * 0.025, 0, Math.PI * 2);
  ctx.fill();

  // Pupils (vertical slit like bird of prey)
  ctx.fillStyle = "#1a1a2e";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.055, y - size * 0.36 + swoop, size * 0.008, size * 0.018, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.055, y - size * 0.36 + swoop, size * 0.008, size * 0.018, 0, 0, Math.PI * 2);
  ctx.fill();

  // Eye highlights
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(x - size * 0.065, y - size * 0.37 + swoop, size * 0.008, 0, Math.PI * 2);
  ctx.arc(x + size * 0.045, y - size * 0.37 + swoop, size * 0.008, 0, Math.PI * 2);
  ctx.fill();

  // Sharp beak (detailed)
  // Upper beak
  const beakGrad = ctx.createLinearGradient(x, y - size * 0.3 + swoop, x, y - size * 0.2 + swoop);
  beakGrad.addColorStop(0, "#d97706");
  beakGrad.addColorStop(0.5, "#f59e0b");
  beakGrad.addColorStop(1, "#fbbf24");
  ctx.fillStyle = beakGrad;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.3 + swoop);
  ctx.quadraticCurveTo(x - size * 0.06, y - size * 0.26 + swoop, x - size * 0.04, y - size * 0.22 + swoop);
  ctx.lineTo(x, y - size * 0.25 + swoop);
  ctx.lineTo(x + size * 0.04, y - size * 0.22 + swoop);
  ctx.quadraticCurveTo(x + size * 0.06, y - size * 0.26 + swoop, x, y - size * 0.3 + swoop);
  ctx.fill();
  // Beak hook
  ctx.fillStyle = "#92400e";
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.25 + swoop);
  ctx.lineTo(x - size * 0.015, y - size * 0.21 + swoop);
  ctx.lineTo(x + size * 0.015, y - size * 0.21 + swoop);
  ctx.fill();
  // Nostril
  ctx.fillStyle = "#78350f";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.27 + swoop, size * 0.008, size * 0.004, 0, 0, Math.PI * 2);
  ctx.fill();

  // === LAYER 7: POWERFUL TALONED LEGS ===
  ctx.strokeStyle = "#78350f";
  ctx.lineWidth = 3 * zoom;
  
  // Left leg with segments
  const leftLegX = x - size * 0.1;
  const legSwing = Math.sin(time * 8) * size * 0.02;
  ctx.beginPath();
  ctx.moveTo(leftLegX, y + size * 0.28 + swoop);
  ctx.lineTo(leftLegX - size * 0.02, y + size * 0.38 + swoop + legSwing);
  ctx.lineTo(leftLegX, y + size * 0.48 + swoop);
  ctx.stroke();
  
  // Right leg
  const rightLegX = x + size * 0.1;
  ctx.beginPath();
  ctx.moveTo(rightLegX, y + size * 0.28 + swoop);
  ctx.lineTo(rightLegX + size * 0.02, y + size * 0.38 + swoop - legSwing);
  ctx.lineTo(rightLegX, y + size * 0.48 + swoop);
  ctx.stroke();

  // Leg scales
  ctx.fillStyle = "#d97706";
  for (let leg = 0; leg < 2; leg++) {
    const lx = leg === 0 ? leftLegX : rightLegX;
    for (let s = 0; s < 3; s++) {
      ctx.beginPath();
      ctx.arc(lx, y + size * 0.32 + s * size * 0.06 + swoop, size * 0.015, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Deadly talons (detailed)
  for (let leg = 0; leg < 2; leg++) {
    const talonX = leg === 0 ? leftLegX : rightLegX;
    const talonBase = y + size * 0.48 + swoop;
    
    // Foot pad
    ctx.fillStyle = "#f59e0b";
    ctx.beginPath();
    ctx.ellipse(talonX, talonBase, size * 0.04, size * 0.02, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Individual talons
    for (let claw = 0; claw < 4; claw++) {
      const clawAngle = -0.4 + claw * 0.27;
      const clawLen = claw === 1 || claw === 2 ? size * 0.1 : size * 0.08;
      
      // Claw bone
      ctx.fillStyle = "#78350f";
      ctx.beginPath();
      ctx.moveTo(talonX + Math.cos(clawAngle + Math.PI * 0.5) * size * 0.03, talonBase);
      ctx.lineTo(
        talonX + Math.cos(clawAngle + Math.PI * 0.5) * size * 0.03 + Math.cos(clawAngle) * clawLen * 0.5,
        talonBase + Math.sin(Math.PI * 0.5 + clawAngle * 0.3) * clawLen * 0.6
      );
      // Claw tip (curved hook)
      ctx.quadraticCurveTo(
        talonX + Math.cos(clawAngle + Math.PI * 0.5) * size * 0.03 + Math.cos(clawAngle - 0.2) * clawLen * 0.8,
        talonBase + clawLen * 0.9,
        talonX + Math.cos(clawAngle + Math.PI * 0.5) * size * 0.03 + Math.cos(clawAngle - 0.4) * clawLen,
        talonBase + clawLen * 0.75
      );
      ctx.fill();
      
      // Claw highlight
      ctx.fillStyle = "#1a1a2e";
      ctx.beginPath();
      ctx.moveTo(
        talonX + Math.cos(clawAngle + Math.PI * 0.5) * size * 0.03 + Math.cos(clawAngle - 0.3) * clawLen * 0.85,
        talonBase + clawLen * 0.82
      );
      ctx.lineTo(
        talonX + Math.cos(clawAngle + Math.PI * 0.5) * size * 0.03 + Math.cos(clawAngle - 0.4) * clawLen,
        talonBase + clawLen * 0.75
      );
      ctx.lineTo(
        talonX + Math.cos(clawAngle + Math.PI * 0.5) * size * 0.03 + Math.cos(clawAngle - 0.5) * clawLen * 0.9,
        talonBase + clawLen * 0.7
      );
      ctx.fill();
    }
  }

  // === LAYER 8: ATTACK DIVE EFFECT ===
  if (isAttacking) {
    // Speed lines
    ctx.strokeStyle = `rgba(139, 92, 246, ${attackIntensity * 0.5})`;
    ctx.lineWidth = 2 * zoom;
    for (let sl = 0; sl < 5; sl++) {
      const slX = x - size * 0.3 + sl * size * 0.15;
      ctx.beginPath();
      ctx.moveTo(slX, y - size * 0.5 + swoop);
      ctx.lineTo(slX + size * 0.05, y + size * 0.3 + swoop);
      ctx.stroke();
    }
    
    // Talon strike trail
    ctx.fillStyle = `rgba(251, 191, 36, ${attackIntensity * 0.4})`;
    ctx.beginPath();
    ctx.moveTo(x - size * 0.15, y + size * 0.6 + swoop);
    ctx.lineTo(x, y + size * 0.8 + swoop);
    ctx.lineTo(x + size * 0.15, y + size * 0.6 + swoop);
    ctx.fill();
  }
}

function drawWyvernEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // WYVERN - Ancient Draconic Terror with Venomous Breath
  // A colossal flying predator wreathed in toxic miasma
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  
  // Core animation variables
  const wingFlap = Math.sin(time * 5) * 0.4 + (isAttacking ? Math.sin(attackPhase * Math.PI * 3) * 0.2 : 0);
  const breathe = Math.sin(time * 2) * size * 0.03;
  const tailSwing = Math.sin(time * 2.5) * 0.25 + (isAttacking ? attackIntensity * 0.3 : 0);
  const neckSway = Math.sin(time * 1.8) * size * 0.02;
  const hoverBob = Math.sin(time * 3) * size * 0.015;
  
  // Attack animation specifics
  const lungeLean = isAttacking ? attackIntensity * size * 0.1 : 0;
  const jawOpen = isAttacking ? attackIntensity * 0.4 : 0.1 + Math.sin(time * 4) * 0.05;
  const venomIntensity = isAttacking ? 0.6 + attackIntensity * 0.4 : 0.3 + Math.sin(time * 3) * 0.15;

  // === LAYER 1: TOXIC MIASMA AURA ===
  // Outer poison cloud
  for (let ring = 0; ring < 4; ring++) {
    const ringPhase = (time * 0.4 + ring * 0.4) % 1;
    const ringSize = size * (0.7 + ring * 0.2) * (1 + venomIntensity * 0.2);
    const ringAlpha = (0.12 - ring * 0.025) * (0.8 + venomIntensity * 0.4);
    ctx.fillStyle = `rgba(74, 222, 128, ${ringAlpha})`;
    ctx.beginPath();
    for (let a = 0; a < Math.PI * 2; a += 0.08) {
      const wobble = Math.sin(a * 4 + time * 2 + ring) * size * 0.04;
      const rx = x + Math.cos(a) * (ringSize + wobble);
      const ry = y + Math.sin(a) * (ringSize * 0.5 + wobble * 0.4) + hoverBob;
      if (a === 0) ctx.moveTo(rx, ry);
      else ctx.lineTo(rx, ry);
    }
    ctx.closePath();
    ctx.fill();
  }

  // Inner power aura
  const auraGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.85);
  auraGrad.addColorStop(0, `rgba(16, 185, 129, ${0.25 + venomIntensity * 0.15})`);
  auraGrad.addColorStop(0.4, `rgba(5, 150, 105, ${0.15 + venomIntensity * 0.1})`);
  auraGrad.addColorStop(0.7, `rgba(4, 120, 87, ${0.08})`);
  auraGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + hoverBob, size * 0.85, size * 0.55, 0, 0, Math.PI * 2);
  ctx.fill();

  // === LAYER 2: MASSIVE SEGMENTED TAIL ===
  ctx.save();
  ctx.translate(x + size * 0.28, y + size * 0.15 + breathe + hoverBob);
  ctx.rotate(tailSwing);
  
  // Tail segments for more detail
  const tailSegments = 6;
  for (let seg = 0; seg < tailSegments; seg++) {
    const segX = seg * size * 0.12;
    const segY = Math.sin(time * 3 + seg * 0.5) * size * 0.02;
    const segSize = size * (0.12 - seg * 0.012);
    const segGrad = ctx.createRadialGradient(segX, segY, 0, segX, segY, segSize);
    segGrad.addColorStop(0, "#10b981");
    segGrad.addColorStop(0.6, "#059669");
    segGrad.addColorStop(1, "#047857");
    ctx.fillStyle = segGrad;
    ctx.beginPath();
    ctx.ellipse(segX, segY, segSize, segSize * 0.7, seg * 0.08, 0, Math.PI * 2);
    ctx.fill();
    
    // Segment ridge scales
    if (seg < tailSegments - 1) {
      ctx.fillStyle = "#065f46";
      ctx.beginPath();
      ctx.moveTo(segX, segY - segSize * 0.6);
      ctx.lineTo(segX + size * 0.03, segY - segSize * 0.9);
      ctx.lineTo(segX + size * 0.06, segY - segSize * 0.6);
      ctx.fill();
    }
  }
  
  // Deadly tail spike cluster
  const spikeBase = (tailSegments - 1) * size * 0.12;
  ctx.fillStyle = "#0f172a";
  // Main spike
  ctx.beginPath();
  ctx.moveTo(spikeBase, 0);
  ctx.lineTo(spikeBase + size * 0.25, -size * 0.05);
  ctx.lineTo(spikeBase + size * 0.22, size * 0.02);
  ctx.fill();
  // Side spikes
  ctx.beginPath();
  ctx.moveTo(spikeBase + size * 0.08, -size * 0.03);
  ctx.lineTo(spikeBase + size * 0.18, -size * 0.12);
  ctx.lineTo(spikeBase + size * 0.15, -size * 0.02);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(spikeBase + size * 0.08, size * 0.02);
  ctx.lineTo(spikeBase + size * 0.18, size * 0.1);
  ctx.lineTo(spikeBase + size * 0.15, size * 0.02);
  ctx.fill();
  // Venom drip from spike
  const dripPhase = (time * 2) % 1;
  ctx.fillStyle = `rgba(74, 222, 128, ${0.7 - dripPhase * 0.5})`;
  ctx.beginPath();
  ctx.arc(spikeBase + size * 0.24, -size * 0.05 + dripPhase * size * 0.08, size * 0.015 * (1 - dripPhase * 0.6), 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // === LAYER 3: MAGNIFICENT WINGS ===
  // Left wing (detailed with membrane and bones)
  ctx.save();
  ctx.translate(x - size * 0.22, y - size * 0.12 + breathe + hoverBob);
  ctx.rotate(-0.45 - wingFlap);
  
  // Wing membrane gradient
  const leftWingGrad = ctx.createLinearGradient(0, 0, -size * 0.95, -size * 0.2);
  leftWingGrad.addColorStop(0, "#10b981");
  leftWingGrad.addColorStop(0.3, "#059669");
  leftWingGrad.addColorStop(0.6, "#047857");
  leftWingGrad.addColorStop(1, "#065f46");
  ctx.fillStyle = leftWingGrad;
  
  // Main wing membrane with detailed shape
  ctx.beginPath();
  ctx.moveTo(0, 0);
  // Wing finger 1
  ctx.lineTo(-size * 0.15, -size * 0.35);
  ctx.lineTo(-size * 0.35, -size * 0.48);
  // Wing finger 2
  ctx.lineTo(-size * 0.55, -size * 0.45);
  ctx.lineTo(-size * 0.78, -size * 0.38);
  // Wing finger 3
  ctx.lineTo(-size * 0.92, -size * 0.25);
  ctx.lineTo(-size * 0.98, -size * 0.08);
  // Lower edge with membrane scallops
  ctx.lineTo(-size * 0.88, size * 0.02);
  ctx.lineTo(-size * 0.75, size * 0.08);
  ctx.lineTo(-size * 0.6, size * 0.05);
  ctx.lineTo(-size * 0.68, size * 0.18);
  ctx.lineTo(-size * 0.5, size * 0.15);
  ctx.lineTo(-size * 0.35, size * 0.12);
  ctx.lineTo(-size * 0.42, size * 0.22);
  ctx.lineTo(-size * 0.25, size * 0.18);
  ctx.quadraticCurveTo(-size * 0.1, size * 0.2, 0, size * 0.15);
  ctx.closePath();
  ctx.fill();
  
  // Wing bone structure
  ctx.strokeStyle = "#047857";
  ctx.lineWidth = 3 * zoom;
  // Main arm bone
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-size * 0.35, -size * 0.15);
  ctx.stroke();
  // Finger bones
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(-size * 0.35, -size * 0.15);
  ctx.lineTo(-size * 0.35, -size * 0.48);
  ctx.moveTo(-size * 0.35, -size * 0.15);
  ctx.lineTo(-size * 0.78, -size * 0.38);
  ctx.moveTo(-size * 0.35, -size * 0.15);
  ctx.lineTo(-size * 0.95, -size * 0.15);
  ctx.stroke();
  
  // Vein details on membrane
  ctx.strokeStyle = "rgba(6, 95, 70, 0.4)";
  ctx.lineWidth = 1 * zoom;
  for (let v = 0; v < 5; v++) {
    ctx.beginPath();
    ctx.moveTo(-size * 0.35 - v * size * 0.1, -size * 0.15);
    ctx.quadraticCurveTo(
      -size * 0.4 - v * size * 0.12,
      size * 0.05 + Math.sin(v) * size * 0.03,
      -size * 0.3 - v * size * 0.08,
      size * 0.12
    );
    ctx.stroke();
  }
  
  // Wing claw
  ctx.fillStyle = "#0f172a";
  ctx.beginPath();
  ctx.moveTo(-size * 0.33, -size * 0.14);
  ctx.lineTo(-size * 0.42, -size * 0.08);
  ctx.lineTo(-size * 0.35, -size * 0.12);
  ctx.fill();
  ctx.restore();

  // Right wing (mirrored)
  ctx.save();
  ctx.translate(x + size * 0.22, y - size * 0.12 + breathe + hoverBob);
  ctx.rotate(0.45 + wingFlap);
  
  const rightWingGrad = ctx.createLinearGradient(0, 0, size * 0.95, -size * 0.2);
  rightWingGrad.addColorStop(0, "#10b981");
  rightWingGrad.addColorStop(0.3, "#059669");
  rightWingGrad.addColorStop(0.6, "#047857");
  rightWingGrad.addColorStop(1, "#065f46");
  ctx.fillStyle = rightWingGrad;
  
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(size * 0.15, -size * 0.35);
  ctx.lineTo(size * 0.35, -size * 0.48);
  ctx.lineTo(size * 0.55, -size * 0.45);
  ctx.lineTo(size * 0.78, -size * 0.38);
  ctx.lineTo(size * 0.92, -size * 0.25);
  ctx.lineTo(size * 0.98, -size * 0.08);
  ctx.lineTo(size * 0.88, size * 0.02);
  ctx.lineTo(size * 0.75, size * 0.08);
  ctx.lineTo(size * 0.6, size * 0.05);
  ctx.lineTo(size * 0.68, size * 0.18);
  ctx.lineTo(size * 0.5, size * 0.15);
  ctx.lineTo(size * 0.35, size * 0.12);
  ctx.lineTo(size * 0.42, size * 0.22);
  ctx.lineTo(size * 0.25, size * 0.18);
  ctx.quadraticCurveTo(size * 0.1, size * 0.2, 0, size * 0.15);
  ctx.closePath();
  ctx.fill();
  
  // Bones and veins mirrored
  ctx.strokeStyle = "#047857";
  ctx.lineWidth = 3 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(size * 0.35, -size * 0.15);
  ctx.stroke();
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(size * 0.35, -size * 0.15);
  ctx.lineTo(size * 0.35, -size * 0.48);
  ctx.moveTo(size * 0.35, -size * 0.15);
  ctx.lineTo(size * 0.78, -size * 0.38);
  ctx.moveTo(size * 0.35, -size * 0.15);
  ctx.lineTo(size * 0.95, -size * 0.15);
  ctx.stroke();
  
  ctx.fillStyle = "#0f172a";
  ctx.beginPath();
  ctx.moveTo(size * 0.33, -size * 0.14);
  ctx.lineTo(size * 0.42, -size * 0.08);
  ctx.lineTo(size * 0.35, -size * 0.12);
  ctx.fill();
  ctx.restore();

  // === LAYER 4: MUSCULAR BODY ===
  const bodyY = y + size * 0.05 + breathe + hoverBob - lungeLean * 0.3;
  
  // Body shadow/depth layer
  ctx.fillStyle = "rgba(4, 120, 87, 0.6)";
  ctx.beginPath();
  ctx.ellipse(x + size * 0.02, bodyY + size * 0.03, size * 0.34, size * 0.38, 0.05, 0, Math.PI * 2);
  ctx.fill();
  
  // Main body with muscle definition
  const bodyGrad = ctx.createRadialGradient(x - size * 0.1, bodyY - size * 0.1, 0, x, bodyY, size * 0.42);
  bodyGrad.addColorStop(0, "#34d399");
  bodyGrad.addColorStop(0.3, "#10b981");
  bodyGrad.addColorStop(0.7, "#059669");
  bodyGrad.addColorStop(1, "#047857");
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.ellipse(x, bodyY, size * 0.32, size * 0.36, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Armored belly plates
  const bellyGrad = ctx.createLinearGradient(x, bodyY - size * 0.2, x, bodyY + size * 0.3);
  bellyGrad.addColorStop(0, "#a7f3d0");
  bellyGrad.addColorStop(0.5, "#6ee7b7");
  bellyGrad.addColorStop(1, "#a7f3d0");
  ctx.fillStyle = bellyGrad;
  ctx.beginPath();
  ctx.ellipse(x, bodyY + size * 0.08, size * 0.2, size * 0.26, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Detailed belly scale plates
  ctx.strokeStyle = "#34d399";
  ctx.lineWidth = 1.5 * zoom;
  for (let i = 0; i < 6; i++) {
    const plateY = bodyY - size * 0.08 + i * size * 0.065;
    const plateWidth = size * (0.18 - Math.abs(i - 2.5) * 0.02);
    ctx.beginPath();
    ctx.moveTo(x - plateWidth, plateY);
    ctx.quadraticCurveTo(x, plateY + size * 0.025, x + plateWidth, plateY);
    ctx.stroke();
  }
  
  // Dorsal ridge spikes
  for (let i = 0; i < 5; i++) {
    const spikeX = x - size * 0.1 + i * size * 0.05;
    const spikeY = bodyY - size * 0.32 + Math.abs(i - 2) * size * 0.03;
    const spikeSize = size * (0.06 - Math.abs(i - 2) * 0.01);
    ctx.fillStyle = "#065f46";
    ctx.beginPath();
    ctx.moveTo(spikeX - spikeSize * 0.4, spikeY + spikeSize * 0.3);
    ctx.lineTo(spikeX, spikeY - spikeSize);
    ctx.lineTo(spikeX + spikeSize * 0.4, spikeY + spikeSize * 0.3);
    ctx.fill();
  }

  // === LAYER 5: POWERFUL NECK ===
  const neckGrad = ctx.createLinearGradient(x - size * 0.15, y - size * 0.2, x + size * 0.1, y - size * 0.55);
  neckGrad.addColorStop(0, "#059669");
  neckGrad.addColorStop(0.5, "#10b981");
  neckGrad.addColorStop(1, "#059669");
  ctx.fillStyle = neckGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.12, y - size * 0.18 + breathe + hoverBob);
  ctx.quadraticCurveTo(
    x - size * 0.05 + neckSway,
    y - size * 0.38,
    x + size * 0.03 + lungeLean,
    y - size * 0.52 + breathe + hoverBob
  );
  ctx.lineTo(x + size * 0.14 + lungeLean, y - size * 0.48 + breathe + hoverBob);
  ctx.quadraticCurveTo(
    x + size * 0.12 + neckSway,
    y - size * 0.32,
    x + size * 0.12,
    y - size * 0.18 + breathe + hoverBob
  );
  ctx.fill();
  
  // Neck ridges
  ctx.fillStyle = "#065f46";
  for (let i = 0; i < 4; i++) {
    const ridgeProgress = 0.2 + i * 0.2;
    const ridgeX = x - size * 0.08 + ridgeProgress * size * 0.12 + neckSway * ridgeProgress;
    const ridgeY = y - size * 0.22 - ridgeProgress * size * 0.28 + breathe + hoverBob;
    ctx.beginPath();
    ctx.moveTo(ridgeX - size * 0.02, ridgeY);
    ctx.lineTo(ridgeX, ridgeY - size * 0.04);
    ctx.lineTo(ridgeX + size * 0.02, ridgeY);
    ctx.fill();
  }

  // === LAYER 6: FEARSOME HEAD ===
  const headX = x + size * 0.04 + lungeLean;
  const headY = y - size * 0.56 + breathe + hoverBob;
  
  // Head base
  const headGrad = ctx.createRadialGradient(headX - size * 0.05, headY - size * 0.02, 0, headX, headY, size * 0.18);
  headGrad.addColorStop(0, "#10b981");
  headGrad.addColorStop(0.6, "#059669");
  headGrad.addColorStop(1, "#047857");
  ctx.fillStyle = headGrad;
  ctx.beginPath();
  ctx.ellipse(headX, headY, size * 0.16, size * 0.13, 0.35, 0, Math.PI * 2);
  ctx.fill();
  
  // Brow ridges
  ctx.fillStyle = "#047857";
  ctx.beginPath();
  ctx.ellipse(headX - size * 0.02, headY - size * 0.08, size * 0.14, size * 0.05, 0.2, Math.PI, Math.PI * 2);
  ctx.fill();
  
  // Snout with jaw mechanics
  const snoutX = headX - size * 0.12;
  const snoutY = headY + size * 0.01 + jawOpen * size * 0.03;
  ctx.fillStyle = "#059669";
  // Upper jaw
  ctx.beginPath();
  ctx.ellipse(snoutX, snoutY - size * 0.02, size * 0.12, size * 0.06, 0.25, 0, Math.PI * 2);
  ctx.fill();
  // Lower jaw (opens when attacking)
  ctx.save();
  ctx.translate(snoutX + size * 0.02, snoutY + size * 0.02);
  ctx.rotate(jawOpen * 0.4);
  ctx.fillStyle = "#047857";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.02, size * 0.1, size * 0.04, 0.2, 0, Math.PI * 2);
  ctx.fill();
  // Teeth on lower jaw
  ctx.fillStyle = "#f0fdf4";
  for (let t = 0; t < 5; t++) {
    const toothX = -size * 0.06 + t * size * 0.025;
    ctx.beginPath();
    ctx.moveTo(toothX - size * 0.008, 0);
    ctx.lineTo(toothX, -size * 0.025);
    ctx.lineTo(toothX + size * 0.008, 0);
    ctx.fill();
  }
  ctx.restore();
  
  // Upper teeth
  ctx.fillStyle = "#f0fdf4";
  for (let t = 0; t < 6; t++) {
    const toothX = snoutX - size * 0.08 + t * size * 0.025;
    const toothY = snoutY + size * 0.02;
    ctx.beginPath();
    ctx.moveTo(toothX - size * 0.008, toothY);
    ctx.lineTo(toothX, toothY + size * 0.03);
    ctx.lineTo(toothX + size * 0.008, toothY);
    ctx.fill();
  }
  
  // Nostrils with smoke
  ctx.fillStyle = "#065f46";
  ctx.beginPath();
  ctx.ellipse(snoutX - size * 0.06, snoutY - size * 0.04, size * 0.015, size * 0.01, 0.3, 0, Math.PI * 2);
  ctx.ellipse(snoutX - size * 0.04, snoutY - size * 0.05, size * 0.015, size * 0.01, 0.3, 0, Math.PI * 2);
  ctx.fill();
  
  // Nostril smoke
  for (let s = 0; s < 3; s++) {
    const smokePhase = (time * 0.8 + s * 0.4) % 1.5;
    const smokeX = snoutX - size * 0.05 + Math.sin(time * 2 + s) * size * 0.02;
    const smokeY = snoutY - size * 0.05 - smokePhase * size * 0.1;
    const smokeAlpha = (0.4 - smokePhase * 0.25) * venomIntensity;
    ctx.fillStyle = `rgba(74, 222, 128, ${smokeAlpha})`;
    ctx.beginPath();
    ctx.arc(smokeX, smokeY, size * (0.02 + smokePhase * 0.02), 0, Math.PI * 2);
    ctx.fill();
  }

  // === LAYER 7: GLOWING PREDATOR EYES ===
  // Eye sockets
  ctx.fillStyle = "#065f46";
  ctx.beginPath();
  ctx.ellipse(headX - size * 0.01, headY - size * 0.03, size * 0.05, size * 0.04, -0.2, 0, Math.PI * 2);
  ctx.ellipse(headX + size * 0.09, headY - size * 0.01, size * 0.045, size * 0.035, 0.1, 0, Math.PI * 2);
  ctx.fill();
  
  // Eye glow (intensifies when attacking)
  const eyeGlow = isAttacking ? 0.9 + attackIntensity * 0.1 : 0.7 + Math.sin(time * 2) * 0.2;
  ctx.fillStyle = `rgba(251, 191, 36, ${eyeGlow})`;
  ctx.beginPath();
  ctx.ellipse(headX - size * 0.01, headY - size * 0.03, size * 0.04, size * 0.03, -0.2, 0, Math.PI * 2);
  ctx.ellipse(headX + size * 0.09, headY - size * 0.01, size * 0.035, size * 0.025, 0.1, 0, Math.PI * 2);
  ctx.fill();
  
  // Slit pupils (narrow when attacking)
  const pupilWidth = isAttacking ? size * 0.008 : size * 0.015;
  ctx.fillStyle = "#0f172a";
  ctx.beginPath();
  ctx.ellipse(headX - size * 0.01, headY - size * 0.03, pupilWidth, size * 0.025, -0.2, 0, Math.PI * 2);
  ctx.ellipse(headX + size * 0.09, headY - size * 0.01, pupilWidth * 0.9, size * 0.02, 0.1, 0, Math.PI * 2);
  ctx.fill();
  
  // Eye shine
  ctx.fillStyle = "#fffbeb";
  ctx.beginPath();
  ctx.arc(headX - size * 0.02, headY - size * 0.045, size * 0.01, 0, Math.PI * 2);
  ctx.arc(headX + size * 0.08, headY - size * 0.025, size * 0.008, 0, Math.PI * 2);
  ctx.fill();

  // === LAYER 8: CROWN OF HORNS ===
  ctx.fillStyle = "#0f172a";
  // Main horns
  ctx.beginPath();
  ctx.moveTo(headX + size * 0.06, headY - size * 0.1);
  ctx.quadraticCurveTo(headX + size * 0.12, headY - size * 0.2, headX + size * 0.16, headY - size * 0.28);
  ctx.lineTo(headX + size * 0.12, headY - size * 0.22);
  ctx.quadraticCurveTo(headX + size * 0.1, headY - size * 0.14, headX + size * 0.08, headY - size * 0.08);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(headX - size * 0.04, headY - size * 0.12);
  ctx.quadraticCurveTo(headX - size * 0.08, headY - size * 0.24, headX - size * 0.06, headY - size * 0.32);
  ctx.lineTo(headX - size * 0.04, headY - size * 0.26);
  ctx.quadraticCurveTo(headX - size * 0.04, headY - size * 0.18, headX - size * 0.02, headY - size * 0.1);
  ctx.fill();
  
  // Horn ridges
  ctx.strokeStyle = "#1e293b";
  ctx.lineWidth = 1 * zoom;
  for (let h = 0; h < 3; h++) {
    ctx.beginPath();
    ctx.arc(headX + size * 0.12, headY - size * 0.18 - h * size * 0.03, size * 0.02, 0, Math.PI);
    ctx.stroke();
  }
  
  // Small decorative horns
  ctx.fillStyle = "#1e293b";
  ctx.beginPath();
  ctx.moveTo(headX + size * 0.13, headY - size * 0.06);
  ctx.lineTo(headX + size * 0.18, headY - size * 0.12);
  ctx.lineTo(headX + size * 0.14, headY - size * 0.08);
  ctx.fill();

  // === LAYER 9: POWERFUL LEGS WITH TALONS ===
  const legY = y + size * 0.28 + breathe + hoverBob;
  
  // Left leg
  ctx.fillStyle = "#059669";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.14, legY - size * 0.05);
  ctx.quadraticCurveTo(x - size * 0.18, legY + size * 0.15, x - size * 0.2, legY + size * 0.3);
  ctx.lineTo(x - size * 0.12, legY + size * 0.3);
  ctx.quadraticCurveTo(x - size * 0.11, legY + size * 0.15, x - size * 0.1, legY - size * 0.02);
  ctx.fill();
  
  // Right leg
  ctx.beginPath();
  ctx.moveTo(x + size * 0.14, legY - size * 0.05);
  ctx.quadraticCurveTo(x + size * 0.18, legY + size * 0.15, x + size * 0.2, legY + size * 0.3);
  ctx.lineTo(x + size * 0.12, legY + size * 0.3);
  ctx.quadraticCurveTo(x + size * 0.11, legY + size * 0.15, x + size * 0.1, legY - size * 0.02);
  ctx.fill();
  
  // Detailed talons
  ctx.fillStyle = "#0f172a";
  for (let leg = 0; leg < 2; leg++) {
    const legX = leg === 0 ? x - size * 0.16 : x + size * 0.16;
    const talonY = legY + size * 0.3;
    // Three front talons
    for (let claw = 0; claw < 3; claw++) {
      const clawX = legX + (claw - 1) * size * 0.04;
      ctx.beginPath();
      ctx.moveTo(clawX - size * 0.015, talonY);
      ctx.quadraticCurveTo(clawX, talonY + size * 0.02, clawX, talonY + size * 0.08);
      ctx.quadraticCurveTo(clawX + size * 0.005, talonY + size * 0.02, clawX + size * 0.015, talonY);
      ctx.fill();
    }
    // Back talon
    ctx.beginPath();
    ctx.moveTo(legX + (leg === 0 ? size * 0.03 : -size * 0.03), talonY);
    ctx.lineTo(legX + (leg === 0 ? size * 0.08 : -size * 0.08), talonY + size * 0.04);
    ctx.lineTo(legX + (leg === 0 ? size * 0.05 : -size * 0.05), talonY);
    ctx.fill();
  }

  // === LAYER 10: VENOM BREATH ATTACK ===
  if (isAttacking || venomIntensity > 0.4) {
    const breathX = snoutX - size * 0.15 - lungeLean;
    const breathY = snoutY + jawOpen * size * 0.05;
    
    // Main venom stream
    const streamLength = size * (0.3 + (isAttacking ? attackIntensity * 0.5 : 0));
    const streamGrad = ctx.createLinearGradient(breathX, breathY, breathX - streamLength, breathY);
    streamGrad.addColorStop(0, `rgba(74, 222, 128, ${venomIntensity * 0.9})`);
    streamGrad.addColorStop(0.3, `rgba(52, 211, 153, ${venomIntensity * 0.7})`);
    streamGrad.addColorStop(0.7, `rgba(16, 185, 129, ${venomIntensity * 0.4})`);
    streamGrad.addColorStop(1, "rgba(16, 185, 129, 0)");
    ctx.fillStyle = streamGrad;
    
    ctx.beginPath();
    ctx.moveTo(breathX, breathY - size * 0.03);
    ctx.quadraticCurveTo(
      breathX - streamLength * 0.5, 
      breathY - size * 0.05 + Math.sin(time * 8) * size * 0.02,
      breathX - streamLength, 
      breathY + Math.sin(time * 6) * size * 0.04
    );
    ctx.quadraticCurveTo(
      breathX - streamLength * 0.5,
      breathY + size * 0.05 + Math.sin(time * 8 + 1) * size * 0.02,
      breathX,
      breathY + size * 0.03
    );
    ctx.closePath();
    ctx.fill();
    
    // Venom droplets/particles
    for (let d = 0; d < 8; d++) {
      const dropPhase = (time * 2 + d * 0.3) % 1;
      const dropX = breathX - dropPhase * streamLength + Math.sin(time * 5 + d) * size * 0.03;
      const dropY = breathY + Math.sin(time * 6 + d * 2) * size * 0.04;
      const dropAlpha = venomIntensity * (1 - dropPhase) * 0.8;
      ctx.fillStyle = `rgba(74, 222, 128, ${dropAlpha})`;
      ctx.beginPath();
      ctx.arc(dropX, dropY, size * 0.015 * (1 - dropPhase * 0.5), 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // === LAYER 11: ATTACK IMPACT EFFECTS ===
  if (isAttacking) {
    // Energy surge from body
    ctx.strokeStyle = `rgba(52, 211, 153, ${attackIntensity * 0.5})`;
    ctx.lineWidth = 2 * zoom;
    for (let i = 0; i < 4; i++) {
      const surgeAngle = time * 4 + i * Math.PI * 0.5;
      const surgeX = x + Math.cos(surgeAngle) * size * 0.4;
      const surgeY = y + Math.sin(surgeAngle) * size * 0.25 + hoverBob;
      ctx.beginPath();
      ctx.arc(surgeX, surgeY, size * 0.05 + attackIntensity * size * 0.03, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    // Claw swipe trails
    ctx.strokeStyle = `rgba(16, 185, 129, ${attackIntensity * 0.6})`;
    ctx.lineWidth = 3 * zoom;
    const swipePhase = attackPhase * Math.PI;
    for (let leg = 0; leg < 2; leg++) {
      const legX = leg === 0 ? x - size * 0.16 : x + size * 0.16;
      ctx.beginPath();
      ctx.arc(legX, legY + size * 0.35, size * 0.15, 
        Math.PI * (leg === 0 ? 0.8 : 0.2) + swipePhase, 
        Math.PI * (leg === 0 ? 1.2 : -0.2) + swipePhase);
      ctx.stroke();
    }
  }
}

function drawSpecterEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // SPECTER - Tormented Soul, Ethereal Horror from Beyond the Veil
  // A terrifying ghostly apparition wreathed in ectoplasmic energy
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase;
  const phase = Math.sin(time * 2) * 5 * zoom + (isAttacking ? attackIntensity * size * 0.2 : 0);
  const flicker = 0.5 + Math.sin(time * 8) * 0.3;
  const waver = Math.sin(time * 4) * 0.1;
  const pulseIntensity = 0.4 + Math.sin(time * 3) * 0.25;
  const distortion = Math.sin(time * 6) * size * 0.02;
  const wailPhase = (time * 2) % 1;

  // === LAYER 1: DIMENSIONAL RIFT / VOID AURA ===
  // Dark void pool beneath
  const voidGrad = ctx.createRadialGradient(x, y + size * 0.5, 0, x, y + size * 0.5, size * 0.6);
  voidGrad.addColorStop(0, `rgba(15, 23, 42, ${pulseIntensity * 0.6})`);
  voidGrad.addColorStop(0.3, `rgba(30, 41, 59, ${pulseIntensity * 0.4})`);
  voidGrad.addColorStop(0.6, `rgba(51, 65, 85, ${pulseIntensity * 0.2})`);
  voidGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = voidGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.5, size * 0.6, size * 0.2, 0, 0, Math.PI * 2);
  ctx.fill();

  // Void tendrils reaching up
  ctx.strokeStyle = `rgba(30, 41, 59, ${pulseIntensity * 0.4})`;
  ctx.lineWidth = 2 * zoom;
  for (let t = 0; t < 5; t++) {
    const tendrilAngle = t * Math.PI / 2.5 - Math.PI / 4;
    const tendrilPhase = (time * 0.5 + t * 0.3) % 1;
    const tendrilHeight = size * 0.3 * tendrilPhase;
    ctx.beginPath();
    ctx.moveTo(x + Math.cos(tendrilAngle) * size * 0.3, y + size * 0.5);
    ctx.quadraticCurveTo(
      x + Math.cos(tendrilAngle) * size * 0.25 + Math.sin(time * 3 + t) * size * 0.1,
      y + size * 0.3 - tendrilHeight * 0.5,
      x + Math.cos(tendrilAngle) * size * 0.15,
      y + size * 0.5 - tendrilHeight
    );
    ctx.stroke();
  }

  // === LAYER 2: ETHEREAL TRAIL (MOTION GHOSTS) ===
  for (let i = 0; i < 6; i++) {
    const trailOffset = i * 8;
    const trailAlpha = (0.2 - i * 0.03) * flicker;
    const trailScale = 1 - i * 0.08;
    
    // Trail body
    const trailGrad = ctx.createRadialGradient(
      x + trailOffset,
      y + i * 4 + phase,
      0,
      x + trailOffset,
      y + i * 4 + phase,
      size * 0.4 * trailScale
    );
    trailGrad.addColorStop(0, `rgba(148, 163, 184, ${trailAlpha})`);
    trailGrad.addColorStop(0.5, `rgba(100, 116, 139, ${trailAlpha * 0.5})`);
    trailGrad.addColorStop(1, "rgba(100, 116, 139, 0)");
    ctx.fillStyle = trailGrad;
    ctx.beginPath();
    ctx.ellipse(
      x + trailOffset,
      y + i * 4 + phase,
      size * 0.3 * trailScale,
      size * 0.4 * trailScale,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  // === LAYER 3: ECTOPLASMIC PARTICLES ===
  for (let p = 0; p < 15; p++) {
    const particlePhase = (time * 0.7 + p * 0.15) % 1;
    const particleAngle = p * Math.PI / 7.5 + time * 0.3;
    const particleDist = size * (0.2 + particlePhase * 0.5);
    const px = x + Math.cos(particleAngle) * particleDist + Math.sin(time * 2 + p) * size * 0.1;
    const py = y - particlePhase * size * 0.6 + phase;
    const particleAlpha = (1 - particlePhase) * 0.5 * pulseIntensity;
    const particleSize = size * 0.025 * (1 - particlePhase * 0.5);
    
    // Particle glow
    const particleGlow = ctx.createRadialGradient(px, py, 0, px, py, particleSize * 3);
    particleGlow.addColorStop(0, `rgba(56, 189, 248, ${particleAlpha * 0.8})`);
    particleGlow.addColorStop(0.5, `rgba(56, 189, 248, ${particleAlpha * 0.3})`);
    particleGlow.addColorStop(1, "rgba(56, 189, 248, 0)");
    ctx.fillStyle = particleGlow;
    ctx.beginPath();
    ctx.arc(px, py, particleSize * 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Particle core
    ctx.fillStyle = `rgba(186, 230, 253, ${particleAlpha})`;
    ctx.beginPath();
    ctx.arc(px, py, particleSize, 0, Math.PI * 2);
    ctx.fill();
  }

  // === LAYER 4: MAIN GHOSTLY FORM (LAYERED FOR DEPTH) ===
  // Outer ethereal shroud
  const outerGrad = ctx.createRadialGradient(x, y - size * 0.05 + phase, 0, x, y + size * 0.1 + phase, size * 0.65);
  outerGrad.addColorStop(0, `rgba(203, 213, 225, ${flicker * 0.7})`);
  outerGrad.addColorStop(0.4, `rgba(148, 163, 184, ${flicker * 0.5})`);
  outerGrad.addColorStop(0.7, `rgba(100, 116, 139, ${flicker * 0.2})`);
  outerGrad.addColorStop(1, "rgba(100, 116, 139, 0)");
  ctx.fillStyle = outerGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.4, y + size * 0.5);
  // Wavy bottom edge with more detail
  for (let i = 0; i < 10; i++) {
    const waveX = x - size * 0.4 + i * size * 0.08;
    const waveY = y + size * 0.5 + Math.sin(time * 5 + i * 0.8) * size * 0.1 + (i % 2) * size * 0.05;
    ctx.lineTo(waveX, waveY);
  }
  ctx.quadraticCurveTo(x + size * 0.45, y + size * 0.1, x + size * 0.3, y - size * 0.35 + phase + distortion);
  ctx.quadraticCurveTo(x + size * 0.15, y - size * 0.55 + phase, x, y - size * 0.5 + phase);
  ctx.quadraticCurveTo(x - size * 0.15, y - size * 0.55 + phase, x - size * 0.3, y - size * 0.35 + phase - distortion);
  ctx.quadraticCurveTo(x - size * 0.45, y + size * 0.1, x - size * 0.4, y + size * 0.5);
  ctx.fill();

  // Inner spectral form
  const innerGrad = ctx.createRadialGradient(x, y - size * 0.1 + phase, 0, x, y + phase, size * 0.45);
  innerGrad.addColorStop(0, `rgba(241, 245, 249, ${flicker * 0.9})`);
  innerGrad.addColorStop(0.3, `rgba(226, 232, 240, ${flicker * 0.7})`);
  innerGrad.addColorStop(0.6, `rgba(203, 213, 225, ${flicker * 0.4})`);
  innerGrad.addColorStop(1, "rgba(203, 213, 225, 0)");
  ctx.fillStyle = innerGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.28, y + size * 0.35);
  for (let i = 0; i < 7; i++) {
    const waveX = x - size * 0.28 + i * size * 0.09;
    const waveY = y + size * 0.35 + Math.sin(time * 6 + i) * size * 0.06;
    ctx.lineTo(waveX, waveY);
  }
  ctx.quadraticCurveTo(x + size * 0.32, y, x + size * 0.2, y - size * 0.35 + phase);
  ctx.quadraticCurveTo(x, y - size * 0.45 + phase, x - size * 0.2, y - size * 0.35 + phase);
  ctx.quadraticCurveTo(x - size * 0.32, y, x - size * 0.28, y + size * 0.35);
  ctx.fill();

  // === LAYER 5: DARK VOID CORE ===
  const voidCore = ctx.createRadialGradient(x, y - size * 0.05 + phase, 0, x, y - size * 0.05 + phase, size * 0.22);
  voidCore.addColorStop(0, `rgba(15, 23, 42, ${flicker * 0.8})`);
  voidCore.addColorStop(0.5, `rgba(30, 41, 59, ${flicker * 0.5})`);
  voidCore.addColorStop(1, "rgba(30, 41, 59, 0)");
  ctx.fillStyle = voidCore;
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.05 + phase, size * 0.18, size * 0.25, 0, 0, Math.PI * 2);
  ctx.fill();

  // Void energy swirls
  ctx.strokeStyle = `rgba(56, 189, 248, ${pulseIntensity * 0.4})`;
  ctx.lineWidth = 1.5 * zoom;
  for (let swirl = 0; swirl < 3; swirl++) {
    const swirlAngle = time * 2 + swirl * Math.PI * 0.67;
    ctx.beginPath();
    ctx.arc(
      x,
      y - size * 0.05 + phase,
      size * (0.08 + swirl * 0.04),
      swirlAngle,
      swirlAngle + Math.PI * 0.5
    );
    ctx.stroke();
  }

  // === LAYER 6: SKULL-LIKE FACE (DETAILED) ===
  // Face glow aura
  const faceGlow = ctx.createRadialGradient(x, y - size * 0.28 + phase, 0, x, y - size * 0.28 + phase, size * 0.28);
  faceGlow.addColorStop(0, `rgba(248, 250, 252, ${flicker * 0.3})`);
  faceGlow.addColorStop(0.5, `rgba(226, 232, 240, ${flicker * 0.15})`);
  faceGlow.addColorStop(1, "rgba(226, 232, 240, 0)");
  ctx.fillStyle = faceGlow;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.28 + phase, size * 0.28, 0, Math.PI * 2);
  ctx.fill();

  // Skull base
  const skullGrad = ctx.createRadialGradient(x, y - size * 0.3 + phase, 0, x, y - size * 0.25 + phase, size * 0.2);
  skullGrad.addColorStop(0, `rgba(248, 250, 252, ${flicker})`);
  skullGrad.addColorStop(0.6, `rgba(226, 232, 240, ${flicker * 0.9})`);
  skullGrad.addColorStop(1, `rgba(203, 213, 225, ${flicker * 0.7})`);
  ctx.fillStyle = skullGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.28 + phase, size * 0.19, 0, Math.PI * 2);
  ctx.fill();

  // Skull cracks for horror
  ctx.strokeStyle = `rgba(100, 116, 139, ${flicker * 0.5})`;
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.05, y - size * 0.42 + phase);
  ctx.lineTo(x - size * 0.08, y - size * 0.32 + phase);
  ctx.lineTo(x - size * 0.03, y - size * 0.28 + phase);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.1, y - size * 0.4 + phase);
  ctx.lineTo(x + size * 0.08, y - size * 0.3 + phase);
  ctx.stroke();

  // Hollow eye sockets (deep black voids)
  ctx.fillStyle = `rgba(15, 23, 42, ${flicker})`;
  ctx.beginPath();
  ctx.ellipse(x - size * 0.08, y - size * 0.3 + phase, size * 0.055, size * 0.07, -0.1, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.08, y - size * 0.3 + phase, size * 0.055, size * 0.07, 0.1, 0, Math.PI * 2);
  ctx.fill();

  // Soul fire in eyes (gradient glow instead of shadowBlur)
  // Left eye glow
  const leftEyeGlow = ctx.createRadialGradient(x - size * 0.08, y - size * 0.3 + phase, 0, x - size * 0.08, y - size * 0.3 + phase, size * 0.08);
  leftEyeGlow.addColorStop(0, `rgba(56, 189, 248, ${flicker})`);
  leftEyeGlow.addColorStop(0.3, `rgba(56, 189, 248, ${flicker * 0.6})`);
  leftEyeGlow.addColorStop(0.6, `rgba(14, 165, 233, ${flicker * 0.3})`);
  leftEyeGlow.addColorStop(1, "rgba(14, 165, 233, 0)");
  ctx.fillStyle = leftEyeGlow;
  ctx.beginPath();
  ctx.arc(x - size * 0.08, y - size * 0.3 + phase, size * 0.08, 0, Math.PI * 2);
  ctx.fill();

  // Right eye glow
  const rightEyeGlow = ctx.createRadialGradient(x + size * 0.08, y - size * 0.3 + phase, 0, x + size * 0.08, y - size * 0.3 + phase, size * 0.08);
  rightEyeGlow.addColorStop(0, `rgba(56, 189, 248, ${flicker})`);
  rightEyeGlow.addColorStop(0.3, `rgba(56, 189, 248, ${flicker * 0.6})`);
  rightEyeGlow.addColorStop(0.6, `rgba(14, 165, 233, ${flicker * 0.3})`);
  rightEyeGlow.addColorStop(1, "rgba(14, 165, 233, 0)");
  ctx.fillStyle = rightEyeGlow;
  ctx.beginPath();
  ctx.arc(x + size * 0.08, y - size * 0.3 + phase, size * 0.08, 0, Math.PI * 2);
  ctx.fill();

  // Eye cores (bright center)
  ctx.fillStyle = `rgba(186, 230, 253, ${flicker})`;
  ctx.beginPath();
  ctx.arc(x - size * 0.08, y - size * 0.3 + phase, size * 0.028, 0, Math.PI * 2);
  ctx.arc(x + size * 0.08, y - size * 0.3 + phase, size * 0.028, 0, Math.PI * 2);
  ctx.fill();

  // Eye flame wisps
  ctx.strokeStyle = `rgba(56, 189, 248, ${flicker * 0.6})`;
  ctx.lineWidth = 1.5 * zoom;
  for (let eye = 0; eye < 2; eye++) {
    const eyeX = x + (eye === 0 ? -size * 0.08 : size * 0.08);
    for (let wisp = 0; wisp < 2; wisp++) {
      const wispAngle = -Math.PI * 0.5 + (wisp - 0.5) * 0.5 + Math.sin(time * 5 + eye + wisp) * 0.2;
      ctx.beginPath();
      ctx.moveTo(eyeX, y - size * 0.3 + phase);
      ctx.quadraticCurveTo(
        eyeX + Math.cos(wispAngle) * size * 0.04,
        y - size * 0.38 + phase,
        eyeX + Math.cos(wispAngle + 0.3) * size * 0.03,
        y - size * 0.45 + phase + Math.sin(time * 6 + wisp) * size * 0.02
      );
      ctx.stroke();
    }
  }

  // Nose cavity
  ctx.fillStyle = `rgba(30, 41, 59, ${flicker * 0.8})`;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.22 + phase);
  ctx.lineTo(x - size * 0.025, y - size * 0.17 + phase);
  ctx.lineTo(x + size * 0.025, y - size * 0.17 + phase);
  ctx.fill();

  // Ghostly mouth (wailing expression)
  const mouthOpen = 0.08 + Math.sin(time * 6) * 0.03 + (isAttacking ? attackIntensity * 0.05 : 0);
  ctx.fillStyle = `rgba(15, 23, 42, ${flicker * 0.9})`;
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.12 + phase, size * 0.07, size * mouthOpen, 0, 0, Math.PI * 2);
  ctx.fill();

  // Mouth inner darkness gradient
  const mouthGrad = ctx.createRadialGradient(x, y - size * 0.12 + phase, 0, x, y - size * 0.12 + phase, size * 0.06);
  mouthGrad.addColorStop(0, "rgba(0, 0, 0, 0.8)");
  mouthGrad.addColorStop(1, "rgba(15, 23, 42, 0)");
  ctx.fillStyle = mouthGrad;
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.12 + phase, size * 0.05, size * (mouthOpen - 0.02), 0, 0, Math.PI * 2);
  ctx.fill();

  // Wail effect (sound waves)
  if (wailPhase < 0.5) {
    const wailAlpha = (0.5 - wailPhase) * 0.4 * flicker;
    ctx.strokeStyle = `rgba(148, 163, 184, ${wailAlpha})`;
    ctx.lineWidth = 1 * zoom;
    for (let wave = 0; wave < 3; wave++) {
      const waveSize = size * (0.1 + wailPhase * 0.3 + wave * 0.08);
      ctx.beginPath();
      ctx.arc(x, y - size * 0.12 + phase, waveSize, Math.PI * 0.2, Math.PI * 0.8);
      ctx.stroke();
    }
  }

  // === LAYER 7: WISPY ARMS (DETAILED) ===
  // Left arm with ethereal detail
  const armGrad = ctx.createLinearGradient(x - size * 0.25, y - size * 0.1 + phase, x - size * 0.5, y + size * 0.35);
  armGrad.addColorStop(0, `rgba(203, 213, 225, ${flicker * 0.7})`);
  armGrad.addColorStop(0.5, `rgba(148, 163, 184, ${flicker * 0.5})`);
  armGrad.addColorStop(1, `rgba(100, 116, 139, ${flicker * 0.2})`);
  
  ctx.strokeStyle = armGrad;
  ctx.lineWidth = 4 * zoom;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.28, y - size * 0.08 + phase);
  ctx.bezierCurveTo(
    x - size * 0.45 + Math.sin(time * 3) * size * 0.08,
    y + size * 0.05,
    x - size * 0.5 + Math.cos(time * 2.5) * size * 0.06,
    y + size * 0.2,
    x - size * 0.45 + waver * size,
    y + size * 0.35
  );
  ctx.stroke();

  // Left arm secondary wisp
  ctx.lineWidth = 2 * zoom;
  ctx.strokeStyle = `rgba(148, 163, 184, ${flicker * 0.4})`;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.35, y + size * 0.1);
  ctx.quadraticCurveTo(
    x - size * 0.55 + Math.sin(time * 4) * size * 0.05,
    y + size * 0.25,
    x - size * 0.5,
    y + size * 0.45
  );
  ctx.stroke();

  // Left hand wisps (fingers)
  ctx.lineWidth = 1.5 * zoom;
  for (let finger = 0; finger < 4; finger++) {
    const fingerAngle = -0.3 + finger * 0.2 + Math.sin(time * 3 + finger) * 0.1;
    ctx.beginPath();
    ctx.moveTo(x - size * 0.45 + waver * size, y + size * 0.35);
    ctx.lineTo(
      x - size * 0.45 + waver * size + Math.cos(fingerAngle) * size * 0.12,
      y + size * 0.35 + Math.sin(fingerAngle + Math.PI * 0.5) * size * 0.1
    );
    ctx.stroke();
  }

  // Right arm
  ctx.strokeStyle = armGrad;
  ctx.lineWidth = 4 * zoom;
  ctx.beginPath();
  ctx.moveTo(x + size * 0.28, y - size * 0.08 + phase);
  ctx.bezierCurveTo(
    x + size * 0.45 - Math.sin(time * 3) * size * 0.08,
    y + size * 0.05,
    x + size * 0.5 - Math.cos(time * 2.5) * size * 0.06,
    y + size * 0.2,
    x + size * 0.45 - waver * size,
    y + size * 0.35
  );
  ctx.stroke();

  // Right arm secondary wisp
  ctx.lineWidth = 2 * zoom;
  ctx.strokeStyle = `rgba(148, 163, 184, ${flicker * 0.4})`;
  ctx.beginPath();
  ctx.moveTo(x + size * 0.35, y + size * 0.1);
  ctx.quadraticCurveTo(
    x + size * 0.55 - Math.sin(time * 4) * size * 0.05,
    y + size * 0.25,
    x + size * 0.5,
    y + size * 0.45
  );
  ctx.stroke();

  // Right hand wisps
  ctx.lineWidth = 1.5 * zoom;
  for (let finger = 0; finger < 4; finger++) {
    const fingerAngle = Math.PI - (-0.3 + finger * 0.2 + Math.sin(time * 3 + finger) * 0.1);
    ctx.beginPath();
    ctx.moveTo(x + size * 0.45 - waver * size, y + size * 0.35);
    ctx.lineTo(
      x + size * 0.45 - waver * size + Math.cos(fingerAngle) * size * 0.12,
      y + size * 0.35 + Math.sin(fingerAngle - Math.PI * 0.5) * size * 0.1
    );
    ctx.stroke();
  }

  // === LAYER 8: CHAINS OF BINDING (DETAILED) ===
  // Left chain
  ctx.strokeStyle = `rgba(71, 85, 105, ${flicker * 0.9})`;
  ctx.lineWidth = 2.5 * zoom;
  const chainStartL = { x: x - size * 0.18, y: y + size * 0.08 + phase };
  for (let link = 0; link < 7; link++) {
    const linkX = chainStartL.x - link * size * 0.055 + Math.sin(time * 2 + link * 0.5) * size * 0.02;
    const linkY = chainStartL.y + link * size * 0.05 + Math.cos(time * 3 + link) * size * 0.01;
    const linkAngle = Math.sin(time + link * 0.3) * 0.3;
    
    ctx.save();
    ctx.translate(linkX, linkY);
    ctx.rotate(linkAngle);
    ctx.strokeStyle = `rgba(71, 85, 105, ${flicker * (0.9 - link * 0.08)})`;
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 0.025, size * 0.035, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }

  // Right chain
  const chainStartR = { x: x + size * 0.18, y: y + size * 0.08 + phase };
  for (let link = 0; link < 7; link++) {
    const linkX = chainStartR.x + link * size * 0.055 - Math.sin(time * 2 + link * 0.5) * size * 0.02;
    const linkY = chainStartR.y + link * size * 0.05 + Math.cos(time * 3 + link) * size * 0.01;
    const linkAngle = -Math.sin(time + link * 0.3) * 0.3;
    
    ctx.save();
    ctx.translate(linkX, linkY);
    ctx.rotate(linkAngle);
    ctx.strokeStyle = `rgba(71, 85, 105, ${flicker * (0.9 - link * 0.08)})`;
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 0.025, size * 0.035, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }

  // Chain shackles on wrists
  ctx.fillStyle = `rgba(51, 65, 85, ${flicker * 0.8})`;
  ctx.beginPath();
  ctx.ellipse(x - size * 0.32, y + size * 0.05 + phase, size * 0.04, size * 0.025, -0.3, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.32, y + size * 0.05 + phase, size * 0.04, size * 0.025, 0.3, 0, Math.PI * 2);
  ctx.fill();

  // === LAYER 9: ATTACK EFFECT (SOUL DRAIN) ===
  if (isAttacking) {
    // Soul drain tendrils
    ctx.strokeStyle = `rgba(56, 189, 248, ${attackIntensity * 0.6})`;
    ctx.lineWidth = 2 * zoom;
    for (let tendril = 0; tendril < 5; tendril++) {
      const tendrilAngle = tendril * Math.PI / 2.5 - Math.PI / 5;
      ctx.beginPath();
      ctx.moveTo(x, y - size * 0.05 + phase);
      ctx.bezierCurveTo(
        x + Math.cos(tendrilAngle) * size * 0.3,
        y + Math.sin(tendrilAngle) * size * 0.2,
        x + Math.cos(tendrilAngle) * size * 0.5 + Math.sin(time * 8 + tendril) * size * 0.1,
        y + Math.sin(tendrilAngle) * size * 0.3,
        x + Math.cos(tendrilAngle) * size * 0.7,
        y + Math.sin(tendrilAngle) * size * 0.35
      );
      ctx.stroke();
    }

    // Soul orbs being drained
    for (let orb = 0; orb < 3; orb++) {
      const orbPhase = (attackIntensity + orb * 0.3) % 1;
      const orbDist = size * (0.6 - orbPhase * 0.5);
      const orbAngle = orb * Math.PI * 0.4 + time * 2;
      const orbX = x + Math.cos(orbAngle) * orbDist;
      const orbY = y + Math.sin(orbAngle) * orbDist * 0.5;
      
      const orbGlow = ctx.createRadialGradient(orbX, orbY, 0, orbX, orbY, size * 0.05);
      orbGlow.addColorStop(0, `rgba(186, 230, 253, ${attackIntensity * 0.8})`);
      orbGlow.addColorStop(0.5, `rgba(56, 189, 248, ${attackIntensity * 0.4})`);
      orbGlow.addColorStop(1, "rgba(56, 189, 248, 0)");
      ctx.fillStyle = orbGlow;
      ctx.beginPath();
      ctx.arc(orbX, orbY, size * 0.05, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // === LAYER 10: HOOD / SHROUD OVERLAY ===
  // Tattered hood edges
  ctx.strokeStyle = `rgba(100, 116, 139, ${flicker * 0.3})`;
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.25, y - size * 0.42 + phase);
  ctx.quadraticCurveTo(x - size * 0.35, y - size * 0.25 + phase, x - size * 0.32, y - size * 0.1 + phase);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.25, y - size * 0.42 + phase);
  ctx.quadraticCurveTo(x + size * 0.35, y - size * 0.25 + phase, x + size * 0.32, y - size * 0.1 + phase);
  ctx.stroke();
}

function drawBerserkerEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // BLOOD WARDEN - Possessed warrior channeling demonic rage through cursed runes
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const rage = Math.sin(time * 14) * 4 * zoom + (isAttacking ? attackIntensity * size * 0.25 : 0);
  const breathe = Math.sin(time * 9) * 0.1;
  const armSwing = Math.sin(time * 12) * 0.5;
  const bloodPulse = 0.6 + Math.sin(time * 6) * 0.35;
  const runeGlow = 0.5 + Math.sin(time * 4) * 0.4;

  // Blood mist aura
  for (let mist = 0; mist < 8; mist++) {
    const mistAngle = time * 0.8 + mist * Math.PI / 4;
    const mistDist = size * 0.5 + Math.sin(time * 2 + mist) * size * 0.1;
    ctx.fillStyle = `rgba(220, 38, 38, ${bloodPulse * 0.15})`;
    ctx.beginPath();
    ctx.arc(x + Math.cos(mistAngle) * mistDist, y + Math.sin(mistAngle) * mistDist * 0.5, size * 0.08, 0, Math.PI * 2);
    ctx.fill();
  }

  // Rage aura - more intense
  const rageGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.8);
  rageGrad.addColorStop(0, `rgba(220, 38, 38, ${bloodPulse * 0.4})`);
  rageGrad.addColorStop(0.4, `rgba(185, 28, 28, ${bloodPulse * 0.25})`);
  rageGrad.addColorStop(0.7, `rgba(127, 29, 29, ${bloodPulse * 0.1})`);
  rageGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = rageGrad;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.8, 0, Math.PI * 2);
  ctx.fill();

  // Motion blur effect - more dramatic
  ctx.globalAlpha = 0.35;
  for (let i = 1; i < 4; i++) {
    ctx.fillStyle = `rgba(185, 28, 28, ${0.3 - i * 0.08})`;
    ctx.beginPath();
    ctx.ellipse(x + i * 9, y, size * (0.28 - i * 0.04), size * (0.38 - i * 0.05), 0, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Blood-soaked ground
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.5, 0, x, y + size * 0.5, size * 0.4);
  shadowGrad.addColorStop(0, "rgba(127, 29, 29, 0.5)");
  shadowGrad.addColorStop(0.5, "rgba(0, 0, 0, 0.3)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.5, size * 0.35, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  // Muscular demonic body with runes
  const bodyGrad = ctx.createLinearGradient(x - size * 0.35, y, x + size * 0.35, y);
  bodyGrad.addColorStop(0, "#450a0a");
  bodyGrad.addColorStop(0.3, "#7f1d1d");
  bodyGrad.addColorStop(0.5, "#b91c1c");
  bodyGrad.addColorStop(0.7, "#7f1d1d");
  bodyGrad.addColorStop(1, "#450a0a");
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.38, y + size * 0.42);
  ctx.lineTo(x - size * 0.45 - breathe * size, y - size * 0.12);
  ctx.quadraticCurveTo(x, y - size * 0.45, x + size * 0.45 + breathe * size, y - size * 0.12);
  ctx.lineTo(x + size * 0.38, y + size * 0.42);
  ctx.closePath();
  ctx.fill();

  // Blood rune tattoos on body
  ctx.strokeStyle = `rgba(220, 38, 38, ${runeGlow})`;
  ctx.lineWidth = 2 * zoom;
  // Left rune
  ctx.beginPath();
  ctx.moveTo(x - size * 0.25, y - size * 0.1);
  ctx.lineTo(x - size * 0.2, y + size * 0.15);
  ctx.lineTo(x - size * 0.3, y + size * 0.25);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(x - size * 0.25, y + size * 0.05, size * 0.04, 0, Math.PI * 2);
  ctx.stroke();
  // Right rune
  ctx.beginPath();
  ctx.moveTo(x + size * 0.25, y - size * 0.1);
  ctx.lineTo(x + size * 0.2, y + size * 0.15);
  ctx.lineTo(x + size * 0.3, y + size * 0.25);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(x + size * 0.25, y + size * 0.05, size * 0.04, 0, Math.PI * 2);
  ctx.stroke();

  // War paint stripes - blood-soaked
  ctx.fillStyle = "#1a1a2e";
  ctx.fillRect(x - size * 0.28, y - size * 0.18, size * 0.1, size * 0.4);
  ctx.fillRect(x + size * 0.18, y - size * 0.18, size * 0.1, size * 0.4);

  // Massive demon-touched arms
  // Left arm with cursed axe
  ctx.save();
  ctx.translate(x - size * 0.4, y - size * 0.12);
  ctx.rotate(-0.55 + armSwing);
  const armGrad = ctx.createLinearGradient(0, 0, 0, size * 0.4);
  armGrad.addColorStop(0, "#b91c1c");
  armGrad.addColorStop(1, "#7f1d1d");
  ctx.fillStyle = armGrad;
  ctx.fillRect(-size * 0.1, 0, size * 0.2, size * 0.4);
  // Arm runes
  ctx.strokeStyle = `rgba(220, 38, 38, ${runeGlow * 0.7})`;
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, size * 0.05);
  ctx.lineTo(0, size * 0.3);
  ctx.stroke();
  // Cursed great axe
  ctx.fillStyle = "#1c1917";
  ctx.fillRect(-size * 0.035, size * 0.35, size * 0.07, size * 0.35);
  // Axe head with blood glow
  ctx.fillStyle = "#3f3f46";
  ctx.beginPath();
  ctx.moveTo(-size * 0.025, size * 0.6);
  ctx.quadraticCurveTo(-size * 0.15, size * 0.55, -size * 0.22, size * 0.45);
  ctx.lineTo(-size * 0.22, size * 0.7);
  ctx.quadraticCurveTo(-size * 0.15, size * 0.65, -size * 0.025, size * 0.65);
  ctx.fill();
  // Blood glow on blade
  ctx.strokeStyle = `rgba(220, 38, 38, ${bloodPulse})`;
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(-size * 0.05, size * 0.58);
  ctx.lineTo(-size * 0.18, size * 0.52);
  ctx.stroke();
  ctx.restore();

  // Right arm with spikes
  ctx.save();
  ctx.translate(x + size * 0.4, y - size * 0.12);
  ctx.rotate(0.55 - armSwing);
  ctx.fillStyle = armGrad;
  ctx.fillRect(-size * 0.1, 0, size * 0.2, size * 0.38);
  // Spiked gauntlet
  ctx.fillStyle = "#1c1917";
  ctx.fillRect(-size * 0.12, size * 0.32, size * 0.24, size * 0.1);
  // Spikes
  for (let spike = 0; spike < 3; spike++) {
    ctx.beginPath();
    ctx.moveTo(-size * 0.08 + spike * size * 0.08, size * 0.42);
    ctx.lineTo(-size * 0.06 + spike * size * 0.08, size * 0.52);
    ctx.lineTo(-size * 0.04 + spike * size * 0.08, size * 0.42);
    ctx.fill();
  }
  ctx.restore();

  // Fierce demonic head
  const headGrad = ctx.createRadialGradient(x, y - size * 0.38 + rage * 0.3, 0, x, y - size * 0.38 + rage * 0.3, size * 0.22);
  headGrad.addColorStop(0, "#a8a29e");
  headGrad.addColorStop(0.6, "#78716c");
  headGrad.addColorStop(1, "#57534e");
  ctx.fillStyle = headGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.38 + rage * 0.3, size * 0.2, 0, Math.PI * 2);
  ctx.fill();

  // Face runes
  ctx.strokeStyle = `rgba(220, 38, 38, ${runeGlow})`;
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.16, y - size * 0.42 + rage * 0.3);
  ctx.lineTo(x - size * 0.1, y - size * 0.32 + rage * 0.3);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.16, y - size * 0.42 + rage * 0.3);
  ctx.lineTo(x + size * 0.1, y - size * 0.32 + rage * 0.3);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.52 + rage * 0.3);
  ctx.lineTo(x, y - size * 0.42 + rage * 0.3);
  ctx.stroke();

  // Demonic eyes (intense blood glow)
  ctx.fillStyle = "#fef2f2";
  ctx.beginPath();
  ctx.arc(x - size * 0.08, y - size * 0.4 + rage * 0.3, size * 0.05, 0, Math.PI * 2);
  ctx.arc(x + size * 0.08, y - size * 0.4 + rage * 0.3, size * 0.05, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#dc2626";
  ctx.shadowColor = "#dc2626";
  ctx.shadowBlur = 10 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.08, y - size * 0.4 + rage * 0.3, size * 0.03, 0, Math.PI * 2);
  ctx.arc(x + size * 0.08, y - size * 0.4 + rage * 0.3, size * 0.03, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Pupil slits
  ctx.fillStyle = "#450a0a";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.08, y - size * 0.4 + rage * 0.3, size * 0.008, size * 0.02, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.08, y - size * 0.4 + rage * 0.3, size * 0.008, size * 0.02, 0, 0, Math.PI * 2);
  ctx.fill();

  // Screaming mouth with fangs
  ctx.fillStyle = "#1a1a2e";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.28 + rage * 0.3, size * 0.1, size * 0.06 + Math.abs(rage) * 0.012, 0, 0, Math.PI * 2);
  ctx.fill();
  // Fanged teeth
  ctx.fillStyle = "#f5f5f5";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.08, y - size * 0.31 + rage * 0.3);
  ctx.lineTo(x - size * 0.06, y - size * 0.24 + rage * 0.3);
  ctx.lineTo(x - size * 0.04, y - size * 0.31 + rage * 0.3);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.08, y - size * 0.31 + rage * 0.3);
  ctx.lineTo(x + size * 0.06, y - size * 0.24 + rage * 0.3);
  ctx.lineTo(x + size * 0.04, y - size * 0.31 + rage * 0.3);
  ctx.fill();

  // Wild flaming hair with horns
  ctx.fillStyle = "#991b1b";
  for (let i = 0; i < 9; i++) {
    const hairAngle = -Math.PI * 0.35 + i * Math.PI * 0.087;
    const hairLen = size * (0.25 + Math.sin(time * 10 + i) * 0.05);
    ctx.beginPath();
    ctx.moveTo(x + Math.cos(hairAngle) * size * 0.16, y - size * 0.5 + rage * 0.3);
    ctx.quadraticCurveTo(
      x + Math.cos(hairAngle) * size * 0.28 + Math.sin(time * 10 + i) * size * 0.06,
      y - size * 0.65 + rage * 0.3,
      x + Math.cos(hairAngle) * size * 0.22,
      y - size * 0.5 - hairLen + rage * 0.3
    );
    ctx.lineTo(x + Math.cos(hairAngle) * size * 0.13, y - size * 0.48 + rage * 0.3);
    ctx.fill();
  }
  // Small demon horns
  ctx.fillStyle = "#1c1917";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.12, y - size * 0.52 + rage * 0.3);
  ctx.lineTo(x - size * 0.18, y - size * 0.68 + rage * 0.3);
  ctx.lineTo(x - size * 0.08, y - size * 0.5 + rage * 0.3);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.12, y - size * 0.52 + rage * 0.3);
  ctx.lineTo(x + size * 0.18, y - size * 0.68 + rage * 0.3);
  ctx.lineTo(x + size * 0.08, y - size * 0.5 + rage * 0.3);
  ctx.fill();
}

function drawGolemEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // NASSAU LION COLOSSUS - Animated stone lion guardian, awakened from Nassau Hall
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const prowl = Math.sin(time * 3) * 3 * zoom + (isAttacking ? attackIntensity * size * 0.2 : 0);
  const breathe = Math.sin(time * 2) * size * 0.02;
  const crackGlow = 0.5 + Math.sin(time * 3) * 0.35;
  const maneFlow = Math.sin(time * 4) * 0.08;
  const tailSwish = Math.sin(time * 5) * 0.3;
  const eyeIntensity = 0.7 + Math.sin(time * 6) * 0.3;

  // Ancient power aura
  const auraGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.9);
  auraGrad.addColorStop(0, `rgba(251, 191, 36, ${crackGlow * 0.25})`);
  auraGrad.addColorStop(0.4, `rgba(217, 119, 6, ${crackGlow * 0.15})`);
  auraGrad.addColorStop(0.7, `rgba(180, 83, 9, ${crackGlow * 0.08})`);
  auraGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.9, 0, Math.PI * 2);
  ctx.fill();

  // Ground cracks from weight
  ctx.strokeStyle = `rgba(251, 191, 36, ${crackGlow * 0.4})`;
  ctx.lineWidth = 2 * zoom;
  for (let crack = 0; crack < 6; crack++) {
    const crackAngle = crack * Math.PI / 3;
    ctx.beginPath();
    ctx.moveTo(x, y + size * 0.45);
    let cx = x, cy = y + size * 0.45;
    for (let seg = 0; seg < 3; seg++) {
      cx += Math.cos(crackAngle + (Math.random() - 0.5) * 0.5) * size * 0.1;
      cy += size * 0.03;
      ctx.lineTo(cx, cy);
    }
    ctx.stroke();
  }

  // Heavy shadow
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.48, 0, x, y + size * 0.48, size * 0.5);
  shadowGrad.addColorStop(0, "rgba(0, 0, 0, 0.6)");
  shadowGrad.addColorStop(0.5, "rgba(0, 0, 0, 0.4)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.48, size * 0.55, size * 0.18, 0, 0, Math.PI * 2);
  ctx.fill();

  // Tail (behind body)
  ctx.save();
  ctx.translate(x + size * 0.35, y + size * 0.15);
  ctx.rotate(tailSwish);
  const tailGrad = ctx.createLinearGradient(0, 0, size * 0.4, 0);
  tailGrad.addColorStop(0, "#78716c");
  tailGrad.addColorStop(1, "#57534e");
  ctx.fillStyle = tailGrad;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.04);
  ctx.quadraticCurveTo(size * 0.25, -size * 0.08 + Math.sin(time * 6) * size * 0.03, size * 0.4, -size * 0.02);
  ctx.quadraticCurveTo(size * 0.25, size * 0.02 + Math.sin(time * 6) * size * 0.03, 0, size * 0.04);
  ctx.fill();
  // Tail tuft (stone carved)
  ctx.fillStyle = "#57534e";
  ctx.beginPath();
  for (let t = 0; t < 5; t++) {
    const tuftAngle = -Math.PI * 0.3 + t * Math.PI * 0.15;
    ctx.moveTo(size * 0.38, 0);
    ctx.quadraticCurveTo(
      size * 0.45 + Math.cos(tuftAngle) * size * 0.08,
      Math.sin(tuftAngle) * size * 0.06,
      size * 0.5 + Math.cos(tuftAngle) * size * 0.1,
      Math.sin(tuftAngle) * size * 0.1
    );
  }
  ctx.fill();
  ctx.restore();

  // Back legs
  ctx.fillStyle = "#57534e";
  // Left back leg
  ctx.beginPath();
  ctx.moveTo(x - size * 0.2, y + size * 0.2);
  ctx.lineTo(x - size * 0.28, y + size * 0.45 + prowl * 0.3);
  ctx.lineTo(x - size * 0.35, y + size * 0.48 + prowl * 0.3);
  ctx.lineTo(x - size * 0.22, y + size * 0.48 + prowl * 0.3);
  ctx.lineTo(x - size * 0.15, y + size * 0.2);
  ctx.fill();
  // Right back leg
  ctx.beginPath();
  ctx.moveTo(x + size * 0.2, y + size * 0.2);
  ctx.lineTo(x + size * 0.28, y + size * 0.45 - prowl * 0.15);
  ctx.lineTo(x + size * 0.35, y + size * 0.48 - prowl * 0.15);
  ctx.lineTo(x + size * 0.22, y + size * 0.48 - prowl * 0.15);
  ctx.lineTo(x + size * 0.15, y + size * 0.2);
  ctx.fill();
  // Paw details
  ctx.strokeStyle = "#44403c";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.32, y + size * 0.48 + prowl * 0.3);
  ctx.lineTo(x - size * 0.3, y + size * 0.45 + prowl * 0.3);
  ctx.moveTo(x - size * 0.28, y + size * 0.48 + prowl * 0.3);
  ctx.lineTo(x - size * 0.26, y + size * 0.45 + prowl * 0.3);
  ctx.stroke();

  // Massive lion body
  const bodyGrad = ctx.createRadialGradient(x, y + size * 0.05, 0, x, y + size * 0.05, size * 0.45);
  bodyGrad.addColorStop(0, "#a8a29e");
  bodyGrad.addColorStop(0.4, "#78716c");
  bodyGrad.addColorStop(0.8, "#57534e");
  bodyGrad.addColorStop(1, "#44403c");
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.08 + breathe, size * 0.4, size * 0.32, 0, 0, Math.PI * 2);
  ctx.fill();

  // Stone texture on body
  ctx.strokeStyle = "#44403c";
  ctx.lineWidth = 1.5 * zoom;
  for (let tex = 0; tex < 5; tex++) {
    const texX = x - size * 0.25 + tex * size * 0.12;
    ctx.beginPath();
    ctx.moveTo(texX, y - size * 0.1 + breathe);
    ctx.quadraticCurveTo(texX + size * 0.03, y + size * 0.05 + breathe, texX - size * 0.02, y + size * 0.2 + breathe);
    ctx.stroke();
  }

  // Glowing rune veins across body
  ctx.strokeStyle = `rgba(251, 191, 36, ${crackGlow * 0.6})`;
  ctx.shadowColor = "#fbbf24";
  ctx.shadowBlur = 8 * zoom;
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.3, y - size * 0.05 + breathe);
  ctx.quadraticCurveTo(x - size * 0.1, y + size * 0.1 + breathe, x + size * 0.15, y - size * 0.02 + breathe);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x - size * 0.15, y + size * 0.15 + breathe);
  ctx.lineTo(x + size * 0.2, y + size * 0.2 + breathe);
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Front legs (powerful, lion-like)
  ctx.fillStyle = "#78716c";
  // Left front leg
  ctx.beginPath();
  ctx.moveTo(x - size * 0.32, y - size * 0.08);
  ctx.lineTo(x - size * 0.38, y + size * 0.35 + prowl);
  ctx.lineTo(x - size * 0.45, y + size * 0.48 + prowl);
  ctx.lineTo(x - size * 0.3, y + size * 0.48 + prowl);
  ctx.lineTo(x - size * 0.26, y - size * 0.08);
  ctx.fill();
  // Right front leg
  ctx.beginPath();
  ctx.moveTo(x + size * 0.32, y - size * 0.08);
  ctx.lineTo(x + size * 0.38, y + size * 0.35 - prowl * 0.5);
  ctx.lineTo(x + size * 0.45, y + size * 0.48 - prowl * 0.5);
  ctx.lineTo(x + size * 0.3, y + size * 0.48 - prowl * 0.5);
  ctx.lineTo(x + size * 0.26, y - size * 0.08);
  ctx.fill();
  // Stone paws with claws
  ctx.fillStyle = "#57534e";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.375, y + size * 0.48 + prowl, size * 0.08, size * 0.035, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.375, y + size * 0.48 - prowl * 0.5, size * 0.08, size * 0.035, 0, 0, Math.PI * 2);
  ctx.fill();
  // Claws (glowing)
  ctx.fillStyle = `rgba(251, 191, 36, ${crackGlow})`;
  for (let paw = 0; paw < 2; paw++) {
    const pawX = paw === 0 ? x - size * 0.375 : x + size * 0.375;
    const pawY = paw === 0 ? y + size * 0.48 + prowl : y + size * 0.48 - prowl * 0.5;
    for (let claw = 0; claw < 4; claw++) {
      ctx.beginPath();
      ctx.moveTo(pawX - size * 0.06 + claw * size * 0.04, pawY + size * 0.02);
      ctx.lineTo(pawX - size * 0.065 + claw * size * 0.04, pawY + size * 0.06);
      ctx.lineTo(pawX - size * 0.055 + claw * size * 0.04, pawY + size * 0.02);
      ctx.fill();
    }
  }

  // Magnificent stone mane
  ctx.fillStyle = "#57534e";
  for (let layer = 0; layer < 3; layer++) {
    for (let m = 0; m < 12; m++) {
      const maneAngle = -Math.PI * 0.7 + m * Math.PI * 0.12;
      const maneLen = size * (0.18 + layer * 0.06) + Math.sin(time * 4 + m) * size * 0.02;
      const maneX = x + Math.cos(maneAngle) * size * (0.22 + layer * 0.03);
      const maneY = y - size * 0.35 + Math.sin(maneAngle) * size * 0.1;
      ctx.save();
      ctx.translate(maneX, maneY);
      ctx.rotate(maneAngle + Math.PI * 0.5 + maneFlow + Math.sin(time * 3 + m) * 0.05);
      ctx.beginPath();
      ctx.moveTo(-size * 0.03, 0);
      ctx.quadraticCurveTo(-size * 0.04, maneLen * 0.5, -size * 0.02, maneLen);
      ctx.quadraticCurveTo(0, maneLen * 1.1, size * 0.02, maneLen);
      ctx.quadraticCurveTo(size * 0.04, maneLen * 0.5, size * 0.03, 0);
      ctx.fill();
      ctx.restore();
    }
  }
  // Glowing veins in mane
  ctx.strokeStyle = `rgba(251, 191, 36, ${crackGlow * 0.4})`;
  ctx.lineWidth = 1.5 * zoom;
  for (let v = 0; v < 6; v++) {
    const vAngle = -Math.PI * 0.5 + v * Math.PI * 0.2;
    ctx.beginPath();
    ctx.moveTo(x + Math.cos(vAngle) * size * 0.15, y - size * 0.38);
    ctx.lineTo(x + Math.cos(vAngle) * size * 0.35, y - size * 0.5 + Math.sin(time * 3 + v) * size * 0.03);
    ctx.stroke();
  }

  // Majestic lion head
  const headGrad = ctx.createRadialGradient(x, y - size * 0.35, 0, x, y - size * 0.35, size * 0.25);
  headGrad.addColorStop(0, "#a8a29e");
  headGrad.addColorStop(0.5, "#78716c");
  headGrad.addColorStop(1, "#57534e");
  ctx.fillStyle = headGrad;
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.35, size * 0.22, size * 0.2, 0, 0, Math.PI * 2);
  ctx.fill();

  // Brow ridge
  ctx.fillStyle = "#57534e";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.48, size * 0.18, size * 0.06, 0, 0, Math.PI);
  ctx.fill();

  // Stone-carved muzzle
  ctx.fillStyle = "#78716c";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.28, size * 0.12, size * 0.1, 0, 0, Math.PI * 2);
  ctx.fill();

  // Nose
  ctx.fillStyle = "#44403c";
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.32);
  ctx.lineTo(x - size * 0.04, y - size * 0.26);
  ctx.lineTo(x + size * 0.04, y - size * 0.26);
  ctx.fill();

  // Ferocious glowing eyes
  ctx.fillStyle = "#1c1917";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.09, y - size * 0.42, size * 0.05, size * 0.04, -0.1, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.09, y - size * 0.42, size * 0.05, size * 0.04, 0.1, 0, Math.PI * 2);
  ctx.fill();
  // Glowing irises
  ctx.fillStyle = `rgba(251, 191, 36, ${eyeIntensity})`;
  ctx.shadowColor = "#fbbf24";
  ctx.shadowBlur = 12 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.09, y - size * 0.42, size * 0.035, 0, Math.PI * 2);
  ctx.arc(x + size * 0.09, y - size * 0.42, size * 0.035, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Slit pupils
  ctx.fillStyle = "#0f0a00";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.09, y - size * 0.42, size * 0.01, size * 0.025, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.09, y - size * 0.42, size * 0.01, size * 0.025, 0, 0, Math.PI * 2);
  ctx.fill();

  // Snarling mouth with stone fangs
  ctx.fillStyle = "#292524";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.22, size * 0.08, size * 0.04, 0, 0, Math.PI);
  ctx.fill();
  // Upper fangs
  ctx.fillStyle = "#e7e5e4";
  for (let fang = 0; fang < 2; fang++) {
    const fangX = fang === 0 ? x - size * 0.05 : x + size * 0.05;
    ctx.beginPath();
    ctx.moveTo(fangX - size * 0.015, y - size * 0.22);
    ctx.lineTo(fangX, y - size * 0.15);
    ctx.lineTo(fangX + size * 0.015, y - size * 0.22);
    ctx.fill();
  }
  // Teeth
  ctx.fillStyle = "#d6d3d1";
  for (let tooth = 0; tooth < 6; tooth++) {
    ctx.beginPath();
    ctx.arc(x - size * 0.05 + tooth * size * 0.02, y - size * 0.21, size * 0.008, 0, Math.PI * 2);
    ctx.fill();
  }

  // Stone ears
  ctx.fillStyle = "#78716c";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.15, y - size * 0.48);
  ctx.lineTo(x - size * 0.22, y - size * 0.62);
  ctx.lineTo(x - size * 0.1, y - size * 0.52);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.15, y - size * 0.48);
  ctx.lineTo(x + size * 0.22, y - size * 0.62);
  ctx.lineTo(x + size * 0.1, y - size * 0.52);
  ctx.fill();

  // Ancient Nassau rune on forehead
  ctx.fillStyle = `rgba(251, 191, 36, ${crackGlow})`;
  ctx.shadowColor = "#fbbf24";
  ctx.shadowBlur = 10 * zoom;
  ctx.font = `bold ${size * 0.1}px serif`;
  ctx.textAlign = "center";
  ctx.fillText("", x, y - size * 0.5);
  ctx.shadowBlur = 0;

  // Weathering and moss patches
  ctx.fillStyle = "#4d7c0f";
  ctx.globalAlpha = 0.6;
  ctx.beginPath();
  ctx.ellipse(x - size * 0.32, y + size * 0.05, size * 0.04, size * 0.025, 0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x + size * 0.28, y + size * 0.12, size * 0.035, size * 0.02, -0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x - size * 0.05, y - size * 0.55, size * 0.025, size * 0.015, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // Dust particles being kicked up
  for (let dust = 0; dust < 6; dust++) {
    const dustPhase = (time * 2 + dust * 0.4) % 1.5;
    const dustX = x - size * 0.4 + dust * size * 0.16 + Math.sin(time * 3 + dust) * size * 0.05;
    const dustY = y + size * 0.5 - dustPhase * size * 0.15;
    ctx.fillStyle = `rgba(168, 162, 158, ${(1 - dustPhase / 1.5) * 0.4})`;
    ctx.beginPath();
    ctx.arc(dustX, dustY, size * 0.015 * (1 - dustPhase / 2), 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawNecromancerEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // LICH SOVEREIGN - Ancient undead king commanding legions of the dead
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const hover = Math.sin(time * 2) * 5 * zoom + (isAttacking ? attackIntensity * size * 0.2 : 0);
  const deathPulse = 0.5 + Math.sin(time * 3) * 0.35;
  const soulBurn = 0.6 + Math.sin(time * 5) * 0.3;
  const phylacteryGlow = 0.7 + Math.sin(time * 4) * 0.25;

  // Death domain - rippling dark energy
  for (let ring = 0; ring < 4; ring++) {
    const ringSize = size * (0.35 + ring * 0.12) + Math.sin(time * 2 + ring * 0.5) * size * 0.04;
    ctx.strokeStyle = `rgba(74, 222, 128, ${deathPulse * (0.4 - ring * 0.08)})`;
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    ctx.ellipse(x, y + size * 0.48, ringSize, ringSize * 0.25, 0, 0, Math.PI * 2);
    ctx.stroke();
  }

  // Death aura - more intense
  const deathGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.9);
  deathGrad.addColorStop(0, `rgba(30, 27, 75, ${deathPulse * 0.5})`);
  deathGrad.addColorStop(0.3, `rgba(15, 10, 46, ${deathPulse * 0.35})`);
  deathGrad.addColorStop(0.6, `rgba(10, 10, 30, ${deathPulse * 0.2})`);
  deathGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = deathGrad;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.9, 0, Math.PI * 2);
  ctx.fill();

  // Floating skull spirits - more detailed
  for (let i = 0; i < 5; i++) {
    const spiritAngle = time * 1.2 + i * Math.PI * 0.4;
    const spiritDist = size * 0.58 + Math.sin(time * 2 + i) * size * 0.08;
    const spiritX = x + Math.cos(spiritAngle) * spiritDist;
    const spiritY = y - size * 0.08 + Math.sin(spiritAngle) * spiritDist * 0.35;
    // Skull glow
    ctx.fillStyle = `rgba(74, 222, 128, ${0.15 + Math.sin(time * 4 + i) * 0.1})`;
    ctx.beginPath();
    ctx.arc(spiritX, spiritY, size * 0.09, 0, Math.PI * 2);
    ctx.fill();
    // Skull
    ctx.fillStyle = `rgba(200, 200, 200, ${0.5 + Math.sin(time * 4 + i) * 0.25})`;
    ctx.beginPath();
    ctx.arc(spiritX, spiritY, size * 0.065, 0, Math.PI * 2);
    ctx.fill();
    // Skull eyes
    ctx.fillStyle = `rgba(74, 222, 128, ${soulBurn})`;
    ctx.shadowColor = "#4ade80";
    ctx.shadowBlur = 4 * zoom;
    ctx.beginPath();
    ctx.arc(spiritX - size * 0.018, spiritY - size * 0.012, size * 0.014, 0, Math.PI * 2);
    ctx.arc(spiritX + size * 0.018, spiritY - size * 0.012, size * 0.014, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    // Soul trail
    ctx.strokeStyle = `rgba(74, 222, 128, 0.2)`;
    ctx.lineWidth = 1 * zoom;
    ctx.beginPath();
    ctx.moveTo(spiritX, spiritY);
    ctx.lineTo(spiritX - Math.cos(spiritAngle) * size * 0.1, spiritY - Math.sin(spiritAngle) * size * 0.04);
    ctx.stroke();
  }

  // Deep shadow
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.52, 0, x, y + size * 0.52, size * 0.4);
  shadowGrad.addColorStop(0, "rgba(30, 27, 75, 0.6)");
  shadowGrad.addColorStop(0.5, "rgba(15, 10, 46, 0.35)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.52, size * 0.4, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  // Dark robes with soul threads
  const robeGrad = ctx.createLinearGradient(x - size * 0.42, y, x + size * 0.42, y);
  robeGrad.addColorStop(0, "#0a0820");
  robeGrad.addColorStop(0.3, "#1e1b4b");
  robeGrad.addColorStop(0.5, "#312e81");
  robeGrad.addColorStop(0.7, "#1e1b4b");
  robeGrad.addColorStop(1, "#0a0820");
  ctx.fillStyle = robeGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.42, y + size * 0.55);
  for (let i = 0; i < 7; i++) {
    const jagX = x - size * 0.42 + i * size * 0.14;
    const jagY = y + size * 0.55 + Math.sin(time * 5 + i * 1.1) * size * 0.05 + (i % 2) * size * 0.03;
    ctx.lineTo(jagX, jagY);
  }
  ctx.quadraticCurveTo(x + size * 0.45, y, x + size * 0.18, y - size * 0.45 + hover);
  ctx.lineTo(x - size * 0.18, y - size * 0.45 + hover);
  ctx.quadraticCurveTo(x - size * 0.45, y, x - size * 0.42, y + size * 0.55);
  ctx.fill();

  // Soul threads on robe
  ctx.strokeStyle = `rgba(74, 222, 128, ${deathPulse * 0.4})`;
  ctx.lineWidth = 1.5 * zoom;
  for (let thread = 0; thread < 5; thread++) {
    const threadX = x - size * 0.25 + thread * size * 0.125;
    ctx.beginPath();
    ctx.moveTo(threadX, y - size * 0.3 + hover * 0.2);
    ctx.bezierCurveTo(
      threadX + Math.sin(time * 2 + thread) * size * 0.05,
      y,
      threadX - Math.cos(time * 2 + thread) * size * 0.04,
      y + size * 0.2,
      threadX + Math.sin(thread) * size * 0.06,
      y + size * 0.45
    );
    ctx.stroke();
  }

  // Bone decorations on robe - more elaborate
  ctx.fillStyle = "#e8e0d0";
  for (let i = 0; i < 4; i++) {
    const boneY = y - size * 0.15 + i * size * 0.14 + hover * 0.5;
    ctx.beginPath();
    ctx.ellipse(x, boneY, size * 0.04, size * 0.018, 0, 0, Math.PI * 2);
    ctx.fill();
    // Small skulls between bones
    if (i < 3) {
      ctx.beginPath();
      ctx.arc(x, boneY + size * 0.07, size * 0.025, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#1e1b4b";
      ctx.beginPath();
      ctx.arc(x - size * 0.008, boneY + size * 0.065, size * 0.005, 0, Math.PI * 2);
      ctx.arc(x + size * 0.008, boneY + size * 0.065, size * 0.005, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#e8e0d0";
    }
  }

  // Crown of souls around head
  for (let crown = 0; crown < 6; crown++) {
    const crownAngle = crown * Math.PI / 3 - Math.PI / 2;
    ctx.fillStyle = `rgba(74, 222, 128, ${soulBurn * 0.5})`;
    ctx.beginPath();
    ctx.moveTo(
      x + Math.cos(crownAngle) * size * 0.2,
      y - size * 0.5 + hover + Math.sin(crownAngle) * size * 0.08
    );
    ctx.lineTo(
      x + Math.cos(crownAngle) * size * 0.28,
      y - size * 0.62 + hover + Math.sin(crownAngle) * size * 0.1 + Math.sin(time * 4 + crown) * size * 0.02
    );
    ctx.lineTo(
      x + Math.cos(crownAngle + 0.15) * size * 0.2,
      y - size * 0.5 + hover + Math.sin(crownAngle + 0.15) * size * 0.08
    );
    ctx.fill();
  }

  // Skeletal face - more detailed lich skull
  const skullGrad = ctx.createRadialGradient(x, y - size * 0.45 + hover, 0, x, y - size * 0.45 + hover, size * 0.18);
  skullGrad.addColorStop(0, "#f5f5f4");
  skullGrad.addColorStop(0.6, "#e8e0d0");
  skullGrad.addColorStop(1, "#d6d3d1");
  ctx.fillStyle = skullGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.45 + hover, size * 0.18, 0, Math.PI * 2);
  ctx.fill();
  // Skull cracks
  ctx.strokeStyle = "#a8a29e";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.58 + hover);
  ctx.lineTo(x - size * 0.04, y - size * 0.48 + hover);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.08, y - size * 0.55 + hover);
  ctx.lineTo(x + size * 0.1, y - size * 0.45 + hover);
  ctx.stroke();

  // Hollow eye sockets
  ctx.fillStyle = "#0a0820";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.07, y - size * 0.47 + hover, size * 0.045, size * 0.055, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.07, y - size * 0.47 + hover, size * 0.045, size * 0.055, 0, 0, Math.PI * 2);
  ctx.fill();

  // Soul-fire eyes
  ctx.fillStyle = "#4ade80";
  ctx.shadowColor = "#4ade80";
  ctx.shadowBlur = 12 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.07, y - size * 0.47 + hover, size * 0.025, 0, Math.PI * 2);
  ctx.arc(x + size * 0.07, y - size * 0.47 + hover, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Skeletal nose hole
  ctx.fillStyle = "#1e1b4b";
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.4 + hover);
  ctx.lineTo(x - size * 0.025, y - size * 0.35 + hover);
  ctx.lineTo(x + size * 0.025, y - size * 0.35 + hover);
  ctx.fill();

  // Grinning teeth
  ctx.fillStyle = "#e8e0d0";
  ctx.fillRect(x - size * 0.08, y - size * 0.33 + hover, size * 0.16, size * 0.04);
  ctx.strokeStyle = "#1e1b4b";
  ctx.lineWidth = 1 * zoom;
  for (let i = 0; i < 6; i++) {
    ctx.beginPath();
    ctx.moveTo(x - size * 0.07 + i * size * 0.028, y - size * 0.33 + hover);
    ctx.lineTo(x - size * 0.07 + i * size * 0.028, y - size * 0.29 + hover);
    ctx.stroke();
  }

  // Ornate hood with soul gems
  ctx.fillStyle = "#050414";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.55 + hover, size * 0.24, size * 0.12, 0, Math.PI, 0);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x - size * 0.24, y - size * 0.55 + hover);
  ctx.quadraticCurveTo(x - size * 0.3, y - size * 0.32 + hover, x - size * 0.22, y - size * 0.15 + hover);
  ctx.lineTo(x - size * 0.18, y - size * 0.35 + hover);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.24, y - size * 0.55 + hover);
  ctx.quadraticCurveTo(x + size * 0.3, y - size * 0.32 + hover, x + size * 0.22, y - size * 0.15 + hover);
  ctx.lineTo(x + size * 0.18, y - size * 0.35 + hover);
  ctx.fill();
  // Soul gem on hood
  ctx.fillStyle = `rgba(74, 222, 128, ${phylacteryGlow})`;
  ctx.shadowColor = "#4ade80";
  ctx.shadowBlur = 6 * zoom;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.62 + hover, size * 0.03, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Skull-topped staff with phylactery
  ctx.strokeStyle = "#1c1917";
  ctx.lineWidth = 5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.4, y - size * 0.22 + hover);
  ctx.lineTo(x - size * 0.45, y + size * 0.48);
  ctx.stroke();
  // Bone rings on staff
  ctx.fillStyle = "#a8a29e";
  ctx.fillRect(x - size * 0.465, y - size * 0.1 + hover, size * 0.05, size * 0.04);
  ctx.fillRect(x - size * 0.465, y + size * 0.15, size * 0.05, size * 0.04);
  ctx.fillRect(x - size * 0.465, y + size * 0.35, size * 0.05, size * 0.04);
  // Large staff skull
  ctx.fillStyle = "#e8e0d0";
  ctx.beginPath();
  ctx.arc(x - size * 0.4, y - size * 0.32 + hover, size * 0.1, 0, Math.PI * 2);
  ctx.fill();
  // Skull eyes (glowing intensely)
  ctx.fillStyle = "#4ade80";
  ctx.shadowColor = "#4ade80";
  ctx.shadowBlur = 8 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.43, y - size * 0.33 + hover, size * 0.02, 0, Math.PI * 2);
  ctx.arc(x - size * 0.37, y - size * 0.33 + hover, size * 0.02, 0, Math.PI * 2);
  ctx.fill();
  // Phylactery crystal above skull
  ctx.fillStyle = `rgba(74, 222, 128, ${phylacteryGlow})`;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.4, y - size * 0.42 + hover);
  ctx.lineTo(x - size * 0.36, y - size * 0.48 + hover);
  ctx.lineTo(x - size * 0.4, y - size * 0.56 + hover + Math.sin(time * 5) * size * 0.02);
  ctx.lineTo(x - size * 0.44, y - size * 0.48 + hover);
  ctx.fill();
  ctx.shadowBlur = 0;
}

function drawShadowKnightEnemy(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  bodyColor: string,
  bodyColorDark: string,
  bodyColorLight: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // DOOM CHAMPION - Fallen paladin corrupted by void, wielding soul-drinking blade
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const stance = Math.sin(time * 3) * 2.5 * zoom + (isAttacking ? attackIntensity * size * 0.18 : 0);
  const darkPulse = 0.5 + Math.sin(time * 4) * 0.35;
  const capeWave = Math.sin(time * 5) * 0.18;
  const voidGlow = 0.6 + Math.sin(time * 6) * 0.3;
  const soulDrain = 0.5 + Math.sin(time * 3) * 0.4;

  // Void corruption spreading from feet
  for (let corrupt = 0; corrupt < 6; corrupt++) {
    const corruptAngle = corrupt * Math.PI / 3 + time * 0.2;
    ctx.strokeStyle = `rgba(139, 92, 246, ${voidGlow * 0.3})`;
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.moveTo(x, y + size * 0.48);
    let cx = x, cy = y + size * 0.48;
    for (let seg = 0; seg < 3; seg++) {
      cx += Math.cos(corruptAngle + (Math.random() - 0.5) * 0.5) * size * 0.12;
      cy += size * 0.025;
      ctx.lineTo(cx, cy);
    }
    ctx.stroke();
  }

  // Dark aura - more intense
  const shadowGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.85);
  shadowGrad.addColorStop(0, `rgba(24, 24, 27, ${darkPulse * 0.45})`);
  shadowGrad.addColorStop(0.4, `rgba(39, 39, 42, ${darkPulse * 0.3})`);
  shadowGrad.addColorStop(0.7, `rgba(24, 24, 27, ${darkPulse * 0.15})`);
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.85, 0, Math.PI * 2);
  ctx.fill();

  // Void particles orbiting
  for (let particle = 0; particle < 8; particle++) {
    const particleAngle = time * 1.5 + particle * Math.PI / 4;
    const particleDist = size * 0.55 + Math.sin(time * 2 + particle) * size * 0.08;
    const px = x + Math.cos(particleAngle) * particleDist;
    const py = y + Math.sin(particleAngle) * particleDist * 0.4;
    ctx.fillStyle = `rgba(139, 92, 246, ${0.4 + Math.sin(time * 4 + particle) * 0.2})`;
    ctx.beginPath();
    ctx.arc(px, py, size * 0.02, 0, Math.PI * 2);
    ctx.fill();
  }

  // Deeper shadow
  const groundShadow = ctx.createRadialGradient(x, y + size * 0.52, 0, x, y + size * 0.52, size * 0.4);
  groundShadow.addColorStop(0, "rgba(0, 0, 0, 0.6)");
  groundShadow.addColorStop(0.5, "rgba(0, 0, 0, 0.35)");
  groundShadow.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = groundShadow;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.52, size * 0.4, size * 0.14, 0, 0, Math.PI * 2);
  ctx.fill();

  // Tattered cape with void tendrils
  const capeGrad = ctx.createLinearGradient(x - size * 0.4, y, x + size * 0.4, y);
  capeGrad.addColorStop(0, "#0a0a0b");
  capeGrad.addColorStop(0.5, "#18181b");
  capeGrad.addColorStop(1, "#0a0a0b");
  ctx.fillStyle = capeGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.28, y - size * 0.28 + stance);
  ctx.quadraticCurveTo(x - size * 0.45 - capeWave * size, y + size * 0.22, x - size * 0.38, y + size * 0.55);
  for (let i = 0; i < 6; i++) {
    const jagX = x - size * 0.38 + i * size * 0.152;
    const jagY = y + size * 0.55 + (i % 2) * size * 0.08 + Math.sin(time * 5 + i * 1.2) * size * 0.04;
    ctx.lineTo(jagX, jagY);
  }
  ctx.quadraticCurveTo(x + size * 0.45 + capeWave * size, y + size * 0.22, x + size * 0.28, y - size * 0.28 + stance);
  ctx.fill();
  // Void tendrils on cape
  ctx.strokeStyle = `rgba(139, 92, 246, ${voidGlow * 0.4})`;
  ctx.lineWidth = 1.5 * zoom;
  for (let tendril = 0; tendril < 4; tendril++) {
    const tendrilX = x - size * 0.25 + tendril * size * 0.17;
    ctx.beginPath();
    ctx.moveTo(tendrilX, y + size * 0.1);
    ctx.bezierCurveTo(
      tendrilX + Math.sin(time * 2 + tendril) * size * 0.05,
      y + size * 0.25,
      tendrilX - Math.cos(time * 2 + tendril) * size * 0.04,
      y + size * 0.4,
      tendrilX + Math.sin(tendril) * size * 0.06,
      y + size * 0.5
    );
    ctx.stroke();
  }

  // Armored body - more elaborate
  const armorGrad = ctx.createLinearGradient(x - size * 0.35, y, x + size * 0.35, y);
  armorGrad.addColorStop(0, "#18181b");
  armorGrad.addColorStop(0.2, "#27272a");
  armorGrad.addColorStop(0.35, "#3f3f46");
  armorGrad.addColorStop(0.5, "#52525b");
  armorGrad.addColorStop(0.65, "#3f3f46");
  armorGrad.addColorStop(0.8, "#27272a");
  armorGrad.addColorStop(1, "#18181b");
  ctx.fillStyle = armorGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.33, y + size * 0.38);
  ctx.lineTo(x - size * 0.38, y - size * 0.18 + stance);
  ctx.quadraticCurveTo(x, y - size * 0.4 + stance, x + size * 0.38, y - size * 0.18 + stance);
  ctx.lineTo(x + size * 0.33, y + size * 0.38);
  ctx.closePath();
  ctx.fill();

  // Armor details and trim
  ctx.strokeStyle = "#0a0a0b";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.3 + stance);
  ctx.lineTo(x, y + size * 0.25);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x - size * 0.28, y - size * 0.06 + stance);
  ctx.lineTo(x + size * 0.28, y - size * 0.06 + stance);
  ctx.stroke();
  // Void runes on armor
  ctx.strokeStyle = `rgba(139, 92, 246, ${darkPulse * 0.7})`;
  ctx.lineWidth = 1.5 * zoom;
  // Central rune
  ctx.beginPath();
  ctx.arc(x, y + size * 0.08, size * 0.05, 0, Math.PI * 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x, y + size * 0.02);
  ctx.lineTo(x, y + size * 0.14);
  ctx.moveTo(x - size * 0.04, y + size * 0.08);
  ctx.lineTo(x + size * 0.04, y + size * 0.08);
  ctx.stroke();

  // Massive shoulder pauldrons with spikes
  ctx.fillStyle = "#3f3f46";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.35, y - size * 0.18 + stance, size * 0.14, size * 0.1, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x + size * 0.35, y - size * 0.18 + stance, size * 0.14, size * 0.1, 0.3, 0, Math.PI * 2);
  ctx.fill();
  // Void gem on left pauldron
  ctx.fillStyle = `rgba(139, 92, 246, ${voidGlow})`;
  ctx.shadowColor = "#8b5cf6";
  ctx.shadowBlur = 4 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.35, y - size * 0.18 + stance, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Multiple spikes on pauldrons
  ctx.fillStyle = "#1c1917";
  for (let spike = 0; spike < 2; spike++) {
    ctx.beginPath();
    ctx.moveTo(x - size * 0.38 - spike * size * 0.05, y - size * 0.22 + stance);
    ctx.lineTo(x - size * 0.44 - spike * size * 0.06, y - size * 0.4 - spike * size * 0.05 + stance);
    ctx.lineTo(x - size * 0.34 - spike * size * 0.05, y - size * 0.2 + stance);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + size * 0.38 + spike * size * 0.05, y - size * 0.22 + stance);
    ctx.lineTo(x + size * 0.44 + spike * size * 0.06, y - size * 0.4 - spike * size * 0.05 + stance);
    ctx.lineTo(x + size * 0.34 + spike * size * 0.05, y - size * 0.2 + stance);
    ctx.fill();
  }

  // Menacing helmet
  const helmGrad = ctx.createLinearGradient(x - size * 0.2, y - size * 0.55, x + size * 0.2, y - size * 0.35);
  helmGrad.addColorStop(0, "#27272a");
  helmGrad.addColorStop(0.5, "#3f3f46");
  helmGrad.addColorStop(1, "#27272a");
  ctx.fillStyle = helmGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.43 + stance, size * 0.2, 0, Math.PI * 2);
  ctx.fill();
  // Helmet visor
  ctx.fillStyle = "#18181b";
  ctx.fillRect(x - size * 0.16, y - size * 0.5 + stance, size * 0.32, size * 0.14);
  // T-shaped visor slit
  ctx.fillStyle = "#0a0a0b";
  ctx.fillRect(x - size * 0.14, y - size * 0.47 + stance, size * 0.28, size * 0.04);
  ctx.fillRect(x - size * 0.02, y - size * 0.47 + stance, size * 0.04, size * 0.1);
  // Glowing eyes behind visor
  ctx.fillStyle = `rgba(139, 92, 246, ${darkPulse + 0.4})`;
  ctx.shadowColor = "#8b5cf6";
  ctx.shadowBlur = 10 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.07, y - size * 0.44 + stance, size * 0.025, 0, Math.PI * 2);
  ctx.arc(x + size * 0.07, y - size * 0.44 + stance, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Large horns
  ctx.fillStyle = "#1c1917";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.14, y - size * 0.58 + stance);
  ctx.quadraticCurveTo(x - size * 0.2, y - size * 0.7 + stance, x - size * 0.25, y - size * 0.8 + stance);
  ctx.quadraticCurveTo(x - size * 0.18, y - size * 0.7 + stance, x - size * 0.1, y - size * 0.58 + stance);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.14, y - size * 0.58 + stance);
  ctx.quadraticCurveTo(x + size * 0.2, y - size * 0.7 + stance, x + size * 0.25, y - size * 0.8 + stance);
  ctx.quadraticCurveTo(x + size * 0.18, y - size * 0.7 + stance, x + size * 0.1, y - size * 0.58 + stance);
  ctx.fill();
  // Crown spikes
  ctx.fillStyle = "#27272a";
  for (let crown = 0; crown < 5; crown++) {
    const crownAngle = -Math.PI * 0.4 + crown * Math.PI * 0.2;
    ctx.beginPath();
    ctx.moveTo(x + Math.cos(crownAngle) * size * 0.18, y - size * 0.55 + stance + Math.sin(crownAngle) * size * 0.05);
    ctx.lineTo(x + Math.cos(crownAngle) * size * 0.22, y - size * 0.65 + stance);
    ctx.lineTo(x + Math.cos(crownAngle + 0.1) * size * 0.18, y - size * 0.55 + stance + Math.sin(crownAngle + 0.1) * size * 0.05);
    ctx.fill();
  }

  // Soul-drinking sword
  ctx.save();
  ctx.translate(x + size * 0.4, y + size * 0.02 + stance);
  ctx.rotate(0.35);
  // Blade with void corruption
  const bladeGrad = ctx.createLinearGradient(0, 0, 0, -size * 0.65);
  bladeGrad.addColorStop(0, "#27272a");
  bladeGrad.addColorStop(0.5, "#3f3f46");
  bladeGrad.addColorStop(1, "#27272a");
  ctx.fillStyle = bladeGrad;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-size * 0.05, -size * 0.55);
  ctx.lineTo(0, -size * 0.68);
  ctx.lineTo(size * 0.05, -size * 0.55);
  ctx.closePath();
  ctx.fill();
  // Void energy flowing on blade
  ctx.strokeStyle = `rgba(139, 92, 246, ${soulDrain})`;
  ctx.shadowColor = "#8b5cf6";
  ctx.shadowBlur = 8 * zoom;
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.1);
  ctx.bezierCurveTo(
    -size * 0.02, -size * 0.25,
    size * 0.02, -size * 0.4,
    0, -size * 0.58
  );
  ctx.stroke();
  ctx.shadowBlur = 0;
  // Blade runes
  ctx.fillStyle = `rgba(139, 92, 246, ${voidGlow * 0.6})`;
  ctx.beginPath();
  ctx.arc(0, -size * 0.2, size * 0.015, 0, Math.PI * 2);
  ctx.arc(0, -size * 0.35, size * 0.015, 0, Math.PI * 2);
  ctx.arc(0, -size * 0.5, size * 0.015, 0, Math.PI * 2);
  ctx.fill();
  // Ornate crossguard
  ctx.fillStyle = "#52525b";
  ctx.fillRect(-size * 0.1, -size * 0.025, size * 0.2, size * 0.05);
  ctx.fillStyle = `rgba(139, 92, 246, ${voidGlow})`;
  ctx.beginPath();
  ctx.arc(-size * 0.08, 0, size * 0.015, 0, Math.PI * 2);
  ctx.arc(size * 0.08, 0, size * 0.015, 0, Math.PI * 2);
  ctx.fill();
  // Grip
  ctx.fillStyle = "#1c1917";
  ctx.fillRect(-size * 0.025, 0, size * 0.05, size * 0.14);
  // Pommel gem
  ctx.fillStyle = `rgba(139, 92, 246, ${voidGlow})`;
  ctx.shadowColor = "#8b5cf6";
  ctx.shadowBlur = 4 * zoom;
  ctx.beginPath();
  ctx.arc(0, size * 0.16, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // Shield (left arm) with skull emblem
  const shieldGrad = ctx.createLinearGradient(x - size * 0.55, y, x - size * 0.35, y);
  shieldGrad.addColorStop(0, "#27272a");
  shieldGrad.addColorStop(0.5, "#3f3f46");
  shieldGrad.addColorStop(1, "#27272a");
  ctx.fillStyle = shieldGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.38, y - size * 0.12 + stance);
  ctx.lineTo(x - size * 0.55, y - size * 0.08 + stance);
  ctx.lineTo(x - size * 0.55, y + size * 0.22 + stance);
  ctx.lineTo(x - size * 0.44, y + size * 0.35 + stance);
  ctx.lineTo(x - size * 0.38, y + size * 0.22 + stance);
  ctx.closePath();
  ctx.fill();
  // Shield border
  ctx.strokeStyle = "#52525b";
  ctx.lineWidth = 2 * zoom;
  ctx.stroke();
  // Skull emblem with glow
  ctx.fillStyle = "#a8a29e";
  ctx.beginPath();
  ctx.arc(x - size * 0.465, y + size * 0.08 + stance, size * 0.06, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = `rgba(139, 92, 246, ${voidGlow})`;
  ctx.shadowColor = "#8b5cf6";
  ctx.shadowBlur = 4 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.48, y + size * 0.07 + stance, size * 0.015, 0, Math.PI * 2);
  ctx.arc(x - size * 0.45, y + size * 0.07 + stance, size * 0.015, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
}
export function renderHero(
  ctx: CanvasRenderingContext2D,
  hero: Hero,
  canvasWidth: number,
  canvasHeight: number,
  dpr: number,
  cameraOffset?: Position,
  cameraZoom?: number
) {
  const screenPos = worldToScreen(
    hero.pos,
    canvasWidth,
    canvasHeight,
    dpr,
    cameraOffset,
    cameraZoom
  );
  const zoom = cameraZoom || 1;
  const hData = HERO_DATA[hero.type];
  const time = Date.now() / 1000;

  // Selection glow
  if (hero.selected) {
    ctx.strokeStyle = "#c9a227";
    ctx.lineWidth = 3 * zoom;
    ctx.setLineDash([6, 4]);
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      screenPos.y + 3 * zoom,
      40 * zoom,
      20 * zoom,
      0,
      0,
      Math.PI * 2
    );
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Shadow
  ctx.fillStyle = "rgba(0,0,0,0.45)";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    screenPos.y + 1 * zoom,
    22 * zoom,
    11 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  const size = 32 * zoom;
  const attackPhase = hero.attackAnim > 0 ? hero.attackAnim / 300 : 0;
  const attackScale = attackPhase > 0 ? 1 + attackPhase * 0.2 : 1;

  ctx.save();
  ctx.translate(screenPos.x, screenPos.y - size / 2);
  ctx.scale(attackScale, attackScale);

  // Draw specific hero type with attack animation
  drawHeroSprite(
    ctx,
    0,
    0,
    size,
    hero.type,
    hData.color,
    time,
    zoom,
    attackPhase
  );

  ctx.restore();

  // HP Bar
  const barWidth = 45 * zoom;
  const barHeight = 6 * zoom;
  const barY = screenPos.y - size - 18 * zoom;

  ctx.fillStyle = "rgba(0,0,0,0.8)";
  ctx.fillRect(
    screenPos.x - barWidth / 2 - 1,
    barY - 1,
    barWidth + 2,
    barHeight + 2
  );
  ctx.fillStyle = "#333";
  ctx.fillRect(screenPos.x - barWidth / 2, barY, barWidth, barHeight);

  const hpPercent = hero.hp / hero.maxHp;
  ctx.fillStyle =
    hpPercent > 0.5 ? "#4ade80" : hpPercent > 0.25 ? "#fbbf24" : "#ef4444";
  ctx.fillRect(
    screenPos.x - barWidth / 2,
    barY,
    barWidth * hpPercent,
    barHeight
  );

  // Name tag with glow
  ctx.shadowColor = hData.color;
  ctx.shadowBlur = 4 * zoom;
  ctx.fillStyle = "#fff";
  ctx.font = `bold ${10 * zoom}px Arial`;
  ctx.textAlign = "center";
  ctx.fillText(hData.name, screenPos.x, barY - 5 * zoom);
  ctx.shadowBlur = 0;
}

function drawHeroSprite(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  type: string,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  switch (type) {
    case "tiger":
      drawTigerHero(ctx, x, y, size, color, time, zoom, attackPhase);
      break;
    case "tenor":
      drawTenorHero(ctx, x, y, size, color, time, zoom, attackPhase);
      break;
    case "mathey":
      drawMatheyKnightHero(ctx, x, y, size, color, time, zoom, attackPhase);
      break;
    case "rocky":
      drawRockyHero(ctx, x, y, size, color, time, zoom, attackPhase);
      break;
    case "scott":
    case "fscott":
      drawFScottHero(ctx, x, y, size, color, time, zoom, attackPhase);
      break;
    case "captain":
      drawCaptainHero(ctx, x, y, size, color, time, zoom, attackPhase);
      break;
    case "engineer":
      drawEngineerHero(ctx, x, y, size, color, time, zoom, attackPhase);
      break;
    default:
      drawDefaultHero(ctx, x, y, size, color, time, zoom, attackPhase);
  }
}

function drawTigerHero(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // ARMORED WAR TIGER - Colossal beast warrior with devastating claw attacks
  const breathe = Math.sin(time * 1.8) * 3; // More pronounced breathing
  const idleSway = Math.sin(time * 1.2) * 1.5; // Subtle idle body sway
  const isAttacking = attackPhase > 0;
  const clawSwipe = isAttacking ? Math.sin(attackPhase * Math.PI * 2) * 1.8 : 0;
  const bodyLean = isAttacking ? Math.sin(attackPhase * Math.PI) * 0.2 : Math.sin(time * 1.5) * 0.03; // Idle lean
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const gemPulse = Math.sin(time * 2.5) * 0.3 + 0.7;
  
  // Arm raise animation - arms swing UP first, then DOWN during attack
  // Phase 0-0.4: Arms raise up
  // Phase 0.4-1.0: Arms swing down powerfully
  let armRaise = 0;
  if (isAttacking) {
    if (attackPhase < 0.4) {
      // Wind up - arms raise
      armRaise = Math.sin((attackPhase / 0.4) * Math.PI * 0.5) * size * 0.35;
    } else {
      // Swing down - arms come down fast
      armRaise = Math.cos(((attackPhase - 0.4) / 0.6) * Math.PI * 0.5) * size * 0.35 * (1 - (attackPhase - 0.4) / 0.6);
    }
  }

  // === ATTACK GLOW EFFECT ===
  if (isAttacking) {
    // Outer attack aura - intense orange glow
    const attackGlow = attackIntensity * 0.7;
    ctx.shadowColor = "#ff6600";
    ctx.shadowBlur = 25 * zoom * attackIntensity;
    
    // Pulsing attack ring
    for (let ring = 0; ring < 3; ring++) {
      const ringSize = size * (0.85 + ring * 0.15 + attackIntensity * 0.1);
      const ringAlpha = attackGlow * (0.6 - ring * 0.18);
      ctx.strokeStyle = `rgba(255, 120, 0, ${ringAlpha})`;
      ctx.lineWidth = (4 - ring) * zoom;
      ctx.beginPath();
      ctx.ellipse(x, y, ringSize, ringSize * 0.85, 0, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.shadowBlur = 0;
  }

  // === MULTI-LAYERED INFERNAL AURA ===
  const auraIntensity = isAttacking ? 0.65 : 0.2; // Much brighter when attacking
  const auraPulse = 0.85 + Math.sin(time * 3) * 0.15;
  for (let auraLayer = 0; auraLayer < 4; auraLayer++) {
    const layerOffset = auraLayer * 0.1;
    const auraGrad = ctx.createRadialGradient(
      x, y, size * (0.1 + layerOffset),
      x, y, size * (1.0 + layerOffset * 0.3)
    );
    auraGrad.addColorStop(0, `rgba(255, 100, 0, ${auraIntensity * auraPulse * (0.4 - auraLayer * 0.08)})`);
    auraGrad.addColorStop(0.4, `rgba(255, 60, 0, ${auraIntensity * auraPulse * (0.25 - auraLayer * 0.05)})`);
    auraGrad.addColorStop(0.7, `rgba(200, 50, 0, ${auraIntensity * auraPulse * (0.12 - auraLayer * 0.02)})`);
    auraGrad.addColorStop(1, "rgba(255, 80, 0, 0)");
    ctx.fillStyle = auraGrad;
    ctx.beginPath();
    ctx.ellipse(x, y, size * (0.95 + layerOffset * 0.2), size * (0.75 + layerOffset * 0.15), 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Floating flame particles
  for (let p = 0; p < 14; p++) {
    const pAngle = (time * 1.2 + p * Math.PI * 0.143) % (Math.PI * 2);
    const pDist = size * 0.75 + Math.sin(time * 2 + p * 0.5) * size * 0.1;
    const px = x + Math.cos(pAngle) * pDist;
    const py = y + Math.sin(pAngle) * pDist * 0.6 - Math.abs(Math.sin(time * 4 + p)) * size * 0.1;
    const pAlpha = 0.6 + Math.sin(time * 4 + p * 0.4) * 0.3;
    ctx.fillStyle = p % 3 === 0 ? `rgba(255, 200, 50, ${pAlpha})` : `rgba(255, 100, 0, ${pAlpha})`;
    ctx.beginPath();
    ctx.moveTo(px, py + size * 0.02);
    ctx.quadraticCurveTo(px - size * 0.01, py, px, py - size * 0.025);
    ctx.quadraticCurveTo(px + size * 0.01, py, px, py + size * 0.02);
    ctx.fill();
  }

  // === DEEP SHADOW ===
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.6, 0, x, y + size * 0.6, size * 0.65);
  shadowGrad.addColorStop(0, "rgba(0, 0, 0, 0.6)");
  shadowGrad.addColorStop(0.6, "rgba(0, 0, 0, 0.35)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.6, size * 0.65, size * 0.2, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(bodyLean);
  ctx.translate(-x, -y);

  // === MASSIVE MUSCULAR TIGER BODY ===
  // Add attack glow to body
  if (isAttacking) {
    ctx.shadowColor = "#ff6600";
    ctx.shadowBlur = 15 * zoom * attackIntensity;
  }
  
  const bodyGrad = ctx.createRadialGradient(x, y + size * 0.05 + breathe * 0.3, 0, x, y + size * 0.05 + breathe * 0.3, size * 0.7);
  bodyGrad.addColorStop(0, isAttacking ? "#ffbb55" : "#ffaa44");
  bodyGrad.addColorStop(0.3, isAttacking ? "#ff9933" : "#ff8822");
  bodyGrad.addColorStop(0.6, "#dd5500");
  bodyGrad.addColorStop(0.85, "#aa3300");
  bodyGrad.addColorStop(1, "#661800");
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  // Bulkier body shape with more breathing movement
  ctx.ellipse(
    x + idleSway * 0.3,
    y + breathe * 0.4,
    size * 0.58 + breathe * 0.008,
    size * 0.68 + breathe * 0.025,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();
  ctx.shadowBlur = 0;

  // === HEAVY WAR ARMOR - CHEST PLATE ===
  const chestArmorGrad = ctx.createLinearGradient(x - size * 0.4, y - size * 0.3, x + size * 0.4, y + size * 0.3);
  chestArmorGrad.addColorStop(0, "#2a2218");
  chestArmorGrad.addColorStop(0.2, "#4a3a28");
  chestArmorGrad.addColorStop(0.4, "#5a4a38");
  chestArmorGrad.addColorStop(0.5, "#6a5a48");
  chestArmorGrad.addColorStop(0.6, "#5a4a38");
  chestArmorGrad.addColorStop(0.8, "#4a3a28");
  chestArmorGrad.addColorStop(1, "#2a2218");
  ctx.fillStyle = chestArmorGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.38, y - size * 0.35);
  ctx.quadraticCurveTo(x - size * 0.45, y, x - size * 0.35, y + size * 0.3);
  ctx.lineTo(x - size * 0.15, y + size * 0.45);
  ctx.quadraticCurveTo(x, y + size * 0.5, x + size * 0.15, y + size * 0.45);
  ctx.lineTo(x + size * 0.35, y + size * 0.3);
  ctx.quadraticCurveTo(x + size * 0.45, y, x + size * 0.38, y - size * 0.35);
  ctx.quadraticCurveTo(x, y - size * 0.45, x - size * 0.38, y - size * 0.35);
  ctx.closePath();
  ctx.fill();

  // Armor plate edge highlight
  ctx.strokeStyle = "#8a7a68";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.36, y - size * 0.33);
  ctx.quadraticCurveTo(x - size * 0.43, y - size * 0.05, x - size * 0.33, y + size * 0.28);
  ctx.stroke();

  // Armor border
  ctx.strokeStyle = "#1a1510";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.38, y - size * 0.35);
  ctx.quadraticCurveTo(x - size * 0.45, y, x - size * 0.35, y + size * 0.3);
  ctx.lineTo(x - size * 0.15, y + size * 0.45);
  ctx.quadraticCurveTo(x, y + size * 0.5, x + size * 0.15, y + size * 0.45);
  ctx.lineTo(x + size * 0.35, y + size * 0.3);
  ctx.quadraticCurveTo(x + size * 0.45, y, x + size * 0.38, y - size * 0.35);
  ctx.quadraticCurveTo(x, y - size * 0.45, x - size * 0.38, y - size * 0.35);
  ctx.closePath();
  ctx.stroke();

  // Armor segment lines
  ctx.strokeStyle = "#3a3028";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.32, y - size * 0.1);
  ctx.lineTo(x + size * 0.32, y - size * 0.1);
  ctx.moveTo(x - size * 0.28, y + size * 0.15);
  ctx.lineTo(x + size * 0.28, y + size * 0.15);
  ctx.stroke();

  // Gold trim on armor
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.36, y - size * 0.32);
  ctx.quadraticCurveTo(x, y - size * 0.42, x + size * 0.36, y - size * 0.32);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x - size * 0.13, y + size * 0.43);
  ctx.quadraticCurveTo(x, y + size * 0.48, x + size * 0.13, y + size * 0.43);
  ctx.stroke();

  // Central tiger emblem on armor
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.28);
  ctx.lineTo(x - size * 0.12, y + size * 0.02);
  ctx.lineTo(x, y + size * 0.15);
  ctx.lineTo(x + size * 0.12, y + size * 0.02);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = "#ff6600";
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.22);
  ctx.lineTo(x - size * 0.08, y);
  ctx.lineTo(x, y + size * 0.1);
  ctx.lineTo(x + size * 0.08, y);
  ctx.closePath();
  ctx.fill();
  // Emblem gem
  ctx.fillStyle = "#ff3300";
  ctx.shadowColor = "#ff6600";
  ctx.shadowBlur = isAttacking ? 10 * zoom * gemPulse : 5 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.06, size * 0.035, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Armor studs/rivets
  for (let row = 0; row < 2; row++) {
    for (let i = -2; i <= 2; i++) {
      if (i === 0) continue;
      const studX = x + i * size * 0.13;
      const studY = y - size * 0.1 + row * size * 0.25;
      ctx.fillStyle = "#c9a227";
      ctx.beginPath();
      ctx.arc(studX, studY, size * 0.025, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#f0c040";
      ctx.beginPath();
      ctx.arc(studX - size * 0.006, studY - size * 0.006, size * 0.01, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // === DARK TIGER STRIPES (on exposed fur areas) ===
  ctx.strokeStyle = "#050202";
  ctx.lineWidth = 2 * zoom;
  ctx.lineCap = "round";
  // Side stripes visible around armor - more prominent
  for (let i = 0; i < 4; i++) {
    const stripeY = y - size * 0.2 + i * size * 0.14 + breathe * 0.3;
    // Left side stripes - longer and more visible
    ctx.beginPath();
    ctx.moveTo(x - size * 0.58, stripeY);
    ctx.quadraticCurveTo(x - size * 0.5, stripeY - size * 0.06, x - size * 0.4, stripeY + size * 0.01);
    ctx.stroke();
    // Right side stripes
    ctx.beginPath();
    ctx.moveTo(x + size * 0.58, stripeY);
    ctx.quadraticCurveTo(x + size * 0.5, stripeY - size * 0.06, x + size * 0.4, stripeY + size * 0.01);
    ctx.stroke();
  }

  // === COLOSSAL ARMORED SHOULDERS/PAULDRONS ===
  for (let side = -1; side <= 1; side += 2) {
    const shoulderX = x + side * size * 0.52 + (isAttacking ? 0 : idleSway * 0.2);
    const shoulderY = y - size * 0.15 - armRaise + (isAttacking ? 0 : breathe * 0.15); // Arms raise up during attack
    const armOffset = isAttacking ? clawSwipe * size * 0.15 * side : 0;
    
    // Arm rotation during attack - arms rotate outward when raised
    const armRotation = isAttacking 
      ? side * (-0.25 - clawSwipe * 0.25 - (armRaise / size) * 0.5) 
      : side * (-0.25 + Math.sin(time * 1.5) * 0.05);

    // Attack glow on arms
    if (isAttacking) {
      ctx.shadowColor = "#ff6600";
      ctx.shadowBlur = 12 * zoom * attackIntensity;
    }

    // Massive arm/shoulder muscle
    const armGrad = ctx.createRadialGradient(
      shoulderX + armOffset, shoulderY, 0,
      shoulderX + armOffset, shoulderY, size * 0.35
    );
    armGrad.addColorStop(0, isAttacking ? "#ffaa55" : "#ff9944");
    armGrad.addColorStop(0.4, isAttacking ? "#ff8833" : "#ff7722");
    armGrad.addColorStop(0.7, "#dd5500");
    armGrad.addColorStop(1, "#aa3300");
    ctx.fillStyle = armGrad;
    ctx.beginPath();
    ctx.ellipse(
      shoulderX + armOffset,
      shoulderY,
      size * 0.28,
      size * 0.35,
      armRotation,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.shadowBlur = 0;

    // Arm stripes - thin and distinctive
    ctx.strokeStyle = "#050202";
    ctx.lineWidth = 1.8 * zoom;
    for (let stripe = 0; stripe < 5; stripe++) {
      const stripeOffset = -size * 0.22 + stripe * size * 0.1;
      ctx.beginPath();
      ctx.moveTo(shoulderX + armOffset + side * size * 0.22, shoulderY + stripeOffset);
      ctx.quadraticCurveTo(
        shoulderX + armOffset + side * size * 0.14, shoulderY + stripeOffset - size * 0.035,
        shoulderX + armOffset + side * size * 0.06, shoulderY + stripeOffset + size * 0.01
      );
      ctx.stroke();
    }

    // Heavy shoulder pauldron with attack glow
    if (isAttacking) {
      ctx.shadowColor = "#ff8800";
      ctx.shadowBlur = 10 * zoom * attackIntensity;
    }
    const pauldronGrad = ctx.createRadialGradient(
      shoulderX + armOffset, shoulderY - size * 0.1, 0,
      shoulderX + armOffset, shoulderY - size * 0.1, size * 0.25
    );
    pauldronGrad.addColorStop(0, isAttacking ? "#7a6a58" : "#6a5a48");
    pauldronGrad.addColorStop(0.4, "#5a4a38");
    pauldronGrad.addColorStop(0.7, "#4a3a28");
    pauldronGrad.addColorStop(1, "#2a2218");
    ctx.fillStyle = pauldronGrad;
    ctx.beginPath();
    ctx.ellipse(
      shoulderX + armOffset,
      shoulderY - size * 0.08,
      size * 0.22,
      size * 0.18,
      armRotation * 0.5,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.shadowBlur = 0;

    // Pauldron spikes
    for (let spike = -1; spike <= 1; spike++) {
      const spikeAngle = armRotation * 0.5 + spike * 0.4;
      const spikeX = shoulderX + armOffset + Math.cos(spikeAngle - Math.PI * 0.5) * size * 0.15;
      const spikeY = shoulderY - size * 0.08 + Math.sin(spikeAngle - Math.PI * 0.5) * size * 0.1;
      const spikeLen = spike === 0 ? size * 0.2 : size * 0.14;
      
      ctx.fillStyle = "#3a3028";
      ctx.beginPath();
      ctx.moveTo(spikeX - size * 0.025, spikeY);
      ctx.lineTo(spikeX + side * spikeLen * 0.3, spikeY - spikeLen);
      ctx.lineTo(spikeX + size * 0.025, spikeY);
      ctx.closePath();
      ctx.fill();
      // Spike highlight
      ctx.strokeStyle = "#5a4a38";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(spikeX - size * 0.015, spikeY);
      ctx.lineTo(spikeX + side * spikeLen * 0.25, spikeY - spikeLen + size * 0.02);
      ctx.stroke();
    }

    // Gold trim on pauldron - glows during attack
    ctx.strokeStyle = isAttacking ? `rgba(255, 180, 50, ${0.8 + attackIntensity * 0.2})` : "#c9a227";
    ctx.lineWidth = (2 + (isAttacking ? attackIntensity : 0)) * zoom;
    if (isAttacking) {
      ctx.shadowColor = "#ffaa00";
      ctx.shadowBlur = 8 * zoom * attackIntensity;
    }
    ctx.beginPath();
    ctx.ellipse(
      shoulderX + armOffset,
      shoulderY - size * 0.08,
      size * 0.22,
      size * 0.18,
      armRotation * 0.5,
      0,
      Math.PI * 2
    );
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Pauldron gem - glows intensely during attack
    ctx.fillStyle = isAttacking ? "#ff6600" : "#ff4400";
    ctx.shadowColor = "#ff6600";
    ctx.shadowBlur = (isAttacking ? 12 + attackIntensity * 10 : 5) * zoom * gemPulse;
    ctx.beginPath();
    ctx.arc(shoulderX + armOffset, shoulderY - size * 0.1, size * (0.03 + (isAttacking ? attackIntensity * 0.01 : 0)), 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // === ARMORED CLAW GAUNTLETS ===
    // Claws move with arms - raise up during wind-up, extend down during strike
    const clawX = shoulderX + armOffset * 1.8 + side * size * 0.15;
    const clawY = y + size * 0.28 - armRaise * 0.8; // Claws raise with arms
    const clawExtend = isAttacking ? attackIntensity * size * 0.3 : 0;

    // Paw base with fur - glows during attack
    if (isAttacking) {
      ctx.shadowColor = "#ff6600";
      ctx.shadowBlur = 15 * zoom * attackIntensity;
    }
    const pawGrad = ctx.createRadialGradient(clawX, clawY - size * 0.06, 0, clawX, clawY - size * 0.06, size * 0.16);
    pawGrad.addColorStop(0, isAttacking ? "#ffbb66" : "#ffaa55");
    pawGrad.addColorStop(0.6, isAttacking ? "#ff9944" : "#ff8833");
    pawGrad.addColorStop(1, "#cc5500");
    ctx.fillStyle = pawGrad;
    ctx.beginPath();
    ctx.ellipse(clawX, clawY - size * 0.04, size * 0.14, size * 0.12, armRotation * 0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Metal claw guards/gauntlet
    const gauntletGrad = ctx.createLinearGradient(clawX - size * 0.1, clawY, clawX + size * 0.1, clawY);
    gauntletGrad.addColorStop(0, "#2a2218");
    gauntletGrad.addColorStop(0.3, "#4a3a28");
    gauntletGrad.addColorStop(0.5, "#5a4a38");
    gauntletGrad.addColorStop(0.7, "#4a3a28");
    gauntletGrad.addColorStop(1, "#2a2218");
    ctx.fillStyle = gauntletGrad;
    ctx.beginPath();
    ctx.moveTo(clawX - size * 0.1, clawY - size * 0.08);
    ctx.lineTo(clawX - size * 0.12, clawY + size * 0.04);
    ctx.lineTo(clawX + size * 0.12, clawY + size * 0.04);
    ctx.lineTo(clawX + size * 0.1, clawY - size * 0.08);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "#c9a227";
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Deadly claws with metal tips
    for (let c = 0; c < 4; c++) {
      const clawAngle = (c - 1.5) * 0.35 + side * (clawSwipe * 0.4);
      const clawBaseX = clawX + Math.sin(clawAngle) * size * 0.12;
      const clawBaseY = clawY + size * 0.04 + Math.cos(clawAngle) * size * 0.04;
      
      ctx.save();
      ctx.translate(clawBaseX, clawBaseY);
      ctx.rotate(clawAngle * 0.4);
      
      // Metal-reinforced claw
      const metalClawGrad = ctx.createLinearGradient(0, 0, 0, size * 0.16 + clawExtend);
      metalClawGrad.addColorStop(0, "#4a4a4a");
      metalClawGrad.addColorStop(0.2, "#2a2a2a");
      metalClawGrad.addColorStop(0.6, "#1a1a1a");
      metalClawGrad.addColorStop(0.85, "#3a3a3a");
      metalClawGrad.addColorStop(1, "#ffffff");
      ctx.fillStyle = metalClawGrad;
      
      ctx.beginPath();
      ctx.moveTo(-size * 0.028, 0);
      ctx.quadraticCurveTo(-size * 0.032, size * 0.08 + clawExtend * 0.5, 0, size * 0.16 + clawExtend);
      ctx.quadraticCurveTo(size * 0.032, size * 0.08 + clawExtend * 0.5, size * 0.028, 0);
      ctx.closePath();
      ctx.fill();
      
      // Claw highlight
      ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
      ctx.lineWidth = 1.5 * zoom;
      ctx.beginPath();
      ctx.moveTo(-size * 0.012, size * 0.025);
      ctx.lineTo(0, size * 0.14 + clawExtend * 0.85);
      ctx.stroke();
      
      ctx.restore();
    }

    // === EPIC CLAW SLASH EFFECT (Top-Down Diagonal Swipe) ===
    // Only trigger during the swing-down phase (after arms are raised)
    if (isAttacking && attackPhase > 0.35 && attackPhase < 0.95) {
      const slashProgress = (attackPhase - 0.35) / 0.6;
      const slashAlpha = Math.sin(slashProgress * Math.PI) * 0.95;
      
      // Starting position matches raised arm position
      const slashStartX = shoulderX + side * size * 0.2;
      const slashStartY = y - size * 0.5; // High starting point
      
      // Four parallel slash marks sweeping down diagonally
      for (let s = 0; s < 4; s++) {
        const slashOffset = s * size * 0.065;
        const slashEndX = shoulderX + side * size * 0.7 * slashProgress;
        const slashEndY = y + size * 0.65 * slashProgress;
        
        // Main slash trail gradient - brighter and more intense
        const slashGrad = ctx.createLinearGradient(
          slashStartX + slashOffset * side, slashStartY,
          slashEndX + slashOffset * side, slashEndY
        );
        slashGrad.addColorStop(0, `rgba(255, 255, 220, ${slashAlpha * 0.4})`);
        slashGrad.addColorStop(0.15, `rgba(255, 240, 120, ${slashAlpha})`);
        slashGrad.addColorStop(0.4, `rgba(255, 160, 20, ${slashAlpha * 0.9})`);
        slashGrad.addColorStop(0.7, `rgba(255, 100, 0, ${slashAlpha * 0.6})`);
        slashGrad.addColorStop(1, `rgba(255, 60, 0, 0)`);
        
        ctx.strokeStyle = slashGrad;
        ctx.lineWidth = (7 - s * 1.2) * zoom;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(slashStartX + slashOffset * side, slashStartY + slashOffset * 0.4);
        ctx.bezierCurveTo(
          slashStartX + side * size * 0.35 + slashOffset * side, slashStartY + size * 0.25,
          shoulderX + side * size * 0.5 + slashOffset * side, y + size * 0.15,
          slashEndX + slashOffset * side, slashEndY + slashOffset * 0.6
        );
        ctx.stroke();
      }
      
      // Add spark particles along the slash - more particles, more dynamic
      if (slashProgress > 0.2 && slashProgress < 0.85) {
        for (let spark = 0; spark < 12; spark++) {
          const sparkProgress = slashProgress * 0.75 + spark * 0.04;
          const sparkX = slashStartX + (shoulderX + side * size * 0.55 - slashStartX) * sparkProgress + side * Math.sin(spark * 2.5 + time * 10) * size * 0.06;
          const sparkY = slashStartY + (y + size * 0.45 - slashStartY) * sparkProgress + Math.cos(spark * 3.5 + time * 8) * size * 0.05;
          const sparkAlpha = slashAlpha * (1 - spark * 0.07);
          const sparkSize = size * (0.022 - spark * 0.0012);
          
          // Glow behind sparks
          ctx.shadowColor = "#ff8800";
          ctx.shadowBlur = 6 * zoom;
          ctx.fillStyle = spark % 3 === 0 
            ? `rgba(255, 255, 180, ${sparkAlpha})` 
            : spark % 3 === 1
            ? `rgba(255, 200, 80, ${sparkAlpha * 0.9})`
            : `rgba(255, 140, 20, ${sparkAlpha * 0.8})`;
          ctx.beginPath();
          ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }
    }
  }

  // === ARMORED LEG GUARDS ===
  for (let side = -1; side <= 1; side += 2) {
    const legX = x + side * size * 0.28;
    const legY = y + size * 0.5;
    
    // Leg fur
    ctx.fillStyle = "#dd6600";
    ctx.beginPath();
    ctx.ellipse(legX, legY, size * 0.12, size * 0.15, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Leg armor
    const legArmorGrad = ctx.createLinearGradient(legX - size * 0.08, legY - size * 0.1, legX + size * 0.08, legY + size * 0.1);
    legArmorGrad.addColorStop(0, "#3a3028");
    legArmorGrad.addColorStop(0.5, "#5a4a38");
    legArmorGrad.addColorStop(1, "#3a3028");
    ctx.fillStyle = legArmorGrad;
    ctx.beginPath();
    ctx.moveTo(legX - size * 0.08, legY - size * 0.08);
    ctx.lineTo(legX - size * 0.1, legY + size * 0.1);
    ctx.lineTo(legX + size * 0.1, legY + size * 0.1);
    ctx.lineTo(legX + size * 0.08, legY - size * 0.08);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "#c9a227";
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  // === FIERCE ARMORED TIGER HEAD ===
  // Head bobs slightly with breathing
  const headY = y - size * 0.55 + breathe * 0.1;
  const headX = x + idleSway * 0.15;
  
  // Attack glow on head
  if (isAttacking) {
    ctx.shadowColor = "#ff6600";
    ctx.shadowBlur = 18 * zoom * attackIntensity;
  }
  
  const headGrad = ctx.createRadialGradient(
    headX, headY, 0,
    headX, headY, size * 0.42
  );
  headGrad.addColorStop(0, isAttacking ? "#ffbb55" : "#ffaa44");
  headGrad.addColorStop(0.4, isAttacking ? "#ff9933" : "#ff8822");
  headGrad.addColorStop(0.7, "#dd5500");
  headGrad.addColorStop(1, "#aa3300");
  ctx.fillStyle = headGrad;
  ctx.beginPath();
  ctx.ellipse(headX, headY, size * 0.4, size * 0.36, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // === WAR CROWN/HELMET ===
  const crownGrad = ctx.createLinearGradient(x - size * 0.35, y - size * 0.85, x + size * 0.35, y - size * 0.85);
  crownGrad.addColorStop(0, "#2a2218");
  crownGrad.addColorStop(0.3, "#5a4a38");
  crownGrad.addColorStop(0.5, "#6a5a48");
  crownGrad.addColorStop(0.7, "#5a4a38");
  crownGrad.addColorStop(1, "#2a2218");
  ctx.fillStyle = crownGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.32, y - size * 0.72);
  ctx.lineTo(x - size * 0.38, y - size * 0.88);
  ctx.lineTo(x - size * 0.2, y - size * 0.78);
  ctx.lineTo(x - size * 0.12, y - size * 0.95);
  ctx.lineTo(x, y - size * 0.82);
  ctx.lineTo(x + size * 0.12, y - size * 0.95);
  ctx.lineTo(x + size * 0.2, y - size * 0.78);
  ctx.lineTo(x + size * 0.38, y - size * 0.88);
  ctx.lineTo(x + size * 0.32, y - size * 0.72);
  ctx.closePath();
  ctx.fill();

  // Crown gold trim
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 2 * zoom;
  ctx.stroke();

  // Crown gems
  const crownGemPositions = [
    { x: x - size * 0.12, y: y - size * 0.9 },
    { x: x, y: y - size * 0.78 },
    { x: x + size * 0.12, y: y - size * 0.9 }
  ];
  ctx.shadowColor = "#ff6600";
  ctx.shadowBlur = 6 * zoom * gemPulse;
  for (const gem of crownGemPositions) {
    ctx.fillStyle = "#ff4400";
    ctx.beginPath();
    ctx.arc(gem.x, gem.y, size * 0.025, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.shadowBlur = 0;

  // Forehead armor plate
  ctx.fillStyle = "#4a3a28";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.22, y - size * 0.7);
  ctx.lineTo(x, y - size * 0.58);
  ctx.lineTo(x + size * 0.22, y - size * 0.7);
  ctx.lineTo(x + size * 0.15, y - size * 0.75);
  ctx.lineTo(x, y - size * 0.68);
  ctx.lineTo(x - size * 0.15, y - size * 0.75);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // === HEAD STRIPES ===
  ctx.strokeStyle = "#0a0505";
  ctx.lineWidth = 3 * zoom;
  ctx.lineCap = "round";
  // Cheek stripes (bold, jagged)
  ctx.beginPath();
  ctx.moveTo(x - size * 0.38, y - size * 0.58);
  ctx.lineTo(x - size * 0.25, y - size * 0.52);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x - size * 0.36, y - size * 0.5);
  ctx.lineTo(x - size * 0.22, y - size * 0.46);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.38, y - size * 0.58);
  ctx.lineTo(x + size * 0.25, y - size * 0.52);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.36, y - size * 0.5);
  ctx.lineTo(x + size * 0.22, y - size * 0.46);
  ctx.stroke();

  // === FIERCE POINTED EARS WITH ARMOR ===
  for (let side = -1; side <= 1; side += 2) {
    // Ear base
    ctx.fillStyle = "#dd6600";
    ctx.beginPath();
    ctx.moveTo(x + side * size * 0.28, y - size * 0.72);
    ctx.lineTo(x + side * size * 0.42, y - size * 1.0);
    ctx.lineTo(x + side * size * 0.18, y - size * 0.76);
    ctx.closePath();
    ctx.fill();
    // Dark ear tips
    ctx.fillStyle = "#1a0a00";
    ctx.beginPath();
    ctx.moveTo(x + side * size * 0.36, y - size * 0.9);
    ctx.lineTo(x + side * size * 0.42, y - size * 1.0);
    ctx.lineTo(x + side * size * 0.32, y - size * 0.88);
    ctx.closePath();
    ctx.fill();
    // Inner ear
    ctx.fillStyle = "#ffccaa";
    ctx.beginPath();
    ctx.moveTo(x + side * size * 0.27, y - size * 0.74);
    ctx.lineTo(x + side * size * 0.35, y - size * 0.88);
    ctx.lineTo(x + side * size * 0.2, y - size * 0.76);
    ctx.closePath();
    ctx.fill();
    // Ear armor ring
    ctx.fillStyle = "#c9a227";
    ctx.beginPath();
    ctx.arc(x + side * size * 0.3, y - size * 0.78, size * 0.025, 0, Math.PI * 2);
    ctx.fill();
  }

  // === MUZZLE ===
  ctx.fillStyle = "#fff8e7";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.44, size * 0.18, size * 0.15, 0, 0, Math.PI * 2);
  ctx.fill();

  // Whisker dots (prominent white)
  ctx.fillStyle = "#ffffff";
  for (let side = -1; side <= 1; side += 2) {
    for (let row = 0; row < 3; row++) {
      for (let col = 0; col < 3; col++) {
        const dotX = x + side * (size * 0.06 + col * size * 0.035);
        const dotY = y - size * 0.46 + row * size * 0.03;
        ctx.beginPath();
        ctx.arc(dotX, dotY, size * 0.012, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // Nose (larger, more fierce)
  ctx.fillStyle = "#1a0a05";
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.52);
  ctx.lineTo(x - size * 0.08, y - size * 0.44);
  ctx.quadraticCurveTo(x, y - size * 0.42, x + size * 0.08, y - size * 0.44);
  ctx.closePath();
  ctx.fill();
  // Nose highlight
  ctx.fillStyle = "#3a2a20";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.02, y - size * 0.48, size * 0.015, size * 0.01, -0.3, 0, Math.PI * 2);
  ctx.fill();

  // === GLOWING FIERCE EYES ===
  const eyeGlow = 0.9 + Math.sin(time * 4) * 0.1 + attackIntensity * 0.3;
  const eyeY = y - size * 0.62 + breathe * 0.08; // Eyes move slightly with breathing
  
  // Eye socket shadows
  ctx.fillStyle = "#1a0a05";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.15, eyeY, size * 0.11, size * 0.085, -0.15, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.15, eyeY, size * 0.11, size * 0.085, 0.15, 0, Math.PI * 2);
  ctx.fill();

  // Glowing eyes - INTENSE glow during attack
  ctx.shadowColor = isAttacking ? "#ff4400" : "#ffaa00";
  ctx.shadowBlur = (isAttacking ? 25 + attackIntensity * 20 : 12) * zoom;
  ctx.fillStyle = isAttacking
    ? `rgba(255, 100, 0, ${eyeGlow})`
    : `rgba(255, 180, 0, ${eyeGlow})`;
  ctx.beginPath();
  ctx.ellipse(x - size * 0.15, eyeY, size * (0.1 + attackIntensity * 0.015), size * (0.07 + attackIntensity * 0.01), -0.15, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.15, eyeY, size * (0.1 + attackIntensity * 0.015), size * (0.07 + attackIntensity * 0.01), 0.15, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Angry brow ridges
  ctx.strokeStyle = "#0a0505";
  ctx.lineWidth = 3 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.25, y - size * 0.68);
  ctx.quadraticCurveTo(x - size * 0.15, y - size * 0.72, x - size * 0.08, y - size * 0.68);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.25, y - size * 0.68);
  ctx.quadraticCurveTo(x + size * 0.15, y - size * 0.72, x + size * 0.08, y - size * 0.68);
  ctx.stroke();

  // Slit pupils (menacing) - narrow during attack
  const pupilWidth = isAttacking ? size * 0.018 : size * 0.025;
  ctx.fillStyle = "#0a0505";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.15, eyeY, pupilWidth, size * 0.06, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.15, eyeY, pupilWidth, size * 0.06, 0, 0, Math.PI * 2);
  ctx.fill();

  // Eye glints
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.arc(x - size * 0.12, eyeY - size * 0.02, size * 0.02, 0, Math.PI * 2);
  ctx.arc(x + size * 0.18, eyeY - size * 0.02, size * 0.02, 0, Math.PI * 2);
  ctx.fill();

  // === ROARING MOUTH ===
  const mouthOpen = isAttacking
    ? size * 0.06 + attackIntensity * size * 0.08
    : size * 0.04;
  
  // Mouth interior
  ctx.fillStyle = "#2a0000";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.34, size * 0.14 + attackIntensity * 0.04, mouthOpen, 0, 0, Math.PI);
  ctx.fill();

  // Tongue
  ctx.fillStyle = "#cc4466";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.32 + mouthOpen * 0.4, size * 0.08, size * 0.04, 0, 0, Math.PI * 2);
  ctx.fill();

  // === MASSIVE FANGS ===
  ctx.fillStyle = "#fffff8";
  // Left fang
  ctx.beginPath();
  ctx.moveTo(x - size * 0.1, y - size * 0.4);
  ctx.lineTo(x - size * 0.06, y - size * 0.26 + attackIntensity * size * 0.04);
  ctx.lineTo(x - size * 0.02, y - size * 0.4);
  ctx.closePath();
  ctx.fill();
  // Right fang
  ctx.beginPath();
  ctx.moveTo(x + size * 0.1, y - size * 0.4);
  ctx.lineTo(x + size * 0.06, y - size * 0.26 + attackIntensity * size * 0.04);
  ctx.lineTo(x + size * 0.02, y - size * 0.4);
  ctx.closePath();
  ctx.fill();
  // Fang highlights
  ctx.strokeStyle = "rgba(200, 200, 200, 0.4)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.08, y - size * 0.38);
  ctx.lineTo(x - size * 0.06, y - size * 0.28);
  ctx.moveTo(x + size * 0.08, y - size * 0.38);
  ctx.lineTo(x + size * 0.06, y - size * 0.28);
  ctx.stroke();

  ctx.restore();

  // === BATTLE ROAR EFFECT ===
  if (isAttacking && attackPhase > 0.15 && attackPhase < 0.65) {
    const roarProgress = (attackPhase - 0.15) / 0.5;
    const roarAlpha = Math.sin(roarProgress * Math.PI) * 0.6;
    for (let w = 0; w < 4; w++) {
      const waveRadius = size * 0.4 + w * size * 0.2 * roarProgress;
      ctx.strokeStyle = w % 2 === 0
        ? `rgba(255, 150, 0, ${roarAlpha * (1 - w * 0.2)})`
        : `rgba(255, 80, 0, ${roarAlpha * (1 - w * 0.2)})`;
      ctx.lineWidth = (4 - w * 0.8) * zoom;
      ctx.beginPath();
      ctx.arc(x, y - size * 0.45, waveRadius, -0.9, 0.9);
      ctx.stroke();
    }
  }

}

function drawTenorHero(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // GRAND ORNATE TENOR - Triangle Club Opera Master with devastating voice attacks
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const singWave = Math.sin(time * 3) * 3;
  const breathe = Math.sin(time * 2) * 1.5;
  const gemPulse = Math.sin(time * 2.5) * 0.3 + 0.7;

  // === MULTI-LAYERED SONIC AURA ===
  const auraBase = isAttacking ? 0.4 : 0.2;
  const auraPulse = 0.85 + Math.sin(time * 3.5) * 0.15;
  for (let auraLayer = 0; auraLayer < 4; auraLayer++) {
    const layerOffset = auraLayer * 0.1;
    const auraGrad = ctx.createRadialGradient(
      x, y - size * 0.2, size * (0.1 + layerOffset),
      x, y - size * 0.2, size * (0.95 + layerOffset * 0.3)
    );
    const layerAlpha = (auraBase - auraLayer * 0.04) * auraPulse;
    auraGrad.addColorStop(0, `rgba(147, 112, 219, ${layerAlpha * 0.5})`);
    auraGrad.addColorStop(0.4, `rgba(180, 150, 235, ${layerAlpha * 0.35})`);
    auraGrad.addColorStop(0.7, `rgba(255, 102, 0, ${layerAlpha * 0.2})`);
    auraGrad.addColorStop(1, "rgba(147, 112, 219, 0)");
    ctx.fillStyle = auraGrad;
    ctx.beginPath();
    ctx.ellipse(x, y - size * 0.2, size * (0.9 + layerOffset * 0.2), size * (0.65 + layerOffset * 0.15), 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Floating musical particles
  for (let p = 0; p < 10; p++) {
    const pAngle = (time * 1.8 + p * Math.PI * 0.2) % (Math.PI * 2);
    const pDist = size * 0.6 + Math.sin(time * 2.5 + p * 0.7) * size * 0.12;
    const px = x + Math.cos(pAngle) * pDist;
    const py = y - size * 0.2 + Math.sin(pAngle) * pDist * 0.5;
    const pAlpha = 0.55 + Math.sin(time * 4 + p * 0.6) * 0.3;
    ctx.fillStyle = p % 2 === 0 ? `rgba(147, 112, 219, ${pAlpha})` : `rgba(255, 102, 0, ${pAlpha})`;
    ctx.beginPath();
    ctx.arc(px, py, size * 0.02, 0, Math.PI * 2);
    ctx.fill();
  }

  // === SONIC SHOCKWAVE RINGS (during attack) ===
  if (isAttacking) {
    for (let ring = 0; ring < 5; ring++) {
      const ringPhase = (attackPhase * 2.5 + ring * 0.12) % 1;
      const ringAlpha = (1 - ringPhase) * 0.6 * attackIntensity;
      // Outer ring
      ctx.strokeStyle = `rgba(147, 112, 219, ${ringAlpha})`;
      ctx.lineWidth = (4 - ring * 0.6) * zoom;
      ctx.beginPath();
      ctx.ellipse(x, y - size * 0.25, size * (0.55 + ringPhase * 0.9), size * (0.42 + ringPhase * 0.7), 0, 0, Math.PI * 2);
      ctx.stroke();
      // Inner bright ring
      ctx.strokeStyle = `rgba(255, 200, 255, ${ringAlpha * 0.4})`;
      ctx.lineWidth = (2 - ring * 0.3) * zoom;
      ctx.stroke();
    }
  }

  // === SHADOW WITH DEPTH ===
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.52, 0, x, y + size * 0.52, size * 0.45);
  shadowGrad.addColorStop(0, "rgba(0, 0, 0, 0.5)");
  shadowGrad.addColorStop(0.6, "rgba(0, 0, 0, 0.25)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.52, size * 0.42, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  // === ELEGANT FORMAL TUXEDO ===
  // Tuxedo jacket main body
  const tuxGrad = ctx.createLinearGradient(x - size * 0.4, y - size * 0.3, x + size * 0.4, y + size * 0.4);
  tuxGrad.addColorStop(0, "#050508");
  tuxGrad.addColorStop(0.15, "#151518");
  tuxGrad.addColorStop(0.35, "#202025");
  tuxGrad.addColorStop(0.5, "#282830");
  tuxGrad.addColorStop(0.65, "#202025");
  tuxGrad.addColorStop(0.85, "#151518");
  tuxGrad.addColorStop(1, "#050508");
  ctx.fillStyle = tuxGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.4, y + size * 0.52 + breathe);
  ctx.lineTo(x - size * 0.45, y - size * 0.14);
  ctx.lineTo(x - size * 0.35, y - size * 0.28);
  ctx.quadraticCurveTo(x, y - size * 0.38, x + size * 0.35, y - size * 0.28);
  ctx.lineTo(x + size * 0.45, y - size * 0.14);
  ctx.lineTo(x + size * 0.4, y + size * 0.52 + breathe);
  ctx.closePath();
  ctx.fill();

  // Tuxedo edge highlight
  ctx.strokeStyle = "#3a3a40";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.38, y + size * 0.5 + breathe);
  ctx.lineTo(x - size * 0.43, y - size * 0.12);
  ctx.lineTo(x - size * 0.33, y - size * 0.26);
  ctx.stroke();

  // Satin lapels
  const lapelGrad = ctx.createLinearGradient(x - size * 0.3, y - size * 0.25, x, y + size * 0.1);
  lapelGrad.addColorStop(0, "#1a1a20");
  lapelGrad.addColorStop(0.5, "#303038");
  lapelGrad.addColorStop(1, "#1a1a20");
  ctx.fillStyle = lapelGrad;
  // Left lapel
  ctx.beginPath();
  ctx.moveTo(x - size * 0.35, y - size * 0.26);
  ctx.lineTo(x - size * 0.16, y - size * 0.22);
  ctx.lineTo(x - size * 0.18, y + size * 0.15);
  ctx.lineTo(x - size * 0.35, y + size * 0.05);
  ctx.closePath();
  ctx.fill();
  // Right lapel
  ctx.beginPath();
  ctx.moveTo(x + size * 0.35, y - size * 0.26);
  ctx.lineTo(x + size * 0.16, y - size * 0.22);
  ctx.lineTo(x + size * 0.18, y + size * 0.15);
  ctx.lineTo(x + size * 0.35, y + size * 0.05);
  ctx.closePath();
  ctx.fill();

  // Lapel borders
  ctx.strokeStyle = "#404048";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.16, y - size * 0.22);
  ctx.lineTo(x - size * 0.18, y + size * 0.15);
  ctx.moveTo(x + size * 0.16, y - size * 0.22);
  ctx.lineTo(x + size * 0.18, y + size * 0.15);
  ctx.stroke();

  // Elegant tuxedo tails
  const tailWave = Math.sin(time * 2.5) * 0.08;
  ctx.fillStyle = "#101015";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.28, y + size * 0.35);
  ctx.bezierCurveTo(
    x - size * 0.38 - tailWave * size, y + size * 0.52,
    x - size * 0.35 - tailWave * size, y + size * 0.68,
    x - size * 0.3, y + size * 0.72
  );
  ctx.lineTo(x - size * 0.2, y + size * 0.58);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.28, y + size * 0.35);
  ctx.bezierCurveTo(
    x + size * 0.38 + tailWave * size, y + size * 0.52,
    x + size * 0.35 + tailWave * size, y + size * 0.68,
    x + size * 0.3, y + size * 0.72
  );
  ctx.lineTo(x + size * 0.2, y + size * 0.58);
  ctx.closePath();
  ctx.fill();

  // Gold buttons
  ctx.fillStyle = "#c9a227";
  for (let btn = 0; btn < 3; btn++) {
  ctx.beginPath();
    ctx.arc(x - size * 0.2, y + size * 0.02 + btn * size * 0.12, size * 0.025, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#f0c040";
    ctx.beginPath();
    ctx.arc(x - size * 0.2 - size * 0.005, y + size * 0.015 + btn * size * 0.12, size * 0.01, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#c9a227";
  }

  // === DRAMATIC OPERA ARMS ===
  // Arm animation: idle = relaxed at sides, attacking = raised dramatically for opera singing
  const armRaiseLeft = isAttacking ? Math.sin(attackPhase * Math.PI) * 0.8 : Math.sin(time * 1.5) * 0.1;
  const armRaiseRight = isAttacking ? Math.sin(attackPhase * Math.PI + 0.3) * 0.9 : Math.sin(time * 1.5 + 0.5) * 0.1;
  
  // Left arm (conducting arm - more dramatic)
  ctx.save();
  ctx.translate(x - size * 0.42, y - size * 0.1);
  ctx.rotate(-0.3 - armRaiseLeft * 1.2);
  
  // Left sleeve (tuxedo)
  const leftSleeveGrad = ctx.createLinearGradient(0, 0, size * 0.15, size * 0.35);
  leftSleeveGrad.addColorStop(0, "#151518");
  leftSleeveGrad.addColorStop(0.5, "#252528");
  leftSleeveGrad.addColorStop(1, "#101012");
  ctx.fillStyle = leftSleeveGrad;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.quadraticCurveTo(size * 0.08, size * 0.15, size * 0.05, size * 0.32);
  ctx.lineTo(-size * 0.08, size * 0.3);
  ctx.quadraticCurveTo(-size * 0.1, size * 0.15, 0, 0);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "#3a3a40";
  ctx.lineWidth = 1;
  ctx.stroke();
  
  // Left cuff (white)
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.ellipse(-size * 0.015, size * 0.31, size * 0.07, size * 0.025, -0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = "#e0e0e0";
  ctx.lineWidth = 0.8;
  ctx.stroke();
  
  // Left hand
  ctx.fillStyle = "#ffe0bd";
  ctx.beginPath();
  ctx.ellipse(-size * 0.01, size * 0.37, size * 0.045, size * 0.06, -0.15, 0, Math.PI * 2);
  ctx.fill();
  // Fingers spread dramatically during attack
  if (isAttacking) {
    ctx.strokeStyle = "#f5d0a8";
    ctx.lineWidth = 3 * zoom;
    ctx.lineCap = "round";
    for (let f = 0; f < 5; f++) {
      const fingerAngle = -0.6 + f * 0.3;
      const fingerLen = size * (0.04 + (f === 2 ? 0.015 : 0));
      ctx.beginPath();
      ctx.moveTo(-size * 0.01 + Math.cos(fingerAngle) * size * 0.03, size * 0.37 + Math.sin(fingerAngle) * size * 0.045);
      ctx.lineTo(-size * 0.01 + Math.cos(fingerAngle) * (size * 0.03 + fingerLen), size * 0.37 + Math.sin(fingerAngle) * (size * 0.045 + fingerLen * 0.6));
      ctx.stroke();
    }
  }
  ctx.restore();
  
  // Right arm (supporting arm)
  ctx.save();
  ctx.translate(x + size * 0.42, y - size * 0.1);
  ctx.rotate(0.3 + armRaiseRight * 1.0);
  
  // Right sleeve (tuxedo)
  const rightSleeveGrad = ctx.createLinearGradient(0, 0, -size * 0.15, size * 0.35);
  rightSleeveGrad.addColorStop(0, "#151518");
  rightSleeveGrad.addColorStop(0.5, "#252528");
  rightSleeveGrad.addColorStop(1, "#101012");
  ctx.fillStyle = rightSleeveGrad;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.quadraticCurveTo(-size * 0.08, size * 0.15, -size * 0.05, size * 0.32);
  ctx.lineTo(size * 0.08, size * 0.3);
  ctx.quadraticCurveTo(size * 0.1, size * 0.15, 0, 0);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "#3a3a40";
  ctx.lineWidth = 1;
  ctx.stroke();
  
  // Right cuff (white)
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.ellipse(size * 0.015, size * 0.31, size * 0.07, size * 0.025, 0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = "#e0e0e0";
  ctx.lineWidth = 0.8;
  ctx.stroke();
  
  // Right hand (cupped gesture for opera)
  ctx.fillStyle = "#ffe0bd";
  ctx.beginPath();
  ctx.ellipse(size * 0.01, size * 0.37, size * 0.045, size * 0.06, 0.15, 0, Math.PI * 2);
  ctx.fill();
  // Fingers together, cupped during attack
  if (isAttacking) {
    ctx.strokeStyle = "#f5d0a8";
    ctx.lineWidth = 2.5 * zoom;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.arc(size * 0.01, size * 0.4, size * 0.035, 0.3 * Math.PI, 0.7 * Math.PI);
    ctx.stroke();
  }
  ctx.restore();

  // Pocket square (orange silk)
  const pocketGrad = ctx.createLinearGradient(x - size * 0.32, y - size * 0.1, x - size * 0.24, y - size * 0.05);
  pocketGrad.addColorStop(0, "#ff6600");
  pocketGrad.addColorStop(0.5, "#ff8833");
  pocketGrad.addColorStop(1, "#ff6600");
  ctx.fillStyle = pocketGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.32, y - size * 0.1);
  ctx.lineTo(x - size * 0.28, y - size * 0.15);
  ctx.lineTo(x - size * 0.24, y - size * 0.08);
  ctx.lineTo(x - size * 0.26, y - size * 0.04);
  ctx.closePath();
  ctx.fill();

  // === PRISTINE WHITE SHIRT WITH RUFFLES ===
  const shirtGrad = ctx.createLinearGradient(x - size * 0.15, y - size * 0.2, x + size * 0.15, y + size * 0.3);
  shirtGrad.addColorStop(0, "#ffffff");
  shirtGrad.addColorStop(0.5, "#f8f8f8");
  shirtGrad.addColorStop(1, "#f0f0f0");
  ctx.fillStyle = shirtGrad;
    ctx.beginPath();
  ctx.moveTo(x - size * 0.15, y - size * 0.24);
  ctx.lineTo(x - size * 0.12, y + size * 0.38);
  ctx.lineTo(x + size * 0.12, y + size * 0.38);
  ctx.lineTo(x + size * 0.15, y - size * 0.24);
  ctx.closePath();
  ctx.fill();

  // Elaborate ruffle details
  ctx.strokeStyle = "#e0e0e0";
  ctx.lineWidth = 1.2 * zoom;
  for (let i = 0; i < 5; i++) {
    const ruffY = y - size * 0.12 + i * size * 0.09;
    ctx.beginPath();
    ctx.moveTo(x - size * 0.1, ruffY);
    ctx.quadraticCurveTo(x - size * 0.03, ruffY + size * 0.025, x, ruffY);
    ctx.quadraticCurveTo(x + size * 0.03, ruffY + size * 0.025, x + size * 0.1, ruffY);
    ctx.stroke();
  }

  // === ORNATE ORANGE BOW TIE ===
  const bowGlow = isAttacking ? 0.6 + attackIntensity * 0.4 : 0;
  if (bowGlow > 0) {
    ctx.shadowColor = "#ff6600";
    ctx.shadowBlur = 12 * zoom * attackIntensity;
  }
  // Left bow
  const bowGrad = ctx.createLinearGradient(x - size * 0.14, y - size * 0.2, x, y - size * 0.16);
  bowGrad.addColorStop(0, "#cc4400");
  bowGrad.addColorStop(0.5, "#ff6600");
  bowGrad.addColorStop(1, "#ff8833");
  ctx.fillStyle = bowGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.02, y - size * 0.19);
  ctx.quadraticCurveTo(x - size * 0.08, y - size * 0.26, x - size * 0.14, y - size * 0.24);
  ctx.quadraticCurveTo(x - size * 0.16, y - size * 0.18, x - size * 0.14, y - size * 0.12);
  ctx.quadraticCurveTo(x - size * 0.08, y - size * 0.1, x - size * 0.02, y - size * 0.17);
  ctx.closePath();
  ctx.fill();
  // Right bow
  ctx.beginPath();
  ctx.moveTo(x + size * 0.02, y - size * 0.19);
  ctx.quadraticCurveTo(x + size * 0.08, y - size * 0.26, x + size * 0.14, y - size * 0.24);
  ctx.quadraticCurveTo(x + size * 0.16, y - size * 0.18, x + size * 0.14, y - size * 0.12);
  ctx.quadraticCurveTo(x + size * 0.08, y - size * 0.1, x + size * 0.02, y - size * 0.17);
  ctx.closePath();
  ctx.fill();
  // Bow center knot
  ctx.fillStyle = "#cc4400";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.18, size * 0.035, size * 0.04, 0, 0, Math.PI * 2);
  ctx.fill();
  // Bow gem
  ctx.fillStyle = "#ff9944";
  ctx.shadowColor = "#ffaa00";
  ctx.shadowBlur = isAttacking ? 6 * zoom * gemPulse : 3 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.18, size * 0.018, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // === DRAMATIC OPERA HEAD ===
  const headY = y - size * 0.48 + singWave * 0.2 + breathe * 0.1;
  
  // Head with subtle skin gradient
  const skinGrad = ctx.createRadialGradient(x - size * 0.05, headY - size * 0.05, 0, x, headY, size * 0.28);
  skinGrad.addColorStop(0, "#ffe8d0");
  skinGrad.addColorStop(0.6, "#ffe0bd");
  skinGrad.addColorStop(1, "#f5d0a8");
  ctx.fillStyle = skinGrad;
  ctx.beginPath();
  ctx.arc(x, headY, size * 0.28, 0, Math.PI * 2);
  ctx.fill();

  // Cheekbone highlights
  ctx.fillStyle = "rgba(255, 200, 180, 0.3)";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.12, headY + size * 0.02, size * 0.06, size * 0.04, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x + size * 0.12, headY + size * 0.02, size * 0.06, size * 0.04, 0.3, 0, Math.PI * 2);
  ctx.fill();

  // === ELABORATE SLICKED HAIR ===
  const hairGrad = ctx.createLinearGradient(x - size * 0.25, headY - size * 0.2, x + size * 0.25, headY - size * 0.3);
  hairGrad.addColorStop(0, "#0a0500");
  hairGrad.addColorStop(0.3, "#1a0a00");
  hairGrad.addColorStop(0.5, "#2a1505");
  hairGrad.addColorStop(0.7, "#1a0a00");
  hairGrad.addColorStop(1, "#0a0500");
  ctx.fillStyle = hairGrad;
  
  // Main hair shape
  ctx.beginPath();
  ctx.moveTo(x - size * 0.25, headY - size * 0.06);
  ctx.quadraticCurveTo(x - size * 0.32, headY - size * 0.25, x - size * 0.15, headY - size * 0.32);
  ctx.quadraticCurveTo(x, headY - size * 0.35, x + size * 0.15, headY - size * 0.32);
  ctx.quadraticCurveTo(x + size * 0.32, headY - size * 0.25, x + size * 0.25, headY - size * 0.06);
  ctx.closePath();
  ctx.fill();

  // Hair wave crest
  ctx.beginPath();
  ctx.moveTo(x - size * 0.22, headY - size * 0.08);
  ctx.bezierCurveTo(
    x - size * 0.35, headY - size * 0.3,
    x - size * 0.1, headY - size * 0.38,
    x, headY - size * 0.35
  );
  ctx.bezierCurveTo(
    x + size * 0.1, headY - size * 0.38,
    x + size * 0.35, headY - size * 0.3,
    x + size * 0.22, headY - size * 0.08
  );
  ctx.fill();

  // Hair highlights
  ctx.strokeStyle = "#3a2010";
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.5;
  for (let strand = 0; strand < 5; strand++) {
    const strandX = x - size * 0.15 + strand * size * 0.075;
    ctx.beginPath();
    ctx.moveTo(strandX, headY - size * 0.1);
    ctx.quadraticCurveTo(strandX - size * 0.02, headY - size * 0.22, strandX + size * 0.01, headY - size * 0.32);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // === DRAMATIC OPERA EYES ===
  if (isAttacking) {
    // Glowing closed eyes during attack
    ctx.fillStyle = `rgba(147, 112, 219, ${0.6 + attackIntensity * 0.4})`;
    ctx.shadowColor = "#9370db";
    ctx.shadowBlur = 8 * zoom;
    ctx.beginPath();
    ctx.ellipse(x - size * 0.1, headY + size * 0.01, size * 0.05, size * 0.015, -0.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x + size * 0.1, headY + size * 0.01, size * 0.05, size * 0.015, 0.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  } else {
    // Dramatic closed eyes (operatic expression)
    ctx.strokeStyle = "#1a0a00";
    ctx.lineWidth = 2.5 * zoom;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.arc(x - size * 0.1, headY + size * 0.01, size * 0.055, 0.15 * Math.PI, 0.85 * Math.PI);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(x + size * 0.1, headY + size * 0.01, size * 0.055, 0.15 * Math.PI, 0.85 * Math.PI);
    ctx.stroke();
    // Eyelashes
    ctx.lineWidth = 1.5 * zoom;
    for (let lash = 0; lash < 3; lash++) {
      const lashAngle = 0.3 + lash * 0.25;
      ctx.beginPath();
      ctx.moveTo(x - size * 0.1 + Math.cos(lashAngle) * size * 0.055, headY + size * 0.01 - Math.sin(lashAngle) * size * 0.055);
      ctx.lineTo(x - size * 0.1 + Math.cos(lashAngle) * size * 0.08, headY + size * 0.01 - Math.sin(lashAngle) * size * 0.08);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x + size * 0.1 - Math.cos(lashAngle) * size * 0.055, headY + size * 0.01 - Math.sin(lashAngle) * size * 0.055);
      ctx.lineTo(x + size * 0.1 - Math.cos(lashAngle) * size * 0.08, headY + size * 0.01 - Math.sin(lashAngle) * size * 0.08);
    ctx.stroke();
    }
  }

  // Dramatic eyebrows
  ctx.strokeStyle = "#1a0a00";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.16, headY - size * 0.06);
  ctx.quadraticCurveTo(x - size * 0.1, headY - size * 0.1 - (isAttacking ? size * 0.02 : 0), x - size * 0.04, headY - size * 0.05);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.16, headY - size * 0.06);
  ctx.quadraticCurveTo(x + size * 0.1, headY - size * 0.1 - (isAttacking ? size * 0.02 : 0), x + size * 0.04, headY - size * 0.05);
  ctx.stroke();

  // === POWERFUL SINGING MOUTH ===
  const mouthOpen = isAttacking ? 0.16 + attackIntensity * 0.1 : 0.12;
  const mouthY = headY + size * 0.12;

  // Mouth interior (dark)
  ctx.fillStyle = "#2a0a0a";
  ctx.beginPath();
  ctx.ellipse(x, mouthY, size * 0.1, size * mouthOpen, 0, 0, Math.PI * 2);
  ctx.fill();

  // Tongue (subtle)
  ctx.fillStyle = "#8a3030";
  ctx.beginPath();
  ctx.ellipse(x, mouthY + size * 0.03, size * 0.06, size * 0.03, 0, 0, Math.PI * 2);
  ctx.fill();

  // Teeth row
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.rect(x - size * 0.07, mouthY - size * mouthOpen * 0.6, size * 0.14, size * 0.03);
  ctx.fill();
  // Individual teeth lines
  ctx.strokeStyle = "#e8e8e8";
  ctx.lineWidth = 0.5;
  for (let tooth = -2; tooth <= 2; tooth++) {
    ctx.beginPath();
    ctx.moveTo(x + tooth * size * 0.025, mouthY - size * mouthOpen * 0.6);
    ctx.lineTo(x + tooth * size * 0.025, mouthY - size * mouthOpen * 0.6 + size * 0.03);
    ctx.stroke();
  }

  // Lips
  ctx.strokeStyle = "#a06060";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.ellipse(x, mouthY, size * 0.11, size * mouthOpen + size * 0.01, 0, 0, Math.PI * 2);
  ctx.stroke();

  // === FLOATING MUSICAL NOTES (elaborate) ===
  const noteCount = isAttacking ? 10 : 5;
  for (let i = 0; i < noteCount; i++) {
    const notePhase = (time * 2.2 + i * 0.4) % 2;
    const noteAngle = -0.6 + (i / noteCount) * 1.2;
    const noteSpiral = Math.sin(notePhase * Math.PI * 2) * size * 0.1;
    const noteX = x + size * (0.35 + notePhase * 0.6) * Math.cos(noteAngle) + noteSpiral;
    const noteY = y - size * 0.3 - notePhase * size * 0.7 + Math.sin(notePhase * Math.PI * 1.5) * size * 0.15;
    const noteAlpha = (1 - notePhase / 2) * (isAttacking ? 0.95 : 0.75);
    const noteSize = (16 + (isAttacking ? 6 : 0) - notePhase * 4) * zoom;

    // Note glow
    ctx.shadowColor = i % 2 === 0 ? "#ff6600" : "#9370db";
    ctx.shadowBlur = isAttacking ? 10 * zoom : 5 * zoom;

    ctx.fillStyle = i % 2 === 0 ? `rgba(255, 102, 0, ${noteAlpha})` : `rgba(147, 112, 219, ${noteAlpha})`;
    ctx.font = `${noteSize}px Arial`;
    ctx.textAlign = "center";
    const noteSymbol = i % 4 === 0 ? "" : i % 4 === 1 ? "" : i % 4 === 2 ? "" : "";
    ctx.fillText(noteSymbol, noteX, noteY);
  }
  ctx.shadowBlur = 0;

  // === SOUND WAVE STAFF LINES ===
  ctx.globalAlpha = isAttacking ? 0.6 : 0.3;
  ctx.strokeStyle = "#9370db";
  ctx.lineWidth = 1.5 * zoom;
  for (let staff = 0; staff < 3; staff++) {
    const staffY = y - size * 0.7 - staff * size * 0.08;
    const staffWave = Math.sin(time * 5 + staff * 0.5) * size * 0.03;
    ctx.beginPath();
    ctx.moveTo(x - size * 0.6, staffY + staffWave);
    for (let point = 0; point <= 20; point++) {
      const px = x - size * 0.6 + point * size * 0.06;
      const py = staffY + Math.sin(time * 6 + point * 0.3 + staff) * size * 0.02;
      ctx.lineTo(px, py);
    }
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // === ELABORATE SONIC AURA RINGS ===
  for (let i = 0; i < 4; i++) {
    const ringPhase = (time * 2.5 + i * 0.35) % 1;
    const ringRadius = size * (0.5 + ringPhase * 0.6);
    const ringAlpha = (1 - ringPhase) * (isAttacking ? 0.75 : 0.45);
    
    // Outer ring
    ctx.strokeStyle = `rgba(147, 112, 219, ${ringAlpha})`;
    ctx.lineWidth = (3 - i * 0.4) * zoom;
    ctx.beginPath();
    ctx.ellipse(x, y - size * 0.2, ringRadius, ringRadius * 0.55, 0, 0, Math.PI * 2);
    ctx.stroke();
    
    // Inner golden ring
    ctx.strokeStyle = `rgba(255, 150, 50, ${ringAlpha * 0.5})`;
    ctx.lineWidth = (1.5 - i * 0.2) * zoom;
    ctx.beginPath();
    ctx.ellipse(x, y - size * 0.2, ringRadius * 0.95, ringRadius * 0.52, 0, 0, Math.PI * 2);
    ctx.stroke();
  }

  // === SPOTLIGHT EFFECT ===
  if (isAttacking) {
    const spotGrad = ctx.createRadialGradient(x, y - size * 0.5, 0, x, y, size * 1.2);
    spotGrad.addColorStop(0, `rgba(255, 255, 200, ${attackIntensity * 0.15})`);
    spotGrad.addColorStop(0.5, `rgba(255, 220, 150, ${attackIntensity * 0.08})`);
    spotGrad.addColorStop(1, "rgba(255, 200, 100, 0)");
    ctx.fillStyle = spotGrad;
    ctx.beginPath();
    ctx.ellipse(x, y - size * 0.2, size * 1.2, size * 0.9, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawMatheyKnightHero(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // COLOSSAL JUGGERNAUT KNIGHT - Massive heavily armored warrior with devastating war hammer
  const isAttacking = attackPhase > 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const heavyStance = Math.sin(time * 1.5) * 1.5; // Slower, heavier movement
  const breathe = Math.sin(time * 1.8) * 1.5;
  const gemPulse = Math.sin(time * 2) * 0.3 + 0.7;

  // === MULTI-LAYERED FROST/STEEL AURA ===
  const auraIntensity = isAttacking ? 0.55 : 0.28;
  const auraPulse = 0.85 + Math.sin(time * 2.5) * 0.15;
  for (let auraLayer = 0; auraLayer < 4; auraLayer++) {
    const layerOffset = auraLayer * 0.1;
    const auraGrad = ctx.createRadialGradient(
      x, y, size * (0.12 + layerOffset),
      x, y, size * (1.0 + layerOffset * 0.3)
    );
    auraGrad.addColorStop(0, `rgba(100, 180, 255, ${auraIntensity * auraPulse * (0.45 - auraLayer * 0.1)})`);
    auraGrad.addColorStop(0.4, `rgba(150, 200, 255, ${auraIntensity * auraPulse * (0.3 - auraLayer * 0.06)})`);
    auraGrad.addColorStop(0.7, `rgba(200, 220, 255, ${auraIntensity * auraPulse * (0.15 - auraLayer * 0.03)})`);
    auraGrad.addColorStop(1, "rgba(100, 180, 255, 0)");
    ctx.fillStyle = auraGrad;
    ctx.beginPath();
    ctx.ellipse(x, y, size * (0.95 + layerOffset * 0.2), size * (0.65 + layerOffset * 0.15), 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Floating frost/steel particles
  for (let p = 0; p < 12; p++) {
    const pAngle = (time * 0.8 + p * Math.PI * 0.167) % (Math.PI * 2);
    const pDist = size * 0.7 + Math.sin(time * 1.5 + p * 0.6) * size * 0.12;
    const px = x + Math.cos(pAngle) * pDist;
    const py = y + Math.sin(pAngle) * pDist * 0.5;
    const pAlpha = 0.55 + Math.sin(time * 3 + p * 0.4) * 0.3;
    // Ice crystal particle
    ctx.fillStyle = p % 3 === 0 ? `rgba(200, 230, 255, ${pAlpha})` : `rgba(100, 180, 255, ${pAlpha})`;
    ctx.beginPath();
    ctx.save();
    ctx.translate(px, py);
    ctx.rotate(time * 2 + p);
    // Diamond shape
    ctx.moveTo(0, -size * 0.025);
    ctx.lineTo(size * 0.015, 0);
    ctx.lineTo(0, size * 0.025);
    ctx.lineTo(-size * 0.015, 0);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // === DEEP SHADOW ===
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.55, 0, x, y + size * 0.55, size * 0.6);
  shadowGrad.addColorStop(0, "rgba(0, 0, 0, 0.6)");
  shadowGrad.addColorStop(0.5, "rgba(0, 0, 0, 0.4)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.55, size * 0.6, size * 0.18, 0, 0, Math.PI * 2);
  ctx.fill();

  // === MASSIVE BULKY PLATE ARMOR BODY ===
  // This knight is significantly wider and heavier
  const armorGrad = ctx.createLinearGradient(x - size * 0.55, y - size * 0.35, x + size * 0.55, y + size * 0.45);
  armorGrad.addColorStop(0, "#252535");
  armorGrad.addColorStop(0.1, "#404058");
  armorGrad.addColorStop(0.25, "#505070");
  armorGrad.addColorStop(0.4, "#606088");
  armorGrad.addColorStop(0.5, "#707098");
  armorGrad.addColorStop(0.6, "#606088");
  armorGrad.addColorStop(0.75, "#505070");
  armorGrad.addColorStop(0.9, "#404058");
  armorGrad.addColorStop(1, "#252535");
  ctx.fillStyle = armorGrad;
  ctx.beginPath();
  // Much wider, bulkier body shape
  ctx.moveTo(x - size * 0.52, y + size * 0.55 + breathe);
  ctx.lineTo(x - size * 0.58, y + size * 0.1);
  ctx.lineTo(x - size * 0.55, y - size * 0.15);
  ctx.lineTo(x - size * 0.4, y - size * 0.32);
  ctx.quadraticCurveTo(x, y - size * 0.42, x + size * 0.4, y - size * 0.32);
  ctx.lineTo(x + size * 0.55, y - size * 0.15);
  ctx.lineTo(x + size * 0.58, y + size * 0.1);
  ctx.lineTo(x + size * 0.52, y + size * 0.55 + breathe);
  ctx.closePath();
  ctx.fill();

  // Armor edge highlight (left side)
  ctx.strokeStyle = "#8888aa";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.5, y + size * 0.53 + breathe);
  ctx.lineTo(x - size * 0.56, y + size * 0.08);
  ctx.lineTo(x - size * 0.53, y - size * 0.13);
  ctx.lineTo(x - size * 0.38, y - size * 0.3);
  ctx.stroke();

  // Armor border
  ctx.strokeStyle = "#151525";
  ctx.lineWidth = 3 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.52, y + size * 0.55 + breathe);
  ctx.lineTo(x - size * 0.58, y + size * 0.1);
  ctx.lineTo(x - size * 0.55, y - size * 0.15);
  ctx.lineTo(x - size * 0.4, y - size * 0.32);
  ctx.quadraticCurveTo(x, y - size * 0.42, x + size * 0.4, y - size * 0.32);
  ctx.lineTo(x + size * 0.55, y - size * 0.15);
  ctx.lineTo(x + size * 0.58, y + size * 0.1);
  ctx.lineTo(x + size * 0.52, y + size * 0.55 + breathe);
  ctx.closePath();
  ctx.stroke();

  // Heavy armor plate segments
  ctx.strokeStyle = "#303048";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  // Horizontal segments
  ctx.moveTo(x - size * 0.48, y - size * 0.08);
  ctx.lineTo(x + size * 0.48, y - size * 0.08);
  ctx.moveTo(x - size * 0.46, y + size * 0.12);
  ctx.lineTo(x + size * 0.46, y + size * 0.12);
  ctx.moveTo(x - size * 0.44, y + size * 0.32);
  ctx.lineTo(x + size * 0.44, y + size * 0.32);
  // Center vertical line
  ctx.moveTo(x, y - size * 0.32);
  ctx.lineTo(x, y + size * 0.52);
  ctx.stroke();

  // Ice blue filigree patterns on armor
  ctx.strokeStyle = "#80c0ff";
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.6;
  // Left ornate pattern
  ctx.beginPath();
  ctx.moveTo(x - size * 0.38, y - size * 0.2);
  ctx.quadraticCurveTo(x - size * 0.45, y - size * 0.05, x - size * 0.38, y + size * 0.08);
  ctx.quadraticCurveTo(x - size * 0.32, y + size * 0.15, x - size * 0.38, y + size * 0.25);
  ctx.stroke();
  // Right ornate pattern
  ctx.beginPath();
  ctx.moveTo(x + size * 0.38, y - size * 0.2);
  ctx.quadraticCurveTo(x + size * 0.45, y - size * 0.05, x + size * 0.38, y + size * 0.08);
  ctx.quadraticCurveTo(x + size * 0.32, y + size * 0.15, x + size * 0.38, y + size * 0.25);
  ctx.stroke();
  // Center frost rune pattern
  ctx.beginPath();
  ctx.moveTo(x - size * 0.15, y - size * 0.15);
  ctx.lineTo(x, y - size * 0.25);
  ctx.lineTo(x + size * 0.15, y - size * 0.15);
  ctx.moveTo(x - size * 0.1, y + size * 0.02);
  ctx.lineTo(x, y - size * 0.08);
  ctx.lineTo(x + size * 0.1, y + size * 0.02);
  ctx.stroke();
  ctx.globalAlpha = 1;

  // Heavy reinforced rivets in rows
  for (let row = 0; row < 4; row++) {
    for (let i = -3; i <= 3; i++) {
      if (i === 0) continue; // Skip center
      const rivetX = x + i * size * 0.12;
      const rivetY = y - size * 0.08 + row * size * 0.16;
      // Rivet base
      ctx.fillStyle = "#404058";
      ctx.beginPath();
      ctx.arc(rivetX, rivetY, size * 0.028, 0, Math.PI * 2);
      ctx.fill();
      // Rivet highlight
      ctx.fillStyle = "#707098";
      ctx.beginPath();
      ctx.arc(rivetX - size * 0.008, rivetY - size * 0.008, size * 0.012, 0, Math.PI * 2);
      ctx.fill();
      // Rivet border
      ctx.strokeStyle = "#252535";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(rivetX, rivetY, size * 0.028, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  // === MASSIVE MATHEY CREST ON CHEST ===
  if (isAttacking) {
    ctx.shadowColor = "#60a0ff";
    ctx.shadowBlur = 18 * zoom * attackIntensity;
  }
  // Crest outer hexagonal frame
  ctx.fillStyle = "#80c0ff";
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.28);
  ctx.lineTo(x - size * 0.18, y - size * 0.1);
  ctx.lineTo(x - size * 0.18, y + size * 0.12);
  ctx.lineTo(x, y + size * 0.28);
  ctx.lineTo(x + size * 0.18, y + size * 0.12);
  ctx.lineTo(x + size * 0.18, y - size * 0.1);
  ctx.closePath();
  ctx.fill();
  // Crest inner dark blue
  ctx.fillStyle = "#1a3050";
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.22);
  ctx.lineTo(x - size * 0.14, y - size * 0.06);
  ctx.lineTo(x - size * 0.14, y + size * 0.08);
  ctx.lineTo(x, y + size * 0.22);
  ctx.lineTo(x + size * 0.14, y + size * 0.08);
  ctx.lineTo(x + size * 0.14, y - size * 0.06);
  ctx.closePath();
  ctx.fill();
  // Frost gem in center
  ctx.fillStyle = "#40a0ff";
  ctx.shadowColor = "#60c0ff";
  ctx.shadowBlur = isAttacking ? 12 * zoom * gemPulse : 6 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.04, 0, Math.PI * 2);
  ctx.fill();
  // Inner gem glow
  ctx.fillStyle = "#a0e0ff";
  ctx.beginPath();
  ctx.arc(x, y - size * 0.01, size * 0.02, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Crest "M" emblem with ice effect
  ctx.fillStyle = "#a0d0ff";
  ctx.font = `bold ${14 * zoom}px serif`;
  ctx.textAlign = "center";
  ctx.fillText("M", x, y + size * 0.14);

  // === COLOSSAL SHOULDER PAULDRONS ===
  for (let side = -1; side <= 1; side += 2) {
    const pauldronX = x + side * size * 0.62;
    
    // Massive pauldron base with gradient
    const pauldronGrad = ctx.createRadialGradient(pauldronX, y - size * 0.18, 0, pauldronX, y - size * 0.18, size * 0.3);
    pauldronGrad.addColorStop(0, "#707098");
    pauldronGrad.addColorStop(0.4, "#505070");
    pauldronGrad.addColorStop(0.7, "#404058");
    pauldronGrad.addColorStop(1, "#303048");
    ctx.fillStyle = pauldronGrad;
    ctx.beginPath();
    ctx.ellipse(pauldronX, y - size * 0.16, size * 0.28, size * 0.22, side * 0.35, 0, Math.PI * 2);
    ctx.fill();
    
    // Pauldron layered plates (3 layers for heavy look)
    for (let layer = 0; layer < 3; layer++) {
      const layerY = y - size * 0.1 + layer * size * 0.08;
      const layerWidth = size * (0.22 - layer * 0.04);
      const layerHeight = size * (0.14 - layer * 0.03);
      ctx.fillStyle = `rgb(${80 + layer * 15}, ${80 + layer * 15}, ${100 + layer * 15})`;
      ctx.beginPath();
      ctx.ellipse(pauldronX + side * size * 0.04, layerY, layerWidth, layerHeight, side * 0.25, 0, Math.PI * 2);
      ctx.fill();
      // Layer edge
      ctx.strokeStyle = "#252535";
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    
    // Ice blue trim
    ctx.strokeStyle = "#80c0ff";
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.ellipse(pauldronX, y - size * 0.16, size * 0.28, size * 0.22, side * 0.35, 0, Math.PI * 2);
    ctx.stroke();

    // Triple spike crown on each pauldron
    for (let spike = -1; spike <= 1; spike++) {
      const spikeX = pauldronX + side * size * 0.08 + spike * size * 0.08;
      const spikeLen = spike === 0 ? size * 0.35 : size * 0.25;
      ctx.fillStyle = "#404058";
      ctx.beginPath();
      ctx.moveTo(spikeX - size * 0.025, y - size * 0.28);
      ctx.lineTo(spikeX, y - size * 0.28 - spikeLen);
      ctx.lineTo(spikeX + size * 0.025, y - size * 0.28);
      ctx.closePath();
      ctx.fill();
      // Spike edge highlight
      ctx.strokeStyle = "#707098";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(spikeX - size * 0.02, y - size * 0.28);
      ctx.lineTo(spikeX, y - size * 0.28 - spikeLen + size * 0.02);
      ctx.stroke();
    }
    
    // Pauldron frost gem
    ctx.fillStyle = "#40a0ff";
    ctx.shadowColor = "#60c0ff";
    ctx.shadowBlur = 6 * zoom * gemPulse;
    ctx.beginPath();
    ctx.arc(pauldronX, y - size * 0.18, size * 0.035, 0, Math.PI * 2);
    ctx.fill();
    // Gem inner glow
    ctx.fillStyle = "#a0e0ff";
    ctx.beginPath();
    ctx.arc(pauldronX - size * 0.01, y - size * 0.19, size * 0.015, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // === HEAVY BARREL HELM ===
  // Different from Captain's - this is a brutal bucket helm
  const helmGrad = ctx.createRadialGradient(
    x - size * 0.06, y - size * 0.58, size * 0.06,
    x, y - size * 0.52, size * 0.42
  );
  helmGrad.addColorStop(0, "#707098");
  helmGrad.addColorStop(0.25, "#606080");
  helmGrad.addColorStop(0.5, "#505068");
  helmGrad.addColorStop(0.75, "#404050");
  helmGrad.addColorStop(1, "#303040");
  ctx.fillStyle = helmGrad;
  // Barrel helm shape (taller, more rectangular)
  ctx.beginPath();
  ctx.moveTo(x - size * 0.3, y - size * 0.3);
  ctx.lineTo(x - size * 0.32, y - size * 0.7);
  ctx.quadraticCurveTo(x - size * 0.32, y - size * 0.92, x, y - size * 0.95);
  ctx.quadraticCurveTo(x + size * 0.32, y - size * 0.92, x + size * 0.32, y - size * 0.7);
  ctx.lineTo(x + size * 0.3, y - size * 0.3);
  ctx.closePath();
  ctx.fill();

  // Helm reinforcement bands
  ctx.strokeStyle = "#404058";
  ctx.lineWidth = 3 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.31, y - size * 0.45);
  ctx.lineTo(x + size * 0.31, y - size * 0.45);
  ctx.moveTo(x - size * 0.32, y - size * 0.65);
  ctx.lineTo(x + size * 0.32, y - size * 0.65);
  ctx.stroke();

  // Center vertical reinforcement
  ctx.strokeStyle = "#505068";
  ctx.lineWidth = 4 * zoom;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.32);
  ctx.lineTo(x, y - size * 0.9);
  ctx.stroke();

  // Ice blue helm trim
  ctx.strokeStyle = "#80c0ff";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.3, y - size * 0.32);
  ctx.lineTo(x - size * 0.32, y - size * 0.7);
  ctx.quadraticCurveTo(x - size * 0.32, y - size * 0.9, x, y - size * 0.93);
  ctx.quadraticCurveTo(x + size * 0.32, y - size * 0.9, x + size * 0.32, y - size * 0.7);
  ctx.lineTo(x + size * 0.3, y - size * 0.32);
  ctx.stroke();

  // Helm border
  ctx.strokeStyle = "#151525";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.3, y - size * 0.3);
  ctx.lineTo(x - size * 0.32, y - size * 0.7);
  ctx.quadraticCurveTo(x - size * 0.32, y - size * 0.92, x, y - size * 0.95);
  ctx.quadraticCurveTo(x + size * 0.32, y - size * 0.92, x + size * 0.32, y - size * 0.7);
  ctx.lineTo(x + size * 0.3, y - size * 0.3);
  ctx.closePath();
  ctx.stroke();

  // T-Visor (brutal, intimidating)
  ctx.fillStyle = "#0a0a15";
  ctx.beginPath();
  // Horizontal slit
  ctx.moveTo(x - size * 0.26, y - size * 0.58);
  ctx.lineTo(x + size * 0.26, y - size * 0.58);
  ctx.lineTo(x + size * 0.26, y - size * 0.48);
  ctx.lineTo(x - size * 0.26, y - size * 0.48);
  ctx.closePath();
  ctx.fill();
  // Vertical slit (forms the T)
  ctx.beginPath();
  ctx.moveTo(x - size * 0.06, y - size * 0.48);
  ctx.lineTo(x + size * 0.06, y - size * 0.48);
  ctx.lineTo(x + size * 0.06, y - size * 0.35);
  ctx.lineTo(x - size * 0.06, y - size * 0.35);
  ctx.closePath();
  ctx.fill();

  // Glowing eyes in T-visor
  ctx.fillStyle = isAttacking
    ? `rgba(100, 200, 255, ${0.8 + attackIntensity * 0.2})`
    : "rgba(80, 160, 220, 0.6)";
  if (isAttacking) {
    ctx.shadowColor = "#60c0ff";
    ctx.shadowBlur = 10 * zoom;
  }
  // Left eye
  ctx.beginPath();
  ctx.arc(x - size * 0.12, y - size * 0.53, size * 0.04, 0, Math.PI * 2);
  ctx.fill();
  // Right eye
  ctx.beginPath();
  ctx.arc(x + size * 0.12, y - size * 0.53, size * 0.04, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Visor breathing holes
  ctx.fillStyle = "#0a0a15";
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 4; col++) {
      ctx.beginPath();
      ctx.arc(x - size * 0.18 + col * size * 0.04, y - size * 0.4 + row * size * 0.025, size * 0.008, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + size * 0.06 + col * size * 0.04, y - size * 0.4 + row * size * 0.025, size * 0.008, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Helm crown with frost gem
  ctx.fillStyle = "#505068";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.08, y - size * 0.93);
  ctx.lineTo(x, y - size * 1.05);
  ctx.lineTo(x + size * 0.08, y - size * 0.93);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = "#40a0ff";
  ctx.shadowColor = "#60c0ff";
  ctx.shadowBlur = 8 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.97, size * 0.03, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // === NO PLUME - Instead, heavy metal horns ===
  for (let side = -1; side <= 1; side += 2) {
    const hornX = x + side * size * 0.25;
    // Horn base
    ctx.fillStyle = "#404058";
    ctx.beginPath();
    ctx.moveTo(hornX - side * size * 0.04, y - size * 0.82);
    ctx.quadraticCurveTo(
      hornX + side * size * 0.15, y - size * 1.0,
      hornX + side * size * 0.32, y - size * 0.9
    );
    ctx.quadraticCurveTo(
      hornX + side * size * 0.18, y - size * 0.85,
      hornX + side * size * 0.02, y - size * 0.78
    );
    ctx.closePath();
    ctx.fill();
    // Horn highlight
    ctx.strokeStyle = "#606080";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(hornX - side * size * 0.02, y - size * 0.8);
    ctx.quadraticCurveTo(
      hornX + side * size * 0.12, y - size * 0.96,
      hornX + side * size * 0.28, y - size * 0.88
    );
    ctx.stroke();
    // Frost glow at horn tips
    ctx.fillStyle = "#60c0ff";
    ctx.shadowColor = "#80e0ff";
    ctx.shadowBlur = 4 * zoom;
    ctx.beginPath();
    ctx.arc(hornX + side * size * 0.3, y - size * 0.89, size * 0.015, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // === ORNATE TOWER SHIELD (Left side) ===
  ctx.save();
  ctx.translate(x - size * 0.58, y + size * 0.05);
  ctx.rotate(0.2);

  // Shield shadow
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.beginPath();
  ctx.moveTo(size * 0.02, -size * 0.32);
  ctx.lineTo(-size * 0.2, -size * 0.2);
  ctx.lineTo(-size * 0.22, size * 0.25);
  ctx.lineTo(size * 0.02, size * 0.42);
  ctx.lineTo(size * 0.24, size * 0.25);
  ctx.lineTo(size * 0.26, -size * 0.2);
  ctx.closePath();
  ctx.fill();

  // Shield body with frost steel gradient
  const shieldGrad = ctx.createLinearGradient(-size * 0.22, 0, size * 0.22, 0);
  shieldGrad.addColorStop(0, "#303050");
  shieldGrad.addColorStop(0.25, "#505078");
  shieldGrad.addColorStop(0.5, "#606090");
  shieldGrad.addColorStop(0.75, "#505078");
  shieldGrad.addColorStop(1, "#303050");
  ctx.fillStyle = shieldGrad;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.35);
  ctx.lineTo(-size * 0.22, -size * 0.22);
  ctx.lineTo(-size * 0.24, size * 0.22);
  ctx.lineTo(0, size * 0.4);
  ctx.lineTo(size * 0.24, size * 0.22);
  ctx.lineTo(size * 0.22, -size * 0.22);
  ctx.closePath();
  ctx.fill();

  // Shield edge highlight
  ctx.strokeStyle = "#8888aa";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-size * 0.01, -size * 0.33);
  ctx.lineTo(-size * 0.2, -size * 0.2);
  ctx.stroke();

  // Shield border
  ctx.strokeStyle = "#151525";
  ctx.lineWidth = 3 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.35);
  ctx.lineTo(-size * 0.22, -size * 0.22);
  ctx.lineTo(-size * 0.24, size * 0.22);
  ctx.lineTo(0, size * 0.4);
  ctx.lineTo(size * 0.24, size * 0.22);
  ctx.lineTo(size * 0.22, -size * 0.22);
  ctx.closePath();
  ctx.stroke();

  // Ice blue inner trim
  ctx.strokeStyle = "#80c0ff";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.3);
  ctx.lineTo(-size * 0.17, -size * 0.18);
  ctx.lineTo(-size * 0.19, size * 0.18);
  ctx.lineTo(0, size * 0.34);
  ctx.lineTo(size * 0.19, size * 0.18);
  ctx.lineTo(size * 0.17, -size * 0.18);
  ctx.closePath();
  ctx.stroke();

  // Shield frost rune patterns
  ctx.strokeStyle = "#60a0ff";
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.6;
  ctx.beginPath();
  ctx.moveTo(-size * 0.1, -size * 0.12);
  ctx.quadraticCurveTo(-size * 0.12, 0, -size * 0.08, size * 0.12);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(size * 0.1, -size * 0.12);
  ctx.quadraticCurveTo(size * 0.12, 0, size * 0.08, size * 0.12);
  ctx.stroke();
  ctx.globalAlpha = 1;

  // Shield boss with "M" emblem
  ctx.fillStyle = "#80c0ff";
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.12, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#1a3050";
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.09, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = "#151525";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.12, 0, Math.PI * 2);
  ctx.stroke();

  // "M" emblem
  ctx.fillStyle = "#80c0ff";
  ctx.font = `bold ${16 * zoom}px serif`;
  ctx.textAlign = "center";
  ctx.fillText("M", 0, size * 0.05);

  // Shield corner gems
  ctx.fillStyle = "#40a0ff";
  ctx.shadowColor = "#60c0ff";
  ctx.shadowBlur = 4 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(0, -size * 0.26, size * 0.022, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(-size * 0.14, size * 0.12, size * 0.018, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(size * 0.14, size * 0.12, size * 0.018, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(0, size * 0.3, size * 0.018, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // === MASSIVE WAR HAMMER (Right side, angled away from face) ===
  // Epic attack animation: wind-up  overhead  devastating slam
  let hammerAngle: number;
  let hammerX: number;
  let hammerY: number;
  
  if (isAttacking) {
    // Phase 1 (0-0.3): Wind-up - hammer goes back and up
    // Phase 2 (0.3-0.6): Overhead swing - hammer arcs over
    // Phase 3 (0.6-1.0): Devastating slam - hammer crashes down
    if (attackPhase < 0.3) {
      // Wind-up: pull back
      const windUp = attackPhase / 0.3;
      hammerAngle = 0.8 + windUp * 1.5; // Rotate back
      hammerX = x + size * 0.55 + windUp * size * 0.15;
      hammerY = y - size * 0.1 - windUp * size * 0.2;
    } else if (attackPhase < 0.6) {
      // Overhead: arc forward
      const overheadProgress = (attackPhase - 0.3) / 0.3;
      hammerAngle = 2.3 - overheadProgress * 3.5; // Arc from back to front
      hammerX = x + size * 0.7 - overheadProgress * size * 0.3;
      hammerY = y - size * 0.3 + overheadProgress * size * 0.4;
    } else {
      // Slam: crash down
      const slamProgress = (attackPhase - 0.6) / 0.4;
      hammerAngle = -1.2 + slamProgress * 0.4; // Slight recovery
      hammerX = x + size * 0.4;
      hammerY = y + size * 0.1 - slamProgress * size * 0.15;
    }
  } else {
    // Idle: hammer resting at side, angled away from face
    hammerAngle = 0.6 + heavyStance * 0.02; // Tilted to the right
    hammerX = x + size * 0.6;
    hammerY = y + size * 0.15;
  }

  ctx.save();
  ctx.translate(hammerX, hammerY);
  ctx.rotate(hammerAngle);

  // Hammer handle - thick reinforced shaft
  const shaftGrad = ctx.createLinearGradient(-size * 0.05, -size * 0.1, size * 0.05, -size * 0.1);
  shaftGrad.addColorStop(0, "#2a1a10");
  shaftGrad.addColorStop(0.3, "#4a3020");
  shaftGrad.addColorStop(0.5, "#5a4030");
  shaftGrad.addColorStop(0.7, "#4a3020");
  shaftGrad.addColorStop(1, "#2a1a10");
  ctx.fillStyle = shaftGrad;
  ctx.fillRect(-size * 0.05, -size * 0.85, size * 0.1, size * 1.05);

  // Metal bands on shaft
  for (let band = 0; band < 6; band++) {
    const bandY = -size * 0.75 + band * size * 0.18;
    ctx.fillStyle = "#505068";
    ctx.fillRect(-size * 0.06, bandY, size * 0.12, size * 0.045);
    ctx.fillStyle = "#707098";
    ctx.fillRect(-size * 0.06, bandY, size * 0.12, size * 0.018);
  }

  // Shaft border
  ctx.strokeStyle = "#1a0a05";
  ctx.lineWidth = 1.5;
  ctx.strokeRect(-size * 0.05, -size * 0.85, size * 0.1, size * 1.05);

  // === MASSIVE HAMMER HEAD ===
  if (isAttacking && attackPhase > 0.5) {
    ctx.shadowColor = "#60c0ff";
    ctx.shadowBlur = 20 * zoom * attackIntensity;
  }

  // Hammer head main body
  const headGrad = ctx.createLinearGradient(-size * 0.22, -size * 0.95, size * 0.22, -size * 0.95);
  headGrad.addColorStop(0, "#252540");
  headGrad.addColorStop(0.15, "#404060");
  headGrad.addColorStop(0.35, "#505078");
  headGrad.addColorStop(0.5, "#606090");
  headGrad.addColorStop(0.65, "#505078");
  headGrad.addColorStop(0.85, "#404060");
  headGrad.addColorStop(1, "#252540");
  ctx.fillStyle = headGrad;
  ctx.beginPath();
  // Main striking head (larger, more imposing)
  ctx.moveTo(-size * 0.2, -size * 0.82);
  ctx.lineTo(-size * 0.25, -size * 1.02);
  ctx.lineTo(size * 0.25, -size * 1.02);
  ctx.lineTo(size * 0.2, -size * 0.82);
  ctx.closePath();
  ctx.fill();

  // Top flat face with bevel
  ctx.fillStyle = "#505070";
  ctx.beginPath();
  ctx.moveTo(-size * 0.23, -size * 1.02);
  ctx.lineTo(-size * 0.18, -size * 1.08);
  ctx.lineTo(size * 0.18, -size * 1.08);
  ctx.lineTo(size * 0.23, -size * 1.02);
  ctx.closePath();
  ctx.fill();

  // Spike on back of hammer (war pick side)
  ctx.fillStyle = "#404058";
  ctx.beginPath();
  ctx.moveTo(-size * 0.2, -size * 0.86);
  ctx.lineTo(-size * 0.4, -size * 0.92);
  ctx.lineTo(-size * 0.2, -size * 0.98);
  ctx.closePath();
  ctx.fill();
  // Spike highlight
  ctx.strokeStyle = "#606080";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-size * 0.2, -size * 0.87);
  ctx.lineTo(-size * 0.38, -size * 0.92);
  ctx.stroke();

  // Hammer head border
  ctx.strokeStyle = "#151525";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(-size * 0.2, -size * 0.82);
  ctx.lineTo(-size * 0.25, -size * 1.02);
  ctx.lineTo(-size * 0.18, -size * 1.08);
  ctx.lineTo(size * 0.18, -size * 1.08);
  ctx.lineTo(size * 0.25, -size * 1.02);
  ctx.lineTo(size * 0.2, -size * 0.82);
  ctx.closePath();
  ctx.stroke();

  ctx.shadowBlur = 0;

  // Frost runes on hammer head (glowing intensely during attack)
  const runeGlow = isAttacking && attackPhase > 0.4 ? 0.8 + attackIntensity * 0.2 : 0.5;
  ctx.fillStyle = `rgba(100, 200, 255, ${runeGlow})`;
  ctx.shadowColor = "#60c0ff";
  ctx.shadowBlur = isAttacking && attackPhase > 0.4 ? 12 * zoom : 4 * zoom;
  // Central rune
  ctx.beginPath();
  ctx.arc(0, -size * 0.92, size * 0.03, 0, Math.PI * 2);
  ctx.fill();
  // Side runes
  ctx.beginPath();
  ctx.arc(-size * 0.12, -size * 0.92, size * 0.022, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(size * 0.12, -size * 0.92, size * 0.022, 0, Math.PI * 2);
  ctx.fill();
  // Rune connecting frost lines
  ctx.strokeStyle = `rgba(100, 200, 255, ${runeGlow * 0.7})`;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-size * 0.1, -size * 0.92);
  ctx.lineTo(-size * 0.02, -size * 0.92);
  ctx.moveTo(size * 0.1, -size * 0.92);
  ctx.lineTo(size * 0.02, -size * 0.92);
  ctx.stroke();
  // Vertical rune line
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.89);
  ctx.lineTo(0, -size * 0.95);
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Ice blue accent trim on hammer
  ctx.strokeStyle = "#80c0ff";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(-size * 0.18, -size * 0.84);
  ctx.lineTo(-size * 0.23, -size * 1.0);
  ctx.lineTo(size * 0.23, -size * 1.0);
  ctx.lineTo(size * 0.18, -size * 0.84);
  ctx.stroke();

  // Ornate pommel at bottom
  ctx.fillStyle = "#505068";
  ctx.beginPath();
  ctx.arc(0, size * 0.22, size * 0.065, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#40a0ff";
  ctx.shadowColor = "#60c0ff";
  ctx.shadowBlur = 4 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(0, size * 0.22, size * 0.035, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // === EPIC IMPACT EFFECTS (during slam phase) ===
  if (isAttacking && attackPhase > 0.55) {
    const slamIntensity = attackPhase > 0.6 ? ((attackPhase - 0.6) / 0.4) : 0;
    const impactX = x + size * 0.4;
    const impactY = y + size * 0.55;
    
    // Screen shake effect simulation via offset particles
    const shakeOffset = slamIntensity * 3 * Math.sin(time * 50);
    
    // Massive shockwave rings
    for (let ring = 0; ring < 5; ring++) {
      const ringSize = size * 0.2 + ring * size * 0.25 * slamIntensity;
      const ringAlpha = (0.8 - ring * 0.15) * slamIntensity;
      ctx.strokeStyle = ring % 2 === 0 
        ? `rgba(100, 180, 255, ${ringAlpha})` 
        : `rgba(200, 230, 255, ${ringAlpha * 0.7})`;
      ctx.lineWidth = (4 - ring * 0.5) * zoom;
      ctx.beginPath();
      ctx.ellipse(impactX + shakeOffset, impactY, ringSize, ringSize * 0.25, 0, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    // Ground crack lines radiating outward
    for (let crack = 0; crack < 12; crack++) {
      const crackAngle = crack * Math.PI / 6 + Math.sin(crack * 0.7) * 0.2;
      const crackLen = size * (0.4 + Math.random() * 0.3) * slamIntensity;
      const crackWidth = (3 - crack * 0.15) * zoom;
      
      // Main crack
      ctx.strokeStyle = `rgba(80, 150, 220, ${0.8 * slamIntensity})`;
      ctx.lineWidth = crackWidth;
      ctx.beginPath();
      ctx.moveTo(impactX, impactY);
      // Jagged crack path
      const midX = impactX + Math.cos(crackAngle) * crackLen * 0.5 + Math.sin(crack * 2) * size * 0.05;
      const midY = impactY + Math.sin(crackAngle) * crackLen * 0.15;
      ctx.lineTo(midX, midY);
      ctx.lineTo(
        impactX + Math.cos(crackAngle) * crackLen,
        impactY + Math.sin(crackAngle) * crackLen * 0.25
      );
      ctx.stroke();
      
      // Crack glow
      ctx.strokeStyle = `rgba(150, 200, 255, ${0.4 * slamIntensity})`;
      ctx.lineWidth = crackWidth * 2;
      ctx.stroke();
    }
    
    // Flying debris and ice shards
    for (let debris = 0; debris < 20; debris++) {
      const debrisAngle = debris * Math.PI / 10 + time * 2;
      const debrisDist = size * 0.1 + debris * size * 0.04 * slamIntensity;
      const debrisHeight = Math.sin((attackPhase - 0.6) * Math.PI * 2 + debris * 0.3) * size * 0.4;
      const debrisX = impactX + Math.cos(debrisAngle) * debrisDist;
      const debrisY = impactY - Math.abs(debrisHeight) * slamIntensity;
      const debrisAlpha = 0.9 * slamIntensity * (1 - debris * 0.04);
      
      // Ice shard shape
      ctx.fillStyle = debris % 3 === 0 
        ? `rgba(200, 230, 255, ${debrisAlpha})` 
        : `rgba(100, 180, 255, ${debrisAlpha * 0.7})`;
      ctx.save();
      ctx.translate(debrisX, debrisY);
      ctx.rotate(debrisAngle + time * 5);
      ctx.beginPath();
      ctx.moveTo(0, -size * 0.025);
      ctx.lineTo(size * 0.012, 0);
      ctx.lineTo(0, size * 0.025);
      ctx.lineTo(-size * 0.012, 0);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
    
    // Central impact flash
    if (attackPhase > 0.58 && attackPhase < 0.75) {
      const flashIntensity = Math.sin((attackPhase - 0.58) / 0.17 * Math.PI);
      const flashGrad = ctx.createRadialGradient(impactX, impactY, 0, impactX, impactY, size * 0.4);
      flashGrad.addColorStop(0, `rgba(255, 255, 255, ${flashIntensity * 0.8})`);
      flashGrad.addColorStop(0.3, `rgba(150, 220, 255, ${flashIntensity * 0.5})`);
      flashGrad.addColorStop(1, "rgba(100, 180, 255, 0)");
      ctx.fillStyle = flashGrad;
      ctx.beginPath();
      ctx.ellipse(impactX, impactY, size * 0.4, size * 0.15, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // === ARMORED LEGS/GREAVES ===
  for (let side = -1; side <= 1; side += 2) {
    const legX = x + side * size * 0.22;
    
    // Heavy greave
    const greaveGrad = ctx.createLinearGradient(legX - size * 0.08, y + size * 0.3, legX + size * 0.08, y + size * 0.3);
    greaveGrad.addColorStop(0, "#303048");
    greaveGrad.addColorStop(0.5, "#505070");
    greaveGrad.addColorStop(1, "#303048");
    ctx.fillStyle = greaveGrad;
    ctx.beginPath();
    ctx.moveTo(legX - size * 0.1, y + size * 0.52);
    ctx.lineTo(legX - size * 0.12, y + size * 0.32);
    ctx.lineTo(legX + size * 0.12, y + size * 0.32);
    ctx.lineTo(legX + size * 0.1, y + size * 0.52);
    ctx.closePath();
    ctx.fill();
    
    // Knee guard
    ctx.fillStyle = "#505068";
    ctx.beginPath();
    ctx.ellipse(legX, y + size * 0.34, size * 0.08, size * 0.06, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#40a0ff";
    ctx.shadowColor = "#60c0ff";
    ctx.shadowBlur = 3 * zoom * gemPulse;
    ctx.beginPath();
    ctx.arc(legX, y + size * 0.34, size * 0.02, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Armored boot
    ctx.fillStyle = "#404058";
    ctx.beginPath();
    ctx.moveTo(legX - size * 0.1, y + size * 0.52);
    ctx.lineTo(legX - size * 0.12, y + size * 0.58);
    ctx.lineTo(legX + side * size * 0.02, y + size * 0.6);
    ctx.lineTo(legX + size * 0.12, y + size * 0.58);
    ctx.lineTo(legX + size * 0.1, y + size * 0.52);
    ctx.closePath();
    ctx.fill();
  }
}

function drawRockyHero(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // EPIC ORNATE ROCKY - Legendary Golden Squirrel King with devastating tail whip attacks
  const hop = Math.abs(Math.sin(time * 6)) * 5;
  const isAttacking = attackPhase > 0;
  const tailWhip = isAttacking ? Math.sin(attackPhase * Math.PI * 2) * 1.8 : 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const gemPulse = Math.sin(time * 2.5) * 0.3 + 0.7;

  // === MULTI-LAYERED GOLDEN AURA ===
  const auraBase = isAttacking ? 0.45 : 0.25;
  const auraPulse = 0.85 + Math.sin(time * 3.5) * 0.15;
  for (let auraLayer = 0; auraLayer < 4; auraLayer++) {
    const layerOffset = auraLayer * 0.1;
    const auraGrad = ctx.createRadialGradient(
      x, y - hop, size * (0.1 + layerOffset),
      x, y - hop, size * (0.95 + layerOffset * 0.3)
    );
    const layerAlpha = (auraBase - auraLayer * 0.05) * auraPulse;
    auraGrad.addColorStop(0, `rgba(218, 165, 32, ${layerAlpha * 0.5})`);
    auraGrad.addColorStop(0.4, `rgba(255, 200, 80, ${layerAlpha * 0.35})`);
    auraGrad.addColorStop(0.7, `rgba(255, 150, 50, ${layerAlpha * 0.2})`);
    auraGrad.addColorStop(1, "rgba(218, 165, 32, 0)");
    ctx.fillStyle = auraGrad;
    ctx.beginPath();
    ctx.ellipse(x, y - hop, size * (0.9 + layerOffset * 0.2), size * (0.7 + layerOffset * 0.15), 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Floating golden spark particles
  for (let p = 0; p < 12; p++) {
    const pAngle = (time * 2 + p * Math.PI * 2 / 12) % (Math.PI * 2);
    const pDist = size * 0.6 + Math.sin(time * 3 + p * 0.8) * size * 0.15;
    const px = x + Math.cos(pAngle) * pDist;
    const py = y - hop + Math.sin(pAngle) * pDist * 0.55;
    const pAlpha = 0.6 + Math.sin(time * 4.5 + p * 0.7) * 0.3;
    ctx.fillStyle = p % 2 === 0 ? `rgba(255, 215, 0, ${pAlpha})` : `rgba(255, 180, 50, ${pAlpha})`;
    ctx.beginPath();
    ctx.arc(px, py, size * 0.018, 0, Math.PI * 2);
    ctx.fill();
  }

  // === ATTACK AURA RINGS ===
  if (isAttacking) {
    for (let ring = 0; ring < 4; ring++) {
      const ringPhase = (attackPhase * 2.5 + ring * 0.15) % 1;
      const ringAlpha = (1 - ringPhase) * 0.55 * attackIntensity;
      // Outer golden ring
      ctx.strokeStyle = `rgba(218, 165, 32, ${ringAlpha})`;
      ctx.lineWidth = (3 - ring * 0.5) * zoom;
      ctx.beginPath();
      ctx.ellipse(x, y - hop, size * (0.55 + ringPhase * 0.5), size * (0.5 + ringPhase * 0.45), 0, 0, Math.PI * 2);
      ctx.stroke();
      // Inner bright ring
      ctx.strokeStyle = `rgba(255, 235, 150, ${ringAlpha * 0.4})`;
      ctx.lineWidth = (1.5 - ring * 0.25) * zoom;
      ctx.stroke();
    }
  }

  // === SHADOW WITH DEPTH ===
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.48, 0, x, y + size * 0.48, size * 0.45);
  shadowGrad.addColorStop(0, "rgba(0, 0, 0, 0.5)");
  shadowGrad.addColorStop(0.6, "rgba(0, 0, 0, 0.25)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.48, size * 0.42, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  // === MAGNIFICENT MULTI-LAYERED FLUFFY TAIL ===
  const tailWave = Math.sin(time * 4.5 + tailWhip) * 7;
  const tailWave2 = Math.sin(time * 5.5 + tailWhip + 0.5) * 4;

  // Tail outer shadow layer
  ctx.fillStyle = "#4a3002";
  ctx.beginPath();
  ctx.moveTo(x + size * 0.24, y + size * 0.26 - hop * 0.3);
  ctx.bezierCurveTo(
    x + size * 0.5 + tailWave * 0.9, y + size * 0.1 - hop * 0.35,
    x + size * 0.85 + tailWave, y - size * 0.2 - hop * 0.4,
    x + size * 0.62 + tailWave * 0.55, y - size * 0.75 - hop * 0.45
  );
  ctx.bezierCurveTo(
    x + size * 0.4 + tailWave2 * 0.3, y - size * 0.45 - hop * 0.35,
    x + size * 0.28, y - size * 0.15 - hop * 0.3,
    x + size * 0.18, y + size * 0.15 - hop * 0.3
  );
  ctx.closePath();
  ctx.fill();

  // Tail outer layer (darker gold)
  ctx.fillStyle = "#6b4904";
  ctx.beginPath();
  ctx.moveTo(x + size * 0.22, y + size * 0.24 - hop * 0.3);
  ctx.bezierCurveTo(
    x + size * 0.48 + tailWave * 0.85, y + size * 0.08 - hop * 0.35,
    x + size * 0.82 + tailWave, y - size * 0.18 - hop * 0.4,
    x + size * 0.6 + tailWave * 0.5, y - size * 0.72 - hop * 0.45
  );
  ctx.bezierCurveTo(
    x + size * 0.38 + tailWave2 * 0.3, y - size * 0.42 - hop * 0.35,
    x + size * 0.26, y - size * 0.12 - hop * 0.3,
    x + size * 0.17, y + size * 0.14 - hop * 0.3
  );
  ctx.closePath();
  ctx.fill();

  // Tail middle layer (warm gold)
  ctx.fillStyle = "#8b6914";
  ctx.beginPath();
  ctx.moveTo(x + size * 0.22, y + size * 0.2 - hop * 0.3);
  ctx.bezierCurveTo(
    x + size * 0.45 + tailWave * 0.8, y + size * 0.02 - hop * 0.35,
    x + size * 0.75 + tailWave * 0.9, y - size * 0.22 - hop * 0.4,
    x + size * 0.55 + tailWave * 0.45, y - size * 0.65 - hop * 0.45
  );
  ctx.bezierCurveTo(
    x + size * 0.36 + tailWave2 * 0.25, y - size * 0.38 - hop * 0.35,
    x + size * 0.25, y - size * 0.08 - hop * 0.3,
    x + size * 0.18, y + size * 0.12 - hop * 0.3
  );
  ctx.closePath();
  ctx.fill();

  // Tail highlight layer (bright gold)
  const tailHighlightGrad = ctx.createLinearGradient(
    x + size * 0.2, y - hop, x + size * 0.6 + tailWave * 0.4, y - size * 0.6 - hop
  );
  tailHighlightGrad.addColorStop(0, "#b09030");
  tailHighlightGrad.addColorStop(0.5, "#d4b050");
  tailHighlightGrad.addColorStop(1, "#c0a040");
  ctx.fillStyle = tailHighlightGrad;
  ctx.beginPath();
  ctx.moveTo(x + size * 0.24, y + size * 0.14 - hop * 0.3);
  ctx.bezierCurveTo(
    x + size * 0.4 + tailWave * 0.7, y - size * 0.05 - hop * 0.35,
    x + size * 0.62 + tailWave * 0.8, y - size * 0.28 - hop * 0.4,
    x + size * 0.48 + tailWave * 0.38, y - size * 0.55 - hop * 0.45
  );
  ctx.bezierCurveTo(
    x + size * 0.35 + tailWave2 * 0.2, y - size * 0.32 - hop * 0.35,
    x + size * 0.26, y - size * 0.02 - hop * 0.3,
    x + size * 0.2, y + size * 0.08 - hop * 0.3
  );
  ctx.closePath();
  ctx.fill();

  // Tail fur strands
  ctx.strokeStyle = "#5a4008";
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.5;
  for (let strand = 0; strand < 8; strand++) {
    const strandT = strand / 7;
    const strandX = x + size * 0.25 + strandT * (size * 0.3 + tailWave * 0.35);
    const strandY = y + size * 0.1 - strandT * (size * 0.55) - hop * (0.3 + strandT * 0.15);
    const strandWave = Math.sin(time * 5 + strand * 0.5) * size * 0.02;
    ctx.beginPath();
    ctx.moveTo(strandX, strandY);
    ctx.lineTo(strandX + size * 0.08 + strandWave, strandY - size * 0.06);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Tail tip magical glow
  const tailTipX = x + size * 0.55 + tailWave * 0.45;
  const tailTipY = y - size * 0.68 - hop * 0.45;
  ctx.fillStyle = `rgba(255, 220, 80, ${0.4 + gemPulse * 0.3})`;
  ctx.shadowColor = "#ffc000";
  ctx.shadowBlur = 10 * zoom * (isAttacking ? 1 + attackIntensity : 0.6);
  ctx.beginPath();
  ctx.arc(tailTipX, tailTipY, size * 0.08, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = `rgba(255, 255, 200, ${0.5 + gemPulse * 0.3})`;
  ctx.beginPath();
  ctx.arc(tailTipX, tailTipY, size * 0.04, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

  // === HEROIC MUSCULAR BODY ===
  const bodyGrad = ctx.createRadialGradient(
    x - size * 0.05, y - hop - size * 0.05, size * 0.08,
    x, y - hop, size * 0.45
  );
  bodyGrad.addColorStop(0, "#e0b050");
  bodyGrad.addColorStop(0.3, "#d4a040");
  bodyGrad.addColorStop(0.6, "#a07020");
  bodyGrad.addColorStop(0.85, "#8b6914");
  bodyGrad.addColorStop(1, "#5a4008");
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.ellipse(x, y - hop, size * 0.36, size * 0.42, 0, 0, Math.PI * 2);
  ctx.fill();

  // Body fur texture
  ctx.strokeStyle = "rgba(90, 64, 8, 0.35)";
  ctx.lineWidth = 1.2 * zoom;
  for (let i = 0; i < 6; i++) {
    const furAngle = -0.6 + i * 0.25;
    const furWave = Math.sin(time * 6 + i * 0.5) * size * 0.01;
    ctx.beginPath();
    ctx.moveTo(
      x + Math.cos(furAngle) * size * 0.15,
      y - hop + Math.sin(furAngle) * size * 0.22
    );
    ctx.lineTo(
      x + Math.cos(furAngle) * size * 0.32 + furWave,
      y - hop + Math.sin(furAngle) * size * 0.38
    );
    ctx.stroke();
  }

  // Royal chest fur tuft
  ctx.fillStyle = "#f0d890";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.08, y - hop - size * 0.2);
  ctx.quadraticCurveTo(x, y - hop - size * 0.28, x + size * 0.08, y - hop - size * 0.2);
  ctx.quadraticCurveTo(x + size * 0.06, y - hop - size * 0.12, x, y - hop - size * 0.08);
  ctx.quadraticCurveTo(x - size * 0.06, y - hop - size * 0.12, x - size * 0.08, y - hop - size * 0.2);
  ctx.fill();

  // Soft belly
  const bellyGrad = ctx.createRadialGradient(
    x, y - hop + size * 0.06, size * 0.02,
    x, y - hop + size * 0.06, size * 0.24
  );
  bellyGrad.addColorStop(0, "#fffaf0");
  bellyGrad.addColorStop(0.5, "#fff8e8");
  bellyGrad.addColorStop(1, "#e8d0b0");
  ctx.fillStyle = bellyGrad;
  ctx.beginPath();
  ctx.ellipse(x, y - hop + size * 0.07, size * 0.24, size * 0.28, 0, 0, Math.PI * 2);
  ctx.fill();

  // === HEROIC SQUIRREL ARMS ===
  // Arms hold the acorn and raise during tail whip attack
  const armSwingLeft = isAttacking ? Math.sin(attackPhase * Math.PI * 2) * 0.5 : Math.sin(time * 3) * 0.08;
  const armSwingRight = isAttacking ? Math.sin(attackPhase * Math.PI * 2 + 0.4) * 0.6 : Math.sin(time * 3 + 0.5) * 0.08;
  
  // Left arm (holding acorn from below)
  ctx.save();
  ctx.translate(x - size * 0.28, y - hop - size * 0.05);
  ctx.rotate(-0.8 - armSwingLeft * 0.8);
  
  // Left arm fur
  const leftArmGrad = ctx.createLinearGradient(0, 0, -size * 0.08, size * 0.22);
  leftArmGrad.addColorStop(0, "#c89828");
  leftArmGrad.addColorStop(0.5, "#a07020");
  leftArmGrad.addColorStop(1, "#8b6914");
  ctx.fillStyle = leftArmGrad;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.quadraticCurveTo(-size * 0.06, size * 0.08, -size * 0.04, size * 0.18);
  ctx.lineTo(size * 0.04, size * 0.16);
  ctx.quadraticCurveTo(size * 0.06, size * 0.08, 0, 0);
  ctx.closePath();
  ctx.fill();
  
  // Left paw
  const leftPawGrad = ctx.createRadialGradient(0, size * 0.2, 0, 0, size * 0.2, size * 0.06);
  leftPawGrad.addColorStop(0, "#e8d0b0");
  leftPawGrad.addColorStop(0.6, "#d4a040");
  leftPawGrad.addColorStop(1, "#a07020");
  ctx.fillStyle = leftPawGrad;
  ctx.beginPath();
  ctx.ellipse(0, size * 0.2, size * 0.055, size * 0.045, -0.3, 0, Math.PI * 2);
  ctx.fill();
  
  // Little paw pads
  ctx.fillStyle = "#a08070";
  ctx.beginPath();
  ctx.arc(-size * 0.02, size * 0.21, size * 0.012, 0, Math.PI * 2);
  ctx.arc(size * 0.015, size * 0.215, size * 0.01, 0, Math.PI * 2);
  ctx.fill();
  
  // Tiny claws
  ctx.strokeStyle = "#3a2a1a";
  ctx.lineWidth = 1 * zoom;
  ctx.lineCap = "round";
  for (let c = 0; c < 4; c++) {
    const clawAngle = -0.8 + c * 0.35;
    ctx.beginPath();
    ctx.moveTo(Math.cos(clawAngle) * size * 0.04, size * 0.2 + Math.sin(clawAngle) * size * 0.035);
    ctx.lineTo(Math.cos(clawAngle) * size * 0.06, size * 0.2 + Math.sin(clawAngle) * size * 0.05);
    ctx.stroke();
  }
  ctx.restore();
  
  // Right arm (holding acorn from side)
  ctx.save();
  ctx.translate(x - size * 0.32, y - hop + size * 0.08);
  ctx.rotate(-1.2 - armSwingRight * 0.6);
  
  // Right arm fur
  const rightArmGrad = ctx.createLinearGradient(0, 0, -size * 0.06, size * 0.2);
  rightArmGrad.addColorStop(0, "#c89828");
  rightArmGrad.addColorStop(0.5, "#a07020");
  rightArmGrad.addColorStop(1, "#8b6914");
  ctx.fillStyle = rightArmGrad;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.quadraticCurveTo(-size * 0.05, size * 0.07, -size * 0.03, size * 0.16);
  ctx.lineTo(size * 0.04, size * 0.14);
  ctx.quadraticCurveTo(size * 0.05, size * 0.07, 0, 0);
  ctx.closePath();
  ctx.fill();
  
  // Right paw
  const rightPawGrad = ctx.createRadialGradient(0, size * 0.18, 0, 0, size * 0.18, size * 0.055);
  rightPawGrad.addColorStop(0, "#e8d0b0");
  rightPawGrad.addColorStop(0.6, "#d4a040");
  rightPawGrad.addColorStop(1, "#a07020");
  ctx.fillStyle = rightPawGrad;
  ctx.beginPath();
  ctx.ellipse(0, size * 0.18, size * 0.05, size * 0.04, -0.4, 0, Math.PI * 2);
  ctx.fill();
  
  // Little paw pads
  ctx.fillStyle = "#a08070";
  ctx.beginPath();
  ctx.arc(-size * 0.015, size * 0.19, size * 0.01, 0, Math.PI * 2);
  ctx.arc(size * 0.012, size * 0.19, size * 0.008, 0, Math.PI * 2);
  ctx.fill();
  
  // Tiny claws
  ctx.strokeStyle = "#3a2a1a";
  ctx.lineWidth = 1 * zoom;
  for (let c = 0; c < 4; c++) {
    const clawAngle = -0.7 + c * 0.3;
    ctx.beginPath();
    ctx.moveTo(Math.cos(clawAngle) * size * 0.035, size * 0.18 + Math.sin(clawAngle) * size * 0.03);
    ctx.lineTo(Math.cos(clawAngle) * size * 0.055, size * 0.18 + Math.sin(clawAngle) * size * 0.045);
    ctx.stroke();
  }
  ctx.restore();

  // === ROYAL HEAD ===
  const headY = y - size * 0.5 - hop;
  const headGrad = ctx.createRadialGradient(
    x - size * 0.05, headY - size * 0.05, size * 0.05,
    x, headY, size * 0.32
  );
  headGrad.addColorStop(0, "#c89828");
  headGrad.addColorStop(0.4, "#b08020");
  headGrad.addColorStop(0.7, "#8b6914");
  headGrad.addColorStop(1, "#6b4904");
  ctx.fillStyle = headGrad;
  ctx.beginPath();
  ctx.ellipse(x, headY, size * 0.3, size * 0.28, 0, 0, Math.PI * 2);
  ctx.fill();

  // Fluffy cheeks with highlight
  const cheekGrad = ctx.createRadialGradient(
    x - size * 0.17, headY + size * 0.06, size * 0.02,
    x - size * 0.16, headY + size * 0.06, size * 0.14
  );
  cheekGrad.addColorStop(0, "#fff8e8");
  cheekGrad.addColorStop(0.6, "#f5deb3");
  cheekGrad.addColorStop(1, "#e0c8a0");
  ctx.fillStyle = cheekGrad;
  ctx.beginPath();
  ctx.ellipse(x - size * 0.17, headY + size * 0.06, size * 0.13, size * 0.11, -0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x + size * 0.17, headY + size * 0.06, size * 0.13, size * 0.11, 0.2, 0, Math.PI * 2);
  ctx.fill();

  // Whiskers
  ctx.strokeStyle = "#4a3a20";
  ctx.lineWidth = 0.8 * zoom;
  ctx.globalAlpha = 0.6;
  for (let side = -1; side <= 1; side += 2) {
    for (let w = 0; w < 3; w++) {
      const whiskerWave = Math.sin(time * 4 + w * 0.5) * size * 0.01;
      ctx.beginPath();
      ctx.moveTo(x + side * size * 0.12, headY + size * 0.08 + w * size * 0.03);
      ctx.lineTo(x + side * size * 0.32 + whiskerWave, headY + size * 0.05 + w * size * 0.04);
      ctx.stroke();
    }
  }
  ctx.globalAlpha = 1;

  // === ORNATE ROYAL EARS (tufted) ===
  for (let side = -1; side <= 1; side += 2) {
    const earX = x + side * size * 0.22;
    const earY = y - size * 0.72 - hop;

    // Ear outer (dark)
    ctx.fillStyle = "#7a5910";
    ctx.beginPath();
    ctx.ellipse(earX, earY, size * 0.1, size * 0.16, side * 0.35, 0, Math.PI * 2);
    ctx.fill();

    // Ear middle (golden)
    ctx.fillStyle = "#9b7018";
    ctx.beginPath();
    ctx.ellipse(earX, earY + size * 0.01, size * 0.085, size * 0.14, side * 0.35, 0, Math.PI * 2);
    ctx.fill();

    // Inner ear (pink warmth)
    const innerEarGrad = ctx.createRadialGradient(earX, earY + size * 0.02, 0, earX, earY + size * 0.02, size * 0.1);
    innerEarGrad.addColorStop(0, "#f5d0b8");
    innerEarGrad.addColorStop(0.7, "#d4a040");
    innerEarGrad.addColorStop(1, "#b08020");
    ctx.fillStyle = innerEarGrad;
    ctx.beginPath();
    ctx.ellipse(earX, earY + size * 0.02, size * 0.065, size * 0.11, side * 0.35, 0, Math.PI * 2);
    ctx.fill();

    // Elaborate ear tufts
    ctx.fillStyle = "#c0a040";
    ctx.beginPath();
    ctx.moveTo(earX - side * size * 0.02, earY - size * 0.14);
    ctx.lineTo(earX + side * size * 0.03, earY - size * 0.24);
    ctx.lineTo(earX + side * size * 0.05, earY - size * 0.22);
    ctx.lineTo(earX + side * size * 0.06, earY - size * 0.28);
    ctx.lineTo(earX + side * size * 0.04, earY - size * 0.12);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#a08030";
    ctx.beginPath();
    ctx.moveTo(earX, earY - size * 0.12);
    ctx.lineTo(earX + side * size * 0.02, earY - size * 0.2);
    ctx.lineTo(earX + side * size * 0.03, earY - size * 0.1);
    ctx.closePath();
    ctx.fill();

    // Ear gold jewelry ring
    ctx.strokeStyle = "#daa520";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(earX + side * size * 0.06, earY + size * 0.05, size * 0.025, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fillStyle = "#ff6600";
    ctx.beginPath();
    ctx.arc(earX + side * size * 0.06, earY + size * 0.075, size * 0.012, 0, Math.PI * 2);
    ctx.fill();
  }

  // === MAJESTIC MINI CROWN ===
  ctx.fillStyle = "#daa520";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.12, headY - size * 0.22);
  ctx.lineTo(x - size * 0.14, headY - size * 0.32);
  ctx.lineTo(x - size * 0.08, headY - size * 0.26);
  ctx.lineTo(x - size * 0.04, headY - size * 0.35);
  ctx.lineTo(x, headY - size * 0.28);
  ctx.lineTo(x + size * 0.04, headY - size * 0.35);
  ctx.lineTo(x + size * 0.08, headY - size * 0.26);
  ctx.lineTo(x + size * 0.14, headY - size * 0.32);
  ctx.lineTo(x + size * 0.12, headY - size * 0.22);
  ctx.closePath();
  ctx.fill();
  // Crown highlight
  ctx.fillStyle = "#f0c040";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.1, headY - size * 0.23);
  ctx.lineTo(x - size * 0.11, headY - size * 0.28);
  ctx.lineTo(x - size * 0.06, headY - size * 0.25);
  ctx.lineTo(x - size * 0.03, headY - size * 0.31);
  ctx.lineTo(x, headY - size * 0.26);
  ctx.lineTo(x + size * 0.03, headY - size * 0.31);
  ctx.lineTo(x + size * 0.06, headY - size * 0.25);
  ctx.lineTo(x + size * 0.11, headY - size * 0.28);
  ctx.lineTo(x + size * 0.1, headY - size * 0.23);
  ctx.closePath();
  ctx.fill();
  // Crown gems
  ctx.fillStyle = "#ff3300";
  ctx.shadowColor = "#ff4400";
  ctx.shadowBlur = 3 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x, headY - size * 0.32, size * 0.018, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#00aaff";
  ctx.shadowColor = "#00ccff";
  ctx.beginPath();
  ctx.arc(x - size * 0.08, headY - size * 0.27, size * 0.012, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + size * 0.08, headY - size * 0.27, size * 0.012, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // === FIERCE EXPRESSIVE EYES ===
  const eyeScale = isAttacking ? 1.2 : 1;

  // Eye whites with slight gradient
  for (let side = -1; side <= 1; side += 2) {
    const eyeX = x + side * size * 0.11;
    const eyeGrad = ctx.createRadialGradient(eyeX, headY - size * 0.02, 0, eyeX, headY - size * 0.02, size * 0.1 * eyeScale);
    eyeGrad.addColorStop(0, "#ffffff");
    eyeGrad.addColorStop(0.7, "#f8f8f8");
    eyeGrad.addColorStop(1, "#1a1a1a");
    ctx.fillStyle = eyeGrad;
    ctx.beginPath();
    ctx.ellipse(eyeX, headY - size * 0.02, size * 0.1 * eyeScale, size * 0.12 * eyeScale, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Golden iris (intense glow during attack)
  const irisColor = isAttacking
    ? `rgba(255, 200, 50, ${0.8 + attackIntensity * 0.2})`
    : "#c09040";
  if (isAttacking) {
    ctx.shadowColor = "#ffc000";
    ctx.shadowBlur = 8 * zoom;
  }
  ctx.fillStyle = irisColor;
  ctx.beginPath();
  ctx.arc(x - size * 0.11, headY - size * 0.02, size * 0.06 * eyeScale, 0, Math.PI * 2);
  ctx.arc(x + size * 0.11, headY - size * 0.02, size * 0.06 * eyeScale, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Eye highlights (sparkle)
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.arc(x - size * 0.13, headY - size * 0.04, size * 0.035, 0, Math.PI * 2);
  ctx.arc(x + size * 0.09, headY - size * 0.04, size * 0.035, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x - size * 0.095, headY, size * 0.015, 0, Math.PI * 2);
  ctx.arc(x + size * 0.125, headY, size * 0.015, 0, Math.PI * 2);
  ctx.fill();

  // Pupils (fierce slits during attack)
  ctx.fillStyle = "#1a1a1a";
  if (isAttacking) {
    ctx.beginPath();
    ctx.ellipse(x - size * 0.11, headY - size * 0.02, size * 0.015, size * 0.045 * eyeScale, 0, 0, Math.PI * 2);
    ctx.ellipse(x + size * 0.11, headY - size * 0.02, size * 0.015, size * 0.045 * eyeScale, 0, 0, Math.PI * 2);
    ctx.fill();
  } else {
    ctx.beginPath();
    ctx.arc(x - size * 0.11, headY - size * 0.02, size * 0.028, 0, Math.PI * 2);
    ctx.arc(x + size * 0.11, headY - size * 0.02, size * 0.028, 0, Math.PI * 2);
    ctx.fill();
  }

  // Determined eyebrows
  ctx.strokeStyle = "#5a4008";
  ctx.lineWidth = 2 * zoom;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.18, headY - size * 0.1 - (isAttacking ? size * 0.02 : 0));
  ctx.quadraticCurveTo(x - size * 0.11, headY - size * 0.14 - (isAttacking ? size * 0.03 : 0), x - size * 0.04, headY - size * 0.1);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.18, headY - size * 0.1 - (isAttacking ? size * 0.02 : 0));
  ctx.quadraticCurveTo(x + size * 0.11, headY - size * 0.14 - (isAttacking ? size * 0.03 : 0), x + size * 0.04, headY - size * 0.1);
  ctx.stroke();

  // === DETAILED NOSE ===
  const noseGrad = ctx.createRadialGradient(x, headY + size * 0.1, 0, x, headY + size * 0.1, size * 0.05);
  noseGrad.addColorStop(0, "#4a2a15");
  noseGrad.addColorStop(0.6, "#3a1a0a");
  noseGrad.addColorStop(1, "#2a0a00");
  ctx.fillStyle = noseGrad;
  ctx.beginPath();
  ctx.ellipse(x, headY + size * 0.1, size * 0.05, size * 0.04, 0, 0, Math.PI * 2);
  ctx.fill();
  // Nose highlight
  ctx.fillStyle = "#6a4a3a";
  ctx.beginPath();
  ctx.arc(x - size * 0.015, headY + size * 0.085, size * 0.018, 0, Math.PI * 2);
  ctx.fill();

  // === EXPRESSIVE MOUTH ===
  if (isAttacking) {
    // Fierce snarling mouth
    ctx.fillStyle = "#2a0a00";
    ctx.beginPath();
    ctx.ellipse(x, headY + size * 0.16, size * 0.06, size * 0.04 * attackIntensity, 0, 0, Math.PI * 2);
    ctx.fill();
    // Fangs
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.moveTo(x - size * 0.035, headY + size * 0.13);
    ctx.lineTo(x - size * 0.02, headY + size * 0.2);
    ctx.lineTo(x - size * 0.005, headY + size * 0.13);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + size * 0.035, headY + size * 0.13);
    ctx.lineTo(x + size * 0.02, headY + size * 0.2);
    ctx.lineTo(x + size * 0.005, headY + size * 0.13);
    ctx.closePath();
    ctx.fill();
  } else {
    // Cute confident smile
    ctx.strokeStyle = "#3a1a0a";
    ctx.lineWidth = 1.8 * zoom;
    ctx.beginPath();
    ctx.arc(x, headY + size * 0.13, size * 0.055, 0.1 * Math.PI, 0.9 * Math.PI);
    ctx.stroke();
    // Little smile curl
    ctx.beginPath();
    ctx.arc(x - size * 0.04, headY + size * 0.14, size * 0.02, 0, Math.PI * 0.8);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(x + size * 0.04, headY + size * 0.14, size * 0.02, Math.PI * 0.2, Math.PI);
    ctx.stroke();
  }

  // === LEGENDARY GOLDEN ACORN ===
  ctx.save();
  ctx.translate(x - size * 0.42, y - size * 0.06 - hop);
  ctx.rotate(-0.15);

  // Acorn powerful glow
  ctx.shadowColor = "#ffc000";
  ctx.shadowBlur = 12 * zoom * (isAttacking ? 1 + attackIntensity * 0.5 : gemPulse);

  // Acorn outer (dark)
  ctx.fillStyle = "#6b5010";
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.11, size * 0.14, 0, 0, Math.PI * 2);
  ctx.fill();

  // Acorn body gradient
  const acornGrad = ctx.createRadialGradient(-size * 0.02, -size * 0.02, 0, 0, 0, size * 0.12);
  acornGrad.addColorStop(0, "#d4a030");
  acornGrad.addColorStop(0.5, "#c09030");
  acornGrad.addColorStop(0.8, "#8b6914");
  acornGrad.addColorStop(1, "#5a3a0a");
  ctx.fillStyle = acornGrad;
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.1, size * 0.13, 0, 0, Math.PI * 2);
  ctx.fill();

  // Acorn highlight
  ctx.fillStyle = "rgba(255, 230, 180, 0.4)";
  ctx.beginPath();
  ctx.ellipse(-size * 0.03, -size * 0.04, size * 0.04, size * 0.06, -0.3, 0, Math.PI * 2);
  ctx.fill();

  // Elaborate acorn cap
  const capGrad = ctx.createLinearGradient(-size * 0.1, -size * 0.1, size * 0.1, -size * 0.08);
  capGrad.addColorStop(0, "#8a6818");
  capGrad.addColorStop(0.5, "#b08020");
  capGrad.addColorStop(1, "#8a6818");
  ctx.fillStyle = capGrad;
  ctx.beginPath();
  ctx.ellipse(0, -size * 0.1, size * 0.095, size * 0.055, 0, 0, Math.PI * 2);
  ctx.fill();

  // Cap scallop pattern
  ctx.strokeStyle = "#5a4010";
  ctx.lineWidth = 0.8 * zoom;
  for (let i = -3; i <= 3; i++) {
    ctx.beginPath();
    ctx.arc(i * size * 0.025, -size * 0.1, size * 0.018, 0, Math.PI * 2);
    ctx.stroke();
  }

  // Acorn stem
  ctx.fillStyle = "#6b5010";
  ctx.beginPath();
  ctx.ellipse(0, -size * 0.145, size * 0.015, size * 0.025, 0, 0, Math.PI * 2);
  ctx.fill();

  // Acorn magical sparkle
  ctx.fillStyle = "#ffffff";
  ctx.globalAlpha = 0.6 + Math.sin(time * 5) * 0.3;
  ctx.beginPath();
  ctx.arc(-size * 0.025, -size * 0.03, size * 0.012, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;

  ctx.shadowBlur = 0;
  ctx.restore();

  // === EPIC SPEED LINES ===
  ctx.lineCap = "round";
  for (let i = 0; i < 5; i++) {
    const lineAlpha = 0.5 - i * 0.08 + Math.sin(time * 10 + i) * 0.15;
    ctx.strokeStyle = `rgba(218, 165, 32, ${lineAlpha})`;
    ctx.lineWidth = (2.5 - i * 0.3) * zoom;
    ctx.beginPath();
    ctx.moveTo(
      x + size * 0.5 - i * size * 0.1,
      y + size * 0.1 + i * size * 0.1 - hop * 0.5
    );
    ctx.lineTo(
      x + size * 0.8 - i * size * 0.12,
      y + size * 0.1 + i * size * 0.1 - hop * 0.5
    );
    ctx.stroke();
  }

  // === GOLDEN DUST TRAIL ===
  for (let dust = 0; dust < 8; dust++) {
    const dustPhase = (time * 3 + dust * 0.4) % 1.5;
    const dustX = x - size * 0.4 - dustPhase * size * 0.5;
    const dustY = y + size * 0.1 + Math.sin(time * 6 + dust * 0.8) * size * 0.1 - hop * 0.3;
    const dustAlpha = (1 - dustPhase / 1.5) * 0.5;
    ctx.fillStyle = `rgba(218, 165, 32, ${dustAlpha})`;
    ctx.beginPath();
    ctx.arc(dustX, dustY, size * 0.015, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawFScottHero(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // ORNATE F. SCOTT FITZGERALD - The Great Gatsby Author, Jazz Age Literary Master
  const isAttacking = attackPhase > 0;
  const quillFlourish = isAttacking ? Math.sin(attackPhase * Math.PI * 2) * 1.2 : 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const writeGesture = Math.sin(time * 2) * 1.5;
  const breathe = Math.sin(time * 2) * 1;
  const goldPulse = Math.sin(time * 3) * 0.3 + 0.7;

  // === MULTI-LAYERED LITERARY AURA ===
  const auraBase = isAttacking ? 0.4 : 0.2;
  const auraPulse = 0.85 + Math.sin(time * 3) * 0.15;
  for (let auraLayer = 0; auraLayer < 4; auraLayer++) {
    const layerOffset = auraLayer * 0.08;
    const auraGrad = ctx.createRadialGradient(
      x, y - size * 0.1, size * (0.1 + layerOffset),
      x, y - size * 0.1, size * (0.95 + layerOffset * 0.3)
    );
    const layerAlpha = (auraBase - auraLayer * 0.04) * auraPulse;
    auraGrad.addColorStop(0, `rgba(218, 165, 32, ${layerAlpha * 0.5})`);
    auraGrad.addColorStop(0.3, `rgba(184, 134, 11, ${layerAlpha * 0.35})`);
    auraGrad.addColorStop(0.6, `rgba(139, 69, 19, ${layerAlpha * 0.2})`);
    auraGrad.addColorStop(1, "rgba(218, 165, 32, 0)");
    ctx.fillStyle = auraGrad;
    ctx.beginPath();
    ctx.ellipse(x, y - size * 0.1, size * (0.85 + layerOffset * 0.15), size * (0.75 + layerOffset * 0.12), 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Floating golden letter particles
  for (let p = 0; p < 10; p++) {
    const pAngle = (time * 1.5 + p * Math.PI * 2 / 10) % (Math.PI * 2);
    const pDist = size * 0.6 + Math.sin(time * 2 + p * 0.7) * size * 0.1;
    const pRise = ((time * 0.5 + p * 0.4) % 1) * size * 0.25;
    const px = x + Math.cos(pAngle) * pDist;
    const py = y - size * 0.1 + Math.sin(pAngle) * pDist * 0.4 - pRise;
    const pAlpha = (0.6 - pRise / (size * 0.25) * 0.4) * goldPulse;
    ctx.fillStyle = `rgba(218, 165, 32, ${pAlpha})`;
    ctx.font = `italic ${8 * zoom}px Georgia`;
    ctx.textAlign = "center";
    const letters = "GATSBY";
    ctx.fillText(letters[p % letters.length], px, py);
  }

  // === MAGICAL WORD ATTACK RINGS ===
  if (isAttacking) {
    for (let ring = 0; ring < 4; ring++) {
      const ringPhase = (attackPhase * 2 + ring * 0.12) % 1;
      const ringAlpha = (1 - ringPhase) * 0.5 * attackIntensity;
      ctx.strokeStyle = `rgba(218, 165, 32, ${ringAlpha})`;
      ctx.lineWidth = (3.5 - ring * 0.6) * zoom;
      ctx.beginPath();
      ctx.ellipse(x, y - size * 0.12, size * (0.55 + ringPhase * 0.5), size * (0.65 + ringPhase * 0.5), 0, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  // === SHADOW WITH DEPTH ===
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.52, 0, x, y + size * 0.52, size * 0.45);
  shadowGrad.addColorStop(0, "rgba(0, 0, 0, 0.45)");
  shadowGrad.addColorStop(0.6, "rgba(0, 0, 0, 0.2)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.52, size * 0.42, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  // === ORNATE 1920S THREE-PIECE SUIT ===
  // Main suit jacket
  const suitGrad = ctx.createLinearGradient(x - size * 0.4, y - size * 0.1, x + size * 0.4, y + size * 0.3);
  suitGrad.addColorStop(0, "#1a1a28");
  suitGrad.addColorStop(0.25, "#2a2a3a");
  suitGrad.addColorStop(0.5, "#353548");
  suitGrad.addColorStop(0.75, "#2a2a3a");
  suitGrad.addColorStop(1, "#1a1a28");
  ctx.fillStyle = suitGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.38, y + size * 0.5 + breathe);
  ctx.lineTo(x - size * 0.42, y - size * 0.1);
  ctx.quadraticCurveTo(x - size * 0.35, y - size * 0.28, x, y - size * 0.32);
  ctx.quadraticCurveTo(x + size * 0.35, y - size * 0.28, x + size * 0.42, y - size * 0.1);
  ctx.lineTo(x + size * 0.38, y + size * 0.5 + breathe);
  ctx.closePath();
  ctx.fill();

  // Suit jacket border
  ctx.strokeStyle = "#0a0a15";
  ctx.lineWidth = 2 * zoom;
  ctx.stroke();

  // Suit pinstripes
  ctx.strokeStyle = "rgba(60, 60, 80, 0.3)";
  ctx.lineWidth = 0.8;
  for (let stripe = 0; stripe < 8; stripe++) {
    const stripeX = x - size * 0.32 + stripe * size * 0.09;
    ctx.beginPath();
    ctx.moveTo(stripeX, y - size * 0.15);
    ctx.lineTo(stripeX - size * 0.02, y + size * 0.45);
    ctx.stroke();
  }

  // Suit lapels with satin finish
  const lapelGrad = ctx.createLinearGradient(x - size * 0.25, y - size * 0.2, x - size * 0.08, y + size * 0.18);
  lapelGrad.addColorStop(0, "#1a1a28");
  lapelGrad.addColorStop(0.4, "#252535");
  lapelGrad.addColorStop(1, "#1a1a28");
  ctx.fillStyle = lapelGrad;
  // Left lapel
  ctx.beginPath();
  ctx.moveTo(x - size * 0.2, y - size * 0.24);
  ctx.lineTo(x - size * 0.28, y + size * 0.18);
  ctx.lineTo(x - size * 0.1, y + size * 0.2);
  ctx.lineTo(x - size * 0.12, y - size * 0.2);
  ctx.closePath();
  ctx.fill();
  // Lapel highlight
  ctx.strokeStyle = "rgba(80, 80, 100, 0.4)";
  ctx.lineWidth = 1;
  ctx.stroke();
  // Right lapel
  ctx.beginPath();
  ctx.moveTo(x + size * 0.2, y - size * 0.24);
  ctx.lineTo(x + size * 0.28, y + size * 0.18);
  ctx.lineTo(x + size * 0.1, y + size * 0.2);
  ctx.lineTo(x + size * 0.12, y - size * 0.2);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Lapel flower (carnation)
  ctx.fillStyle = "#cc2233";
  ctx.beginPath();
  ctx.arc(x - size * 0.22, y - size * 0.08, size * 0.03, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#dd4455";
  ctx.beginPath();
  ctx.arc(x - size * 0.215, y - size * 0.085, size * 0.015, 0, Math.PI * 2);
  ctx.fill();

  // Ornate brocade vest
  const vestGrad = ctx.createLinearGradient(x - size * 0.15, y - size * 0.18, x + size * 0.15, y + size * 0.3);
  vestGrad.addColorStop(0, "#5a4530");
  vestGrad.addColorStop(0.3, "#7a6545");
  vestGrad.addColorStop(0.5, "#8b7555");
  vestGrad.addColorStop(0.7, "#7a6545");
  vestGrad.addColorStop(1, "#5a4530");
  ctx.fillStyle = vestGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.14, y - size * 0.2);
  ctx.lineTo(x - size * 0.16, y + size * 0.3);
  ctx.lineTo(x + size * 0.16, y + size * 0.3);
  ctx.lineTo(x + size * 0.14, y - size * 0.2);
  ctx.closePath();
  ctx.fill();

  // Vest brocade pattern
  ctx.strokeStyle = "rgba(180, 150, 100, 0.3)";
  ctx.lineWidth = 0.8;
  for (let pattern = 0; pattern < 4; pattern++) {
    const patternY = y - size * 0.1 + pattern * size * 0.1;
    ctx.beginPath();
    ctx.moveTo(x - size * 0.1, patternY);
    ctx.quadraticCurveTo(x, patternY - size * 0.02, x + size * 0.1, patternY);
    ctx.stroke();
  }

  // Vest border
  ctx.strokeStyle = "#4a3520";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.14, y - size * 0.2);
  ctx.lineTo(x - size * 0.16, y + size * 0.3);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.14, y - size * 0.2);
  ctx.lineTo(x + size * 0.16, y + size * 0.3);
  ctx.stroke();

  // Vest buttons (ornate gold)
  for (let i = 0; i < 4; i++) {
    const btnY = y - size * 0.1 + i * size * 0.095;
    // Button shadow
    ctx.fillStyle = "#8b6914";
    ctx.beginPath();
    ctx.arc(x + size * 0.005, btnY + size * 0.005, size * 0.022, 0, Math.PI * 2);
    ctx.fill();
    // Main button
    const btnGrad = ctx.createRadialGradient(x - size * 0.005, btnY - size * 0.005, 0, x, btnY, size * 0.022);
    btnGrad.addColorStop(0, "#ffec8b");
    btnGrad.addColorStop(0.5, "#daa520");
    btnGrad.addColorStop(1, "#b8860b");
    ctx.fillStyle = btnGrad;
    ctx.beginPath();
    ctx.arc(x, btnY, size * 0.022, 0, Math.PI * 2);
    ctx.fill();
    // Button highlight
    ctx.fillStyle = "rgba(255, 255, 220, 0.5)";
    ctx.beginPath();
    ctx.arc(x - size * 0.008, btnY - size * 0.008, size * 0.008, 0, Math.PI * 2);
    ctx.fill();
  }

  // Crisp white dress shirt
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.14, y - size * 0.22);
  ctx.lineTo(x - size * 0.2, y - size * 0.08);
  ctx.quadraticCurveTo(x, y - size * 0.14, x + size * 0.2, y - size * 0.08);
  ctx.lineTo(x + size * 0.14, y - size * 0.22);
  ctx.closePath();
  ctx.fill();
  // Shirt collar points
  ctx.beginPath();
  ctx.moveTo(x - size * 0.14, y - size * 0.22);
  ctx.lineTo(x - size * 0.18, y - size * 0.16);
  ctx.lineTo(x - size * 0.1, y - size * 0.18);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.14, y - size * 0.22);
  ctx.lineTo(x + size * 0.18, y - size * 0.16);
  ctx.lineTo(x + size * 0.1, y - size * 0.18);
  ctx.closePath();
  ctx.fill();

  // === ELEGANT GOLD & BLACK TIE ===
  if (isAttacking) {
    ctx.shadowColor = "#daa520";
    ctx.shadowBlur = 10 * zoom * attackIntensity;
  }
  const tieGrad = ctx.createLinearGradient(x, y - size * 0.18, x, y + size * 0.22);
  tieGrad.addColorStop(0, "#daa520");
  tieGrad.addColorStop(0.2, "#c9a227");
  tieGrad.addColorStop(0.5, "#b8860b");
  tieGrad.addColorStop(0.8, "#8b6914");
  tieGrad.addColorStop(1, "#6a5010");
  ctx.fillStyle = tieGrad;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.18);
  ctx.lineTo(x - size * 0.07, y + size * 0.14);
  ctx.lineTo(x, y + size * 0.22);
  ctx.lineTo(x + size * 0.07, y + size * 0.14);
  ctx.closePath();
  ctx.fill();
  // Tie diagonal stripes
  ctx.strokeStyle = "rgba(30, 20, 10, 0.3)";
  ctx.lineWidth = 1.5;
  for (let stripe = 0; stripe < 5; stripe++) {
    const stripeY = y - size * 0.1 + stripe * size * 0.06;
    ctx.beginPath();
    ctx.moveTo(x - size * 0.04, stripeY);
    ctx.lineTo(x + size * 0.04, stripeY + size * 0.03);
    ctx.stroke();
  }
  // Tie knot
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.16, size * 0.045, size * 0.028, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // === ELEGANT 1920S ARMS ===
  // Left arm - relaxed at side, gestures during attack
  const leftArmGesture = isAttacking ? Math.sin(attackPhase * Math.PI) * 0.5 : Math.sin(time * 1.2) * 0.08;
  // Right arm - holds pen, flourishes when writing/attacking
  const rightArmFlourish = isAttacking ? Math.sin(attackPhase * Math.PI * 1.5) * 0.6 + 0.3 : 0.15 + Math.sin(time * 2) * 0.05;
  
  // Left arm (suit sleeve)
  ctx.save();
  ctx.translate(x - size * 0.4, y - size * 0.08);
  ctx.rotate(-0.25 - leftArmGesture * 0.9);
  
  // Left sleeve (suit jacket)
  const leftSleeveGrad = ctx.createLinearGradient(0, 0, size * 0.1, size * 0.35);
  leftSleeveGrad.addColorStop(0, "#2a2a3a");
  leftSleeveGrad.addColorStop(0.5, "#353548");
  leftSleeveGrad.addColorStop(1, "#1a1a28");
  ctx.fillStyle = leftSleeveGrad;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.quadraticCurveTo(size * 0.07, size * 0.12, size * 0.04, size * 0.3);
  ctx.lineTo(-size * 0.06, size * 0.28);
  ctx.quadraticCurveTo(-size * 0.08, size * 0.12, 0, 0);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "#0a0a15";
  ctx.lineWidth = 1.2;
  ctx.stroke();
  
  // Left shirt cuff
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.ellipse(-size * 0.01, size * 0.29, size * 0.055, size * 0.022, -0.15, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = "#e8e8e8";
  ctx.lineWidth = 0.8;
  ctx.stroke();
  
  // Left cufflink (gold)
  ctx.fillStyle = "#daa520";
  ctx.beginPath();
  ctx.arc(-size * 0.01, size * 0.29, size * 0.012, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#ffec8b";
  ctx.beginPath();
  ctx.arc(-size * 0.014, size * 0.286, size * 0.005, 0, Math.PI * 2);
  ctx.fill();
  
  // Left hand
  ctx.fillStyle = "#ffe0bd";
  ctx.beginPath();
  ctx.ellipse(-size * 0.005, size * 0.35, size * 0.04, size * 0.055, -0.1, 0, Math.PI * 2);
  ctx.fill();
  // Fingers - relaxed or gesturing during attack
  ctx.strokeStyle = "#f5d0a8";
  ctx.lineWidth = 2.5 * zoom;
  ctx.lineCap = "round";
  if (isAttacking) {
    // Dramatic gesture with fingers spread
    for (let f = 0; f < 5; f++) {
      const fingerAngle = -0.5 + f * 0.25;
      const fingerLen = size * (0.035 + (f === 2 ? 0.01 : 0));
      ctx.beginPath();
      ctx.moveTo(-size * 0.005 + Math.cos(fingerAngle) * size * 0.025, size * 0.35 + Math.sin(fingerAngle) * size * 0.04);
      ctx.lineTo(-size * 0.005 + Math.cos(fingerAngle) * (size * 0.025 + fingerLen), size * 0.35 + Math.sin(fingerAngle) * (size * 0.04 + fingerLen * 0.5));
      ctx.stroke();
    }
  } else {
    // Relaxed fingers
    ctx.beginPath();
    ctx.arc(-size * 0.005, size * 0.38, size * 0.025, 0.2 * Math.PI, 0.8 * Math.PI);
    ctx.stroke();
  }
  ctx.restore();
  
  // Right arm (holding pen - more forward)
  ctx.save();
  ctx.translate(x + size * 0.38, y - size * 0.1);
  ctx.rotate(0.4 + rightArmFlourish * 0.7);
  
  // Right sleeve (suit jacket)
  const rightSleeveGrad = ctx.createLinearGradient(0, 0, -size * 0.1, size * 0.35);
  rightSleeveGrad.addColorStop(0, "#2a2a3a");
  rightSleeveGrad.addColorStop(0.5, "#353548");
  rightSleeveGrad.addColorStop(1, "#1a1a28");
  ctx.fillStyle = rightSleeveGrad;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.quadraticCurveTo(-size * 0.07, size * 0.12, -size * 0.04, size * 0.3);
  ctx.lineTo(size * 0.06, size * 0.28);
  ctx.quadraticCurveTo(size * 0.08, size * 0.12, 0, 0);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "#0a0a15";
  ctx.lineWidth = 1.2;
  ctx.stroke();
  
  // Right shirt cuff
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.ellipse(size * 0.01, size * 0.29, size * 0.055, size * 0.022, 0.15, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = "#e8e8e8";
  ctx.lineWidth = 0.8;
  ctx.stroke();
  
  // Right cufflink (gold)
  ctx.fillStyle = "#daa520";
  ctx.beginPath();
  ctx.arc(size * 0.01, size * 0.29, size * 0.012, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#ffec8b";
  ctx.beginPath();
  ctx.arc(size * 0.014, size * 0.286, size * 0.005, 0, Math.PI * 2);
  ctx.fill();
  
  // Right hand (holding pen)
  ctx.fillStyle = "#ffe0bd";
  ctx.beginPath();
  ctx.ellipse(size * 0.005, size * 0.35, size * 0.04, size * 0.055, 0.1, 0, Math.PI * 2);
  ctx.fill();
  // Fingers gripping the pen
  ctx.strokeStyle = "#f5d0a8";
  ctx.lineWidth = 2.5 * zoom;
  ctx.lineCap = "round";
  // Thumb
  ctx.beginPath();
  ctx.moveTo(size * 0.025, size * 0.33);
  ctx.quadraticCurveTo(size * 0.045, size * 0.35, size * 0.04, size * 0.38);
  ctx.stroke();
  // Index finger (pointing forward to hold pen)
  ctx.beginPath();
  ctx.moveTo(size * 0.015, size * 0.38);
  ctx.lineTo(size * 0.025, size * 0.44);
  ctx.stroke();
  // Other fingers curled
  ctx.beginPath();
  ctx.arc(-size * 0.005, size * 0.39, size * 0.025, 0.4 * Math.PI, 0.9 * Math.PI);
  ctx.stroke();
  ctx.restore();

  // === DISTINGUISHED HEAD ===
  const headY = y - size * 0.5;
  // Face with subtle gradient
  const faceGrad = ctx.createRadialGradient(x - size * 0.05, headY - size * 0.05, 0, x, headY, size * 0.28);
  faceGrad.addColorStop(0, "#ffe8d0");
  faceGrad.addColorStop(0.5, "#ffe0bd");
  faceGrad.addColorStop(1, "#f0c8a0");
  ctx.fillStyle = faceGrad;
  ctx.beginPath();
  ctx.arc(x, headY, size * 0.28, 0, Math.PI * 2);
  ctx.fill();

  // Chiseled jaw/chin
  ctx.fillStyle = "#f5d5b0";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.16, headY + size * 0.12);
  ctx.quadraticCurveTo(x - size * 0.1, headY + size * 0.22, x, headY + size * 0.26);
  ctx.quadraticCurveTo(x + size * 0.1, headY + size * 0.22, x + size * 0.16, headY + size * 0.12);
  ctx.closePath();
  ctx.fill();

  // Subtle cheekbone shadows
  ctx.fillStyle = "rgba(200, 160, 120, 0.2)";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.15, headY + size * 0.02, size * 0.06, size * 0.04, -0.3, 0, Math.PI * 2);
  ctx.fill();

  ctx.beginPath();
  ctx.ellipse(x + size * 0.15, headY + size * 0.02, size * 0.06, size * 0.04, 0.3, 0, Math.PI * 2);
  ctx.fill();

  // === SLICKED 1920S HAIR ===
  // Main hair
  const hairGrad = ctx.createLinearGradient(x - size * 0.2, headY - size * 0.2, x + size * 0.2, headY - size * 0.1);
  hairGrad.addColorStop(0, "#2a1810");
  hairGrad.addColorStop(0.3, "#3a2515");
  hairGrad.addColorStop(0.7, "#3a2515");
  hairGrad.addColorStop(1, "#2a1810");
  ctx.fillStyle = hairGrad;
  ctx.beginPath();
  ctx.ellipse(x, headY - size * 0.14, size * 0.27, size * 0.16, 0, Math.PI, Math.PI * 2);
  ctx.fill();

  // Hair wave on left side
  ctx.beginPath();
  ctx.moveTo(x - size * 0.2, headY - size * 0.12);
  ctx.quadraticCurveTo(x - size * 0.28, headY, x - size * 0.26, headY + size * 0.1);
  ctx.lineWidth = 5 * zoom;
  ctx.strokeStyle = "#3a2515";
  ctx.stroke();

  // Hair on right side
  ctx.beginPath();
  ctx.moveTo(x + size * 0.18, headY - size * 0.12);
  ctx.quadraticCurveTo(x + size * 0.24, headY - size * 0.02, x + size * 0.22, headY + size * 0.06);
  ctx.lineWidth = 4 * zoom;
  ctx.stroke();

  // Hair shine
  ctx.strokeStyle = "rgba(80, 60, 40, 0.4)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.1, headY - size * 0.22);
  ctx.quadraticCurveTo(x, headY - size * 0.26, x + size * 0.1, headY - size * 0.22);
  ctx.stroke();

  // Side part line
  ctx.strokeStyle = "#1a0a00";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x + size * 0.1, headY - size * 0.24);
  ctx.lineTo(x + size * 0.14, headY - size * 0.08);
  ctx.stroke();

  // === SOULFUL EYES ===
  // Eye socket shadows
  ctx.fillStyle = "rgba(180, 140, 100, 0.25)";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.1, headY - size * 0.02, size * 0.08, size * 0.05, -0.1, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.1, headY - size * 0.02, size * 0.08, size * 0.05, 0.1, 0, Math.PI * 2);
  ctx.fill();

  // Eye whites
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.1, headY - size * 0.02, size * 0.065, size * 0.055, -0.08, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x + size * 0.1, headY - size * 0.02, size * 0.065, size * 0.055, 0.08, 0, Math.PI * 2);
  ctx.fill();

  // Irises (glowing golden during attack, otherwise deep blue-grey)
  if (isAttacking) {
    ctx.shadowColor = "#daa520";
    ctx.shadowBlur = 8 * zoom * attackIntensity;
    ctx.fillStyle = `rgba(218, 165, 32, ${0.85 + attackIntensity * 0.15})`;
  } else {
    ctx.fillStyle = "#4a6080";
  }
  ctx.beginPath();
  ctx.arc(x - size * 0.1, headY - size * 0.02, size * 0.042, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + size * 0.1, headY - size * 0.02, size * 0.042, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Iris detail
  ctx.strokeStyle = isAttacking ? "#b8860b" : "#3a5070";
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.arc(x - size * 0.1, headY - size * 0.02, size * 0.035, 0, Math.PI * 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(x + size * 0.1, headY - size * 0.02, size * 0.035, 0, Math.PI * 2);
  ctx.stroke();

  // Pupils
  ctx.fillStyle = "#0a0a0a";
  ctx.beginPath();
  ctx.arc(x - size * 0.1, headY - size * 0.02, size * 0.02, 0, Math.PI * 2);
  ctx.arc(x + size * 0.1, headY - size * 0.02, size * 0.02, 0, Math.PI * 2);
  ctx.fill();

  // Eye highlights
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.arc(x - size * 0.115, headY - size * 0.035, size * 0.015, 0, Math.PI * 2);
  ctx.arc(x + size * 0.085, headY - size * 0.035, size * 0.015, 0, Math.PI * 2);
  ctx.fill();

  // Eyebrows (thoughtful, slightly furrowed)
  ctx.strokeStyle = "#3a2515";
  ctx.lineWidth = 2.5 * zoom;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.18, headY - size * 0.08);
  ctx.quadraticCurveTo(x - size * 0.1, headY - size * 0.11, x - size * 0.04, headY - size * 0.08);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.18, headY - size * 0.08);
  ctx.quadraticCurveTo(x + size * 0.1, headY - size * 0.11, x + size * 0.04, headY - size * 0.08);
  ctx.stroke();

  // Nose
  ctx.strokeStyle = "#c8a888";
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(x, headY - size * 0.02);
  ctx.lineTo(x - size * 0.02, headY + size * 0.08);
  ctx.quadraticCurveTo(x, headY + size * 0.1, x + size * 0.02, headY + size * 0.08);
  ctx.stroke();

  // Subtle smile/contemplative expression
  ctx.strokeStyle = "#a08070";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.08, headY + size * 0.14);
  ctx.quadraticCurveTo(x, headY + size * 0.16, x + size * 0.08, headY + size * 0.14);
  ctx.stroke();

  // === ORNATE MAGICAL FOUNTAIN PEN ===
  // Pen follows the right arm movement
  const penArmAngle = 0.4 + rightArmFlourish * 0.7;
  const penBaseX = x + size * 0.38 + Math.sin(penArmAngle) * size * 0.35;
  const penBaseY = y - size * 0.1 + Math.cos(penArmAngle) * size * 0.35;
  ctx.save();
  ctx.translate(penBaseX, penBaseY + writeGesture * 0.5);
  ctx.rotate(-0.5 + penArmAngle * 0.3 + quillFlourish * 0.25);

  // Pen glow during attack
  if (isAttacking) {
    ctx.shadowColor = "#daa520";
    ctx.shadowBlur = 15 * zoom * attackIntensity;
  }

  // Pen body (black lacquer with gold inlay)
  const penGrad = ctx.createLinearGradient(-size * 0.025, -size * 0.25, size * 0.025, -size * 0.25);
  penGrad.addColorStop(0, "#0a0a0a");
  penGrad.addColorStop(0.2, "#2a2a2a");
  penGrad.addColorStop(0.5, "#1a1a1a");
  penGrad.addColorStop(0.8, "#2a2a2a");
  penGrad.addColorStop(1, "#0a0a0a");
  ctx.fillStyle = penGrad;
  ctx.beginPath();
  ctx.roundRect(-size * 0.03, -size * 0.25, size * 0.06, size * 0.32, size * 0.01);
  ctx.fill();

  // Pen body highlight
  ctx.strokeStyle = "rgba(100, 100, 100, 0.3)";
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.moveTo(-size * 0.02, -size * 0.24);
  ctx.lineTo(-size * 0.02, size * 0.06);
  ctx.stroke();

  // Gold bands (ornate)
  const goldBandGrad = ctx.createLinearGradient(-size * 0.035, 0, size * 0.035, 0);
  goldBandGrad.addColorStop(0, "#b8860b");
  goldBandGrad.addColorStop(0.3, "#daa520");
  goldBandGrad.addColorStop(0.5, "#ffec8b");
  goldBandGrad.addColorStop(0.7, "#daa520");
  goldBandGrad.addColorStop(1, "#b8860b");
  ctx.fillStyle = goldBandGrad;
  ctx.fillRect(-size * 0.035, -size * 0.2, size * 0.07, size * 0.025);
  ctx.fillRect(-size * 0.035, -size * 0.12, size * 0.07, size * 0.015);
  ctx.fillRect(-size * 0.035, -size * 0.04, size * 0.07, size * 0.015);
  ctx.fillRect(-size * 0.035, size * 0.04, size * 0.07, size * 0.025);

  // Gold clip
  ctx.fillStyle = goldBandGrad;
  ctx.fillRect(size * 0.025, -size * 0.18, size * 0.015, size * 0.15);
  ctx.beginPath();
  ctx.arc(size * 0.0325, -size * 0.18, size * 0.0075, 0, Math.PI * 2);
  ctx.fill();

  // Nib section
  ctx.fillStyle = "#1a1a1a";
  ctx.beginPath();
  ctx.moveTo(-size * 0.025, -size * 0.25);
  ctx.lineTo(-size * 0.02, -size * 0.3);
  ctx.lineTo(size * 0.02, -size * 0.3);
  ctx.lineTo(size * 0.025, -size * 0.25);
  ctx.closePath();
  ctx.fill();

  // Gold nib
  const nibGrad = ctx.createLinearGradient(-size * 0.015, -size * 0.3, size * 0.015, -size * 0.3);
  nibGrad.addColorStop(0, "#b8860b");
  nibGrad.addColorStop(0.5, "#ffd700");
  nibGrad.addColorStop(1, "#b8860b");
  ctx.fillStyle = nibGrad;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.3);
  ctx.lineTo(-size * 0.018, -size * 0.38);
  ctx.lineTo(0, -size * 0.42);
  ctx.lineTo(size * 0.018, -size * 0.38);
  ctx.closePath();
  ctx.fill();

  // Nib slit
  ctx.strokeStyle = "#5a4010";
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.32);
  ctx.lineTo(0, -size * 0.4);
  ctx.stroke();

  // Ink flow during attack
  if (isAttacking && attackPhase > 0.2) {
    const inkPhase = (attackPhase - 0.2) / 0.8;
    for (let drop = 0; drop < 3; drop++) {
      const dropY = -size * 0.44 - inkPhase * size * 0.2 - drop * size * 0.05;
      const dropAlpha = (1 - inkPhase) * (1 - drop * 0.3);
      ctx.fillStyle = `rgba(20, 15, 10, ${dropAlpha})`;
      ctx.beginPath();
      ctx.ellipse(Math.sin(time * 10 + drop) * size * 0.01, dropY, size * 0.012, size * 0.018, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.shadowBlur = 0;
  ctx.restore();

  // === FLOATING MAGICAL WORDS (enhanced) ===
  const wordCount = isAttacking ? 8 : 5;
  const words = ["dream", "green", "light", "hope", "glory", "jazz", "Gatsby", "beauty"];
  for (let i = 0; i < wordCount; i++) {
    const wordPhase = (time * 0.6 + i * 0.4) % 3.5;
    const wordAngle = -0.6 + (i / wordCount) * 1.2;
    const wordX = x - size * 0.3 + Math.sin(wordAngle + wordPhase * Math.PI * 0.4) * size * 0.65;
    const wordY = y - size * 0.6 - wordPhase * size * 0.3;
    const wordAlpha = (1 - wordPhase / 3.5) * (isAttacking ? 0.95 : 0.6);
    const wordScale = 1 + (isAttacking ? attackIntensity * 0.3 : 0);

    ctx.fillStyle = `rgba(218, 165, 32, ${wordAlpha})`;
    ctx.shadowColor = "#daa520";
    ctx.shadowBlur = isAttacking ? 8 * zoom : 4 * zoom;
    ctx.font = `italic ${(10 + (isAttacking ? 4 : 0)) * zoom * wordScale}px Georgia`;
    ctx.textAlign = "center";
    ctx.fillText(words[i % words.length], wordX, wordY);
  }
  ctx.shadowBlur = 0;

  // === GOLDEN LITERARY AURA ===
  const auraGlow = 0.3 + Math.sin(time * 3.5) * 0.1 + attackIntensity * 0.3;
  ctx.strokeStyle = `rgba(218, 165, 32, ${auraGlow})`;
  ctx.lineWidth = (2 + attackIntensity * 2) * zoom;
  ctx.setLineDash([5 * zoom, 4 * zoom]);
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.08, size * 0.55, size * 0.7, 0, 0, Math.PI * 2);
  ctx.stroke();
  ctx.setLineDash([]);

  // Inner aura glow
  ctx.strokeStyle = `rgba(255, 215, 0, ${auraGlow * 0.4})`;
  ctx.lineWidth = (1.2 + attackIntensity * 1) * zoom;
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.08, size * 0.5, size * 0.65, 0, 0, Math.PI * 2);
  ctx.stroke();
}

function drawCaptainHero(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // ORNATE CAPTAIN - Elite Military Commander who rallies knights with inspiring presence
  const breathe = Math.sin(time * 2) * 2;
  const isAttacking = attackPhase > 0;
  const swordSwing = isAttacking ? Math.sin(attackPhase * Math.PI * 2) : 0;
  const commandPose = isAttacking ? Math.sin(attackPhase * Math.PI) : 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const gemPulse = Math.sin(time * 2.5) * 0.3 + 0.7;

  // === MULTI-LAYERED COMMAND AURA ===
  const auraBase = isAttacking ? 0.35 : 0.2;
  const auraPulse = 0.85 + Math.sin(time * 3) * 0.15;
  for (let auraLayer = 0; auraLayer < 4; auraLayer++) {
    const layerOffset = auraLayer * 0.1;
    const auraGrad = ctx.createRadialGradient(
      x, y, size * (0.1 + layerOffset),
      x, y, size * (0.95 + layerOffset * 0.2)
    );
    const layerAlpha = (auraBase - auraLayer * 0.04) * auraPulse;
    auraGrad.addColorStop(0, `rgba(220, 38, 38, ${layerAlpha * 0.6})`);
    auraGrad.addColorStop(0.4, `rgba(255, 80, 50, ${layerAlpha * 0.4})`);
    auraGrad.addColorStop(0.7, `rgba(255, 215, 0, ${layerAlpha * 0.2})`);
    auraGrad.addColorStop(1, "rgba(220, 38, 38, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
    ctx.ellipse(x, y, size * (0.9 + layerOffset * 0.15), size * (0.58 + layerOffset * 0.1), 0, 0, Math.PI * 2);
  ctx.fill();
  }

  // Floating command rune particles
  for (let p = 0; p < 10; p++) {
    const pAngle = (time * 1.5 + p * Math.PI * 0.2) % (Math.PI * 2);
    const pDist = size * 0.65 + Math.sin(time * 2.5 + p * 0.7) * size * 0.12;
    const px = x + Math.cos(pAngle) * pDist;
    const py = y + Math.sin(pAngle) * pDist * 0.5;
    const pAlpha = 0.6 + Math.sin(time * 4 + p * 0.6) * 0.25;
    ctx.fillStyle = p % 3 === 0 ? `rgba(255, 215, 0, ${pAlpha})` : `rgba(220, 38, 38, ${pAlpha})`;
  ctx.beginPath();
    ctx.arc(px, py, size * 0.02, 0, Math.PI * 2);
  ctx.fill();
    // Inner glow
    ctx.fillStyle = `rgba(255, 255, 200, ${pAlpha * 0.5})`;
    ctx.beginPath();
    ctx.arc(px, py, size * 0.008, 0, Math.PI * 2);
    ctx.fill();
  }

  // === SHADOW WITH DEPTH ===
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.52, 0, x, y + size * 0.52, size * 0.5);
  shadowGrad.addColorStop(0, "rgba(0, 0, 0, 0.55)");
  shadowGrad.addColorStop(0.6, "rgba(0, 0, 0, 0.3)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.52, size * 0.5, size * 0.16, 0, 0, Math.PI * 2);
  ctx.fill();

  // === ORNATE ROYAL CAPE ===
  const capeWave = Math.sin(time * 3.5) * 0.12;
  const capeWave2 = Math.sin(time * 4.2 + 0.5) * 0.08;

  // Cape shadow layer
  ctx.fillStyle = "#4a0000";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.24, y - size * 0.22);
  ctx.bezierCurveTo(
    x - size * 0.52 - capeWave * size, y + size * 0.15,
    x - size * 0.48 - capeWave2 * size, y + size * 0.45,
    x - size * 0.42, y + size * 0.62
  );
  ctx.lineTo(x + size * 0.42, y + size * 0.62);
  ctx.bezierCurveTo(
    x + size * 0.48 + capeWave2 * size, y + size * 0.45,
    x + size * 0.52 + capeWave * size, y + size * 0.15,
    x + size * 0.24, y - size * 0.22
  );
  ctx.closePath();
  ctx.fill();

  // Cape main with gradient
  const capeGrad = ctx.createLinearGradient(x - size * 0.5, y, x + size * 0.5, y);
  capeGrad.addColorStop(0, "#6a0000");
  capeGrad.addColorStop(0.2, "#8b0000");
  capeGrad.addColorStop(0.5, "#aa1515");
  capeGrad.addColorStop(0.8, "#8b0000");
  capeGrad.addColorStop(1, "#6a0000");
  ctx.fillStyle = capeGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.26, y - size * 0.24);
  ctx.bezierCurveTo(
    x - size * 0.55 - capeWave * size, y + size * 0.12,
    x - size * 0.5 - capeWave2 * size, y + size * 0.42,
    x - size * 0.4, y + size * 0.58
  );
  ctx.lineTo(x + size * 0.4, y + size * 0.58);
  ctx.bezierCurveTo(
    x + size * 0.5 + capeWave2 * size, y + size * 0.42,
    x + size * 0.55 + capeWave * size, y + size * 0.12,
    x + size * 0.26, y - size * 0.24
  );
  ctx.closePath();
  ctx.fill();

  // Cape gold trim
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.4, y + size * 0.58);
  ctx.bezierCurveTo(
    x - size * 0.5 - capeWave2 * size, y + size * 0.42,
    x - size * 0.55 - capeWave * size, y + size * 0.12,
    x - size * 0.26, y - size * 0.24
  );
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.4, y + size * 0.58);
  ctx.bezierCurveTo(
    x + size * 0.5 + capeWave2 * size, y + size * 0.42,
    x + size * 0.55 + capeWave * size, y + size * 0.12,
    x + size * 0.26, y - size * 0.24
  );
  ctx.stroke();

  // Cape embroidery pattern
  ctx.strokeStyle = "#daa520";
  ctx.lineWidth = 0.8;
  ctx.globalAlpha = 0.5;
  for (let row = 0; row < 3; row++) {
    const rowY = y + size * 0.1 + row * size * 0.15;
    for (let col = -1; col <= 1; col++) {
      const colX = x + col * size * 0.18;
      ctx.beginPath();
      ctx.arc(colX, rowY, size * 0.025, 0, Math.PI * 2);
      ctx.stroke();
    }
  }
  ctx.globalAlpha = 1;

  // Cape bottom fringe
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.5;
  for (let fringe = -4; fringe <= 4; fringe++) {
    const fringeX = x + fringe * size * 0.09;
    const fringeWave = Math.sin(time * 5 + fringe * 0.5) * size * 0.015;
    ctx.beginPath();
    ctx.moveTo(fringeX, y + size * 0.56);
    ctx.lineTo(fringeX + fringeWave, y + size * 0.62);
    ctx.stroke();
  }

  // === ORNATE ARMORED BODY ===
  const armorGrad = ctx.createLinearGradient(x - size * 0.42, y - size * 0.3, x + size * 0.42, y + size * 0.4);
  armorGrad.addColorStop(0, "#3a3a3a");
  armorGrad.addColorStop(0.15, "#5a5a5a");
  armorGrad.addColorStop(0.35, "#7a7a7a");
  armorGrad.addColorStop(0.5, "#909090");
  armorGrad.addColorStop(0.65, "#7a7a7a");
  armorGrad.addColorStop(0.85, "#5a5a5a");
  armorGrad.addColorStop(1, "#3a3a3a");
  ctx.fillStyle = armorGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.38, y + size * 0.52 + breathe);
  ctx.lineTo(x - size * 0.44, y - size * 0.08);
  ctx.lineTo(x - size * 0.3, y - size * 0.28);
  ctx.quadraticCurveTo(x, y - size * 0.38, x + size * 0.3, y - size * 0.28);
  ctx.lineTo(x + size * 0.44, y - size * 0.08);
  ctx.lineTo(x + size * 0.38, y + size * 0.52 + breathe);
  ctx.closePath();
  ctx.fill();

  // Armor edge highlight
  ctx.strokeStyle = "#a0a0a0";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.36, y + size * 0.5 + breathe);
  ctx.lineTo(x - size * 0.42, y - size * 0.06);
  ctx.lineTo(x - size * 0.28, y - size * 0.26);
  ctx.stroke();

  // Armor border
  ctx.strokeStyle = "#2a2a2a";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.38, y + size * 0.52 + breathe);
  ctx.lineTo(x - size * 0.44, y - size * 0.08);
  ctx.lineTo(x - size * 0.3, y - size * 0.28);
  ctx.quadraticCurveTo(x, y - size * 0.38, x + size * 0.3, y - size * 0.28);
  ctx.lineTo(x + size * 0.44, y - size * 0.08);
  ctx.lineTo(x + size * 0.38, y + size * 0.52 + breathe);
  ctx.closePath();
  ctx.stroke();

  // Armor segment lines
  ctx.strokeStyle = "#4a4a4a";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.34, y - size * 0.02);
  ctx.lineTo(x + size * 0.34, y - size * 0.02);
  ctx.moveTo(x - size * 0.32, y + size * 0.16);
  ctx.lineTo(x + size * 0.32, y + size * 0.16);
  ctx.moveTo(x - size * 0.3, y + size * 0.34);
  ctx.lineTo(x + size * 0.3, y + size * 0.34);
  ctx.stroke();

  // Red commander's V trim
  ctx.strokeStyle = "#dc2626";
  ctx.lineWidth = 3.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.36, y - size * 0.16);
  ctx.lineTo(x, y + size * 0.14);
  ctx.lineTo(x + size * 0.36, y - size * 0.16);
  ctx.stroke();
  ctx.strokeStyle = "#aa1818";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.32, y - size * 0.12);
  ctx.lineTo(x, y + size * 0.1);
  ctx.lineTo(x + size * 0.32, y - size * 0.12);
  ctx.stroke();

  // Gold filigree on armor
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 0.8;
  ctx.globalAlpha = 0.7;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.26, y - size * 0.18);
  ctx.quadraticCurveTo(x - size * 0.32, y - size * 0.06, x - size * 0.26, y + size * 0.06);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.26, y - size * 0.18);
  ctx.quadraticCurveTo(x + size * 0.32, y - size * 0.06, x + size * 0.26, y + size * 0.06);
  ctx.stroke();
  ctx.globalAlpha = 1;

  // Chest emblem (commander's star)
  ctx.fillStyle = "#daa520";
  ctx.beginPath();
  for (let star = 0; star < 6; star++) {
    const starAngle = star * Math.PI / 3 - Math.PI / 2;
    const innerR = size * 0.03;
    const outerR = size * 0.06;
    if (star === 0) {
      ctx.moveTo(x + Math.cos(starAngle) * outerR, y + Math.sin(starAngle) * outerR);
    } else {
      ctx.lineTo(x + Math.cos(starAngle) * outerR, y + Math.sin(starAngle) * outerR);
    }
    ctx.lineTo(x + Math.cos(starAngle + Math.PI / 6) * innerR, y + Math.sin(starAngle + Math.PI / 6) * innerR);
  }
  ctx.closePath();
  ctx.fill();
  // Star center gem
  ctx.fillStyle = "#dc2626";
  ctx.shadowColor = "#ff4444";
  ctx.shadowBlur = 4 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x, y, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // === ELABORATE PAULDRONS ===
  for (let side = -1; side <= 1; side += 2) {
    const pauldronX = x + side * size * 0.46;
    
    // Multi-layer pauldron
    const pauldronGrad = ctx.createRadialGradient(pauldronX, y - size * 0.16, 0, pauldronX, y - size * 0.16, size * 0.22);
    pauldronGrad.addColorStop(0, "#8a8a8a");
    pauldronGrad.addColorStop(0.5, "#6a6a6a");
    pauldronGrad.addColorStop(1, "#4a4a4a");
    ctx.fillStyle = pauldronGrad;
    ctx.beginPath();
    ctx.ellipse(pauldronX, y - size * 0.16, size * 0.2, size * 0.14, side * 0.3, 0, Math.PI * 2);
    ctx.fill();

    // Pauldron layers
    ctx.fillStyle = "#7a7a7a";
    ctx.beginPath();
    ctx.ellipse(pauldronX + side * size * 0.04, y - size * 0.12, size * 0.15, size * 0.1, side * 0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#6a6a6a";
    ctx.beginPath();
    ctx.ellipse(pauldronX + side * size * 0.06, y - size * 0.08, size * 0.11, size * 0.07, side * 0.3, 0, Math.PI * 2);
    ctx.fill();

    // Gold trim
    ctx.strokeStyle = "#c9a227";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.ellipse(pauldronX, y - size * 0.16, size * 0.2, size * 0.14, side * 0.3, 0, Math.PI * 2);
    ctx.stroke();

    // Red crest on pauldron
  ctx.fillStyle = "#dc2626";
  ctx.beginPath();
    ctx.ellipse(pauldronX, y - size * 0.2, size * 0.1, size * 0.055, 0, 0, Math.PI * 2);
  ctx.fill();
    // Crest highlight
    ctx.fillStyle = "#ff4444";
  ctx.beginPath();
    ctx.ellipse(pauldronX - size * 0.02, y - size * 0.21, size * 0.04, size * 0.025, 0, 0, Math.PI * 2);
  ctx.fill();

    // Pauldron gem
    ctx.fillStyle = "#daa520";
    ctx.shadowColor = "#ffdd00";
    ctx.shadowBlur = 4 * zoom * gemPulse;
    ctx.beginPath();
    ctx.arc(pauldronX, y - size * 0.16, size * 0.025, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Decorative spike
    ctx.fillStyle = "#5a5a5a";
    ctx.beginPath();
    ctx.moveTo(pauldronX + side * size * 0.14, y - size * 0.22);
    ctx.lineTo(pauldronX + side * size * 0.22, y - size * 0.35);
    ctx.lineTo(pauldronX + side * size * 0.1, y - size * 0.18);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "#8a8a8a";
    ctx.lineWidth = 0.8;
    ctx.beginPath();
    ctx.moveTo(pauldronX + side * size * 0.14, y - size * 0.22);
    ctx.lineTo(pauldronX + side * size * 0.21, y - size * 0.34);
    ctx.stroke();
  }

  // === COMMANDER'S ORNATE SWORD ===
  ctx.save();
  ctx.translate(x + size * 0.52, y + size * 0.1);
  ctx.rotate(0.75 + swordSwing * 1.3);

  // Blade glow during attack
  if (isAttacking) {
    ctx.shadowColor = "#ff4400";
    ctx.shadowBlur = 10 * zoom * attackIntensity;
  }

  // Blade with gradient
  const bladeGrad = ctx.createLinearGradient(-size * 0.045, -size * 0.1, size * 0.045, -size * 0.1);
  bladeGrad.addColorStop(0, "#909098");
  bladeGrad.addColorStop(0.2, "#c8c8d0");
  bladeGrad.addColorStop(0.4, "#e8e8f0");
  bladeGrad.addColorStop(0.5, "#ffffff");
  bladeGrad.addColorStop(0.6, "#e8e8f0");
  bladeGrad.addColorStop(0.8, "#c8c8d0");
  bladeGrad.addColorStop(1, "#909098");
  ctx.fillStyle = bladeGrad;
  ctx.beginPath();
  ctx.moveTo(-size * 0.045, -size * 0.02);
  ctx.lineTo(-size * 0.04, -size * 0.58);
  ctx.lineTo(0, -size * 0.68);
  ctx.lineTo(size * 0.04, -size * 0.58);
  ctx.lineTo(size * 0.045, -size * 0.02);
  ctx.closePath();
  ctx.fill();
  ctx.shadowBlur = 0;

  // Blade edge highlight
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 0.6;
  ctx.globalAlpha = 0.5;
  ctx.beginPath();
  ctx.moveTo(-size * 0.038, -size * 0.04);
  ctx.lineTo(-size * 0.035, -size * 0.56);
  ctx.lineTo(0, -size * 0.66);
  ctx.stroke();
  ctx.globalAlpha = 1;

  // Blade border
  ctx.strokeStyle = "#606068";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(-size * 0.045, -size * 0.02);
  ctx.lineTo(-size * 0.04, -size * 0.58);
  ctx.lineTo(0, -size * 0.68);
  ctx.lineTo(size * 0.04, -size * 0.58);
  ctx.lineTo(size * 0.045, -size * 0.02);
  ctx.closePath();
  ctx.stroke();

  // Fuller (blood groove)
  ctx.strokeStyle = "#707078";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.08);
  ctx.lineTo(0, -size * 0.48);
  ctx.stroke();

  // Runes on blade
  ctx.fillStyle = `rgba(220, 38, 38, ${0.5 + attackIntensity * 0.4})`;
  ctx.shadowColor = "#dc2626";
  ctx.shadowBlur = isAttacking ? 5 * zoom : 2 * zoom;
  for (let rune = 0; rune < 3; rune++) {
    ctx.beginPath();
    ctx.arc(0, -size * 0.15 - rune * size * 0.12, size * 0.015, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.shadowBlur = 0;

  // Ornate crossguard
  const guardGrad = ctx.createLinearGradient(-size * 0.14, 0, size * 0.14, 0);
  guardGrad.addColorStop(0, "#a08020");
  guardGrad.addColorStop(0.3, "#daa520");
  guardGrad.addColorStop(0.5, "#f0c040");
  guardGrad.addColorStop(0.7, "#daa520");
  guardGrad.addColorStop(1, "#a08020");
  ctx.fillStyle = guardGrad;
  ctx.beginPath();
  ctx.moveTo(-size * 0.14, 0);
  ctx.quadraticCurveTo(-size * 0.16, -size * 0.03, -size * 0.12, -size * 0.05);
  ctx.lineTo(size * 0.12, -size * 0.05);
  ctx.quadraticCurveTo(size * 0.16, -size * 0.03, size * 0.14, 0);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "#806010";
  ctx.lineWidth = 0.8;
  ctx.stroke();

  // Guard gems
  ctx.fillStyle = "#dc2626";
  ctx.shadowColor = "#ff4444";
  ctx.shadowBlur = 3 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(-size * 0.08, -size * 0.025, size * 0.02, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(size * 0.08, -size * 0.025, size * 0.02, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Hilt
  const hiltGrad = ctx.createLinearGradient(-size * 0.03, 0, size * 0.03, 0);
  hiltGrad.addColorStop(0, "#2a1005");
  hiltGrad.addColorStop(0.5, "#4a2a1a");
  hiltGrad.addColorStop(1, "#2a1005");
  ctx.fillStyle = hiltGrad;
  ctx.fillRect(-size * 0.03, -size * 0.02, size * 0.06, size * 0.16);
  // Hilt wrapping
  ctx.strokeStyle = "#5a3a2a";
  ctx.lineWidth = 1.5 * zoom;
  for (let wrap = 0; wrap < 4; wrap++) {
    ctx.beginPath();
    ctx.moveTo(-size * 0.03, wrap * size * 0.035);
    ctx.lineTo(size * 0.03, size * 0.015 + wrap * size * 0.035);
    ctx.stroke();
  }

  // Ornate pommel
  ctx.fillStyle = "#dc2626";
  ctx.beginPath();
  ctx.arc(0, size * 0.18, size * 0.055, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#ff5555";
  ctx.beginPath();
  ctx.arc(0, size * 0.18, size * 0.035, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#daa520";
  ctx.shadowColor = "#ffdd00";
  ctx.shadowBlur = 3 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(0, size * 0.18, size * 0.02, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // === ORNATE BATTLE STANDARD/BANNER ===
  ctx.save();
  ctx.translate(x - size * 0.58, y - size * 0.1);

  // Banner pole with gradient
  const poleGrad = ctx.createLinearGradient(-size * 0.025, -size * 0.7, size * 0.025, -size * 0.7);
  poleGrad.addColorStop(0, "#5a3010");
  poleGrad.addColorStop(0.5, "#8b4513");
  poleGrad.addColorStop(1, "#5a3010");
  ctx.fillStyle = poleGrad;
  ctx.fillRect(-size * 0.025, -size * 0.7, size * 0.05, size * 0.8);

  // Pole gold rings
  ctx.fillStyle = "#daa520";
  ctx.fillRect(-size * 0.03, -size * 0.7, size * 0.06, size * 0.03);
  ctx.fillRect(-size * 0.03, -size * 0.55, size * 0.06, size * 0.02);
  ctx.fillRect(-size * 0.03, -size * 0.2, size * 0.06, size * 0.02);

  // Pole finial
  ctx.fillStyle = "#daa520";
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.78);
  ctx.lineTo(-size * 0.05, -size * 0.7);
  ctx.lineTo(size * 0.05, -size * 0.7);
  ctx.closePath();
  ctx.fill();
  // Finial gem
  ctx.fillStyle = "#dc2626";
  ctx.shadowColor = "#ff4444";
  ctx.shadowBlur = 4 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(0, -size * 0.73, size * 0.018, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Banner fabric with wave
  const bannerWave = Math.sin(time * 4.5) * 0.18;
  const bannerWave2 = Math.sin(time * 5.2 + 0.5) * 0.1;

  // Banner shadow
  ctx.fillStyle = "#6a1010";
  ctx.beginPath();
  ctx.moveTo(size * 0.025, -size * 0.62);
  ctx.bezierCurveTo(
    size * 0.22 + bannerWave * size, -size * 0.58,
    size * 0.28 + bannerWave2 * size, -size * 0.42,
    size * 0.32, -size * 0.32
  );
  ctx.bezierCurveTo(
    size * 0.25 + bannerWave2 * size * 0.5, -size * 0.25,
    size * 0.18 + bannerWave * size * 0.3, -size * 0.18,
    size * 0.025, -size * 0.15
  );
  ctx.closePath();
  ctx.fill();

  // Banner main
  const bannerGrad = ctx.createLinearGradient(size * 0.025, -size * 0.4, size * 0.3, -size * 0.4);
  bannerGrad.addColorStop(0, "#aa1818");
  bannerGrad.addColorStop(0.5, "#dc2626");
  bannerGrad.addColorStop(1, "#aa1818");
  ctx.fillStyle = bannerGrad;
  ctx.beginPath();
  ctx.moveTo(size * 0.025, -size * 0.65);
  ctx.bezierCurveTo(
    size * 0.2 + bannerWave * size, -size * 0.6,
    size * 0.26 + bannerWave2 * size, -size * 0.45,
    size * 0.3, -size * 0.35
  );
  ctx.bezierCurveTo(
    size * 0.23 + bannerWave2 * size * 0.5, -size * 0.28,
    size * 0.16 + bannerWave * size * 0.3, -size * 0.2,
    size * 0.025, -size * 0.18
  );
  ctx.closePath();
  ctx.fill();

  // Banner gold trim
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Banner emblem (golden P)
  ctx.fillStyle = "#daa520";
  ctx.beginPath();
  ctx.arc(size * 0.14, -size * 0.42, size * 0.07, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#f0c040";
  ctx.beginPath();
  ctx.arc(size * 0.14, -size * 0.42, size * 0.05, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#aa1818";
  ctx.font = `bold ${9 * zoom}px serif`;
  ctx.textAlign = "center";
  ctx.fillText("P", size * 0.14, -size * 0.395);

  // Banner fringe
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1;
  for (let fringe = 0; fringe < 4; fringe++) {
    const fringeT = fringe / 3;
    const fx = size * 0.025 + (size * 0.28 - size * 0.025) * fringeT;
    const fy = -size * 0.18 + (-size * 0.35 + size * 0.18) * fringeT + Math.sin(time * 6 + fringe) * size * 0.01;
    ctx.beginPath();
    ctx.moveTo(fx, fy);
    ctx.lineTo(fx + size * 0.02, fy + size * 0.04);
    ctx.stroke();
  }
  ctx.restore();

  // === ORNATE HELMETED HEAD ===
  const headGrad = ctx.createRadialGradient(
    x - size * 0.05, y - size * 0.55, size * 0.05,
    x, y - size * 0.5, size * 0.32
  );
  headGrad.addColorStop(0, "#909090");
  headGrad.addColorStop(0.3, "#7a7a7a");
  headGrad.addColorStop(0.6, "#5a5a5a");
  headGrad.addColorStop(1, "#3a3a3a");
  ctx.fillStyle = headGrad;
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.5, size * 0.3, size * 0.28, 0, 0, Math.PI * 2);
  ctx.fill();

  // Helm ridge/crest
  ctx.fillStyle = "#5a5a5a";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.03, y - size * 0.78);
  ctx.lineTo(x - size * 0.04, y - size * 0.5);
  ctx.lineTo(x + size * 0.04, y - size * 0.5);
  ctx.lineTo(x + size * 0.03, y - size * 0.78);
  ctx.closePath();
  ctx.fill();

  // Helm gold crown band
  ctx.strokeStyle = "#daa520";
  ctx.lineWidth = 3 * zoom;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.5, size * 0.3, Math.PI * 1.1, Math.PI * 1.9);
  ctx.stroke();
  ctx.strokeStyle = "#a08020";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.5, size * 0.27, Math.PI * 1.15, Math.PI * 1.85);
  ctx.stroke();

  // Crown points
  ctx.fillStyle = "#daa520";
  for (let crown = -2; crown <= 2; crown++) {
    const crownX = x + crown * size * 0.08;
    ctx.beginPath();
    ctx.moveTo(crownX - size * 0.02, y - size * 0.72);
    ctx.lineTo(crownX, y - size * 0.8);
    ctx.lineTo(crownX + size * 0.02, y - size * 0.72);
    ctx.closePath();
    ctx.fill();
  }

  // Helm border
  ctx.strokeStyle = "#2a2a2a";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.ellipse(x, y - size * 0.5, size * 0.3, size * 0.28, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Detailed visor
  ctx.fillStyle = "#1a1a1a";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.22, y - size * 0.56);
  ctx.lineTo(x + size * 0.22, y - size * 0.56);
  ctx.lineTo(x + size * 0.18, y - size * 0.4);
  ctx.lineTo(x - size * 0.18, y - size * 0.4);
  ctx.closePath();
  ctx.fill();

  // Visor frame
  ctx.strokeStyle = "#4a4a4a";
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Visor slits with glow
  ctx.fillStyle = isAttacking
    ? `rgba(220, 38, 38, ${0.7 + attackIntensity * 0.3})`
    : "rgba(180, 50, 30, 0.5)";
  if (isAttacking) {
    ctx.shadowColor = "#dc2626";
    ctx.shadowBlur = 6 * zoom;
  }
  for (let slit = 0; slit < 6; slit++) {
    const slitX = x - size * 0.15 + slit * size * 0.06;
    ctx.fillRect(slitX - size * 0.012, y - size * 0.54, size * 0.024, size * 0.1);
  }
  ctx.shadowBlur = 0;

  // Visor air holes
  ctx.fillStyle = "#0a0a0a";
  for (let hole = 0; hole < 5; hole++) {
    ctx.beginPath();
    ctx.arc(x - size * 0.1 + hole * size * 0.05, y - size * 0.42, size * 0.012, 0, Math.PI * 2);
    ctx.fill();
  }

  // Helm center gem
  ctx.fillStyle = "#dc2626";
  ctx.shadowColor = "#ff4444";
  ctx.shadowBlur = 5 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.78, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // === MAJESTIC RED PLUME ===
  // Plume shadow
  for (let i = 0; i < 7; i++) {
    const plumeX = x + (i - 3) * size * 0.045;
    const plumeWave = Math.sin(time * 4.5 + i * 0.35) * 5;
    const plumeLen = size * (0.35 + Math.abs(i - 3) * 0.025);
    ctx.strokeStyle = "#6a1010";
    ctx.lineWidth = (6 - Math.abs(i - 3) * 0.7) * zoom;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(plumeX + size * 0.01, y - size * 0.76);
  ctx.quadraticCurveTo(
      plumeX + plumeWave * 1.6 + size * 0.01,
      y - size * 0.92 - plumeLen * 0.5,
      plumeX + plumeWave * 0.85 + size * 0.01,
      y - size * 0.76 - plumeLen
    );
    ctx.stroke();
  }

  // Main plume
  for (let i = 0; i < 7; i++) {
    const plumeX = x + (i - 3) * size * 0.045;
    const plumeWave = Math.sin(time * 4.5 + i * 0.35) * 5;
    const plumeLen = size * (0.35 + Math.abs(i - 3) * 0.025);
    ctx.strokeStyle = i % 2 === 0 ? "#dc2626" : "#aa1818";
    ctx.lineWidth = (5.5 - Math.abs(i - 3) * 0.65) * zoom;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(plumeX, y - size * 0.78);
    ctx.quadraticCurveTo(
      plumeX + plumeWave * 1.5,
      y - size * 0.94 - plumeLen * 0.5,
      plumeX + plumeWave * 0.8,
      y - size * 0.78 - plumeLen
    );
    ctx.stroke();
  }

  // Plume highlights
  for (let i = 1; i < 6; i += 2) {
    const plumeX = x + (i - 3) * size * 0.045;
    const plumeWave = Math.sin(time * 4.5 + i * 0.35) * 5;
    const plumeLen = size * (0.32 + Math.abs(i - 3) * 0.02);
    ctx.strokeStyle = "#ff6666";
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.moveTo(plumeX, y - size * 0.8);
    ctx.quadraticCurveTo(
      plumeX + plumeWave * 1.2,
      y - size * 0.9 - plumeLen * 0.4,
      plumeX + plumeWave * 0.6,
      y - size * 0.8 - plumeLen * 0.85
    );
    ctx.stroke();
  }

  // === ENHANCED COMMAND EFFECT WHEN ATTACKING ===
  if (isAttacking) {
    // Outer command rings
    for (let ring = 0; ring < 4; ring++) {
      const ringRadius = size * (0.55 + ring * 0.18 + commandPose * 0.25);
      const ringAlpha = commandPose * (0.5 - ring * 0.1);
      
      // Gold outer ring
      ctx.strokeStyle = `rgba(255, 215, 0, ${ringAlpha})`;
      ctx.lineWidth = 2.5 * zoom;
      ctx.beginPath();
      ctx.ellipse(x, y, ringRadius, ringRadius * 0.5, 0, 0, Math.PI * 2);
      ctx.stroke();
      
      // Red inner ring
      ctx.strokeStyle = `rgba(220, 38, 38, ${ringAlpha * 0.7})`;
      ctx.lineWidth = 1.5 * zoom;
      ctx.beginPath();
      ctx.ellipse(x, y, ringRadius * 0.95, ringRadius * 0.47, 0, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Command spark particles
    for (let spark = 0; spark < 12; spark++) {
      const sparkAngle = (time * 4 + spark * Math.PI * 2 / 12) % (Math.PI * 2);
      const sparkDist = size * (0.6 + commandPose * 0.4);
      const sparkX = x + Math.cos(sparkAngle) * sparkDist;
      const sparkY = y + Math.sin(sparkAngle) * sparkDist * 0.5;
      const sparkAlpha = commandPose * (0.7 + Math.sin(time * 8 + spark) * 0.3);
      
      ctx.fillStyle = spark % 2 === 0 
        ? `rgba(255, 215, 0, ${sparkAlpha})`
        : `rgba(220, 38, 38, ${sparkAlpha})`;
      ctx.beginPath();
      ctx.arc(sparkX, sparkY, size * 0.025, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}


function drawEngineerHero(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // SCI-FI ENGINEER - Advanced Tech Specialist with holographic displays and nano-tools
  const breathe = Math.sin(time * 2) * 1.5;
  const isAttacking = attackPhase > 0;
  const workAnimation = isAttacking ? Math.sin(attackPhase * Math.PI * 4) : 0;
  const toolSpark = isAttacking ? Math.sin(attackPhase * Math.PI * 8) : 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0
  const dataPulse = Math.sin(time * 5) * 0.5 + 0.5;
  const holoFlicker = Math.sin(time * 15) * 0.1 + 0.9;

  // === MULTI-LAYERED TECH AURA ===
  const auraBase = isAttacking ? 0.35 : 0.2;
  const auraPulse = 0.85 + Math.sin(time * 4) * 0.15;
  for (let auraLayer = 0; auraLayer < 4; auraLayer++) {
    const layerOffset = auraLayer * 0.08;
    const auraGrad = ctx.createRadialGradient(
      x, y, size * (0.1 + layerOffset),
      x, y, size * (0.9 + layerOffset * 0.3)
    );
    const layerAlpha = (auraBase - auraLayer * 0.04) * auraPulse;
    auraGrad.addColorStop(0, `rgba(0, 200, 255, ${layerAlpha * 0.4})`);
    auraGrad.addColorStop(0.4, `rgba(100, 220, 255, ${layerAlpha * 0.3})`);
    auraGrad.addColorStop(0.7, `rgba(234, 179, 8, ${layerAlpha * 0.2})`);
    auraGrad.addColorStop(1, "rgba(0, 200, 255, 0)");
    ctx.fillStyle = auraGrad;
    ctx.beginPath();
    ctx.ellipse(x, y, size * (0.85 + layerOffset * 0.2), size * (0.55 + layerOffset * 0.12), 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Floating data particles
  for (let p = 0; p < 12; p++) {
    const pAngle = (time * 2 + p * Math.PI * 2 / 12) % (Math.PI * 2);
    const pDist = size * 0.6 + Math.sin(time * 3 + p * 0.8) * size * 0.1;
    const px = x + Math.cos(pAngle) * pDist;
    const py = y + Math.sin(pAngle) * pDist * 0.45;
    const pAlpha = 0.5 + Math.sin(time * 6 + p * 0.7) * 0.3;
    ctx.fillStyle = p % 3 === 0 ? `rgba(0, 220, 255, ${pAlpha})` : p % 3 === 1 ? `rgba(234, 179, 8, ${pAlpha})` : `rgba(0, 255, 150, ${pAlpha})`;
    ctx.beginPath();
    ctx.rect(px - size * 0.01, py - size * 0.01, size * 0.02, size * 0.02);
    ctx.fill();
  }

  // === HOLOGRAPHIC CIRCUIT LINES ===
  ctx.strokeStyle = `rgba(0, 200, 255, ${0.3 + dataPulse * 0.2})`;
  ctx.lineWidth = 1 * zoom;
  for (let circuit = 0; circuit < 6; circuit++) {
    const circuitAngle = circuit * Math.PI / 3 + time * 0.5;
    const circuitDist = size * 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(circuitAngle) * circuitDist, y + Math.sin(circuitAngle) * circuitDist * 0.5);
    ctx.stroke();
    // Circuit node
    ctx.fillStyle = `rgba(0, 255, 200, ${0.5 + dataPulse * 0.3})`;
    ctx.beginPath();
    ctx.arc(x + Math.cos(circuitAngle) * circuitDist * 0.7, y + Math.sin(circuitAngle) * circuitDist * 0.35, size * 0.015, 0, Math.PI * 2);
    ctx.fill();
  }

  // === SHADOW WITH DEPTH ===
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.52, 0, x, y + size * 0.52, size * 0.48);
  shadowGrad.addColorStop(0, "rgba(0, 0, 0, 0.5)");
  shadowGrad.addColorStop(0.6, "rgba(0, 0, 0, 0.25)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.52, size * 0.45, size * 0.14, 0, 0, Math.PI * 2);
  ctx.fill();

  // === ADVANCED TECH BACKPACK ===
  // Main backpack body
  const backpackGrad = ctx.createLinearGradient(x - size * 0.25, y - size * 0.2, x + size * 0.25, y + size * 0.3);
  backpackGrad.addColorStop(0, "#3a3a4a");
  backpackGrad.addColorStop(0.3, "#4a4a5a");
  backpackGrad.addColorStop(0.7, "#3a3a4a");
  backpackGrad.addColorStop(1, "#2a2a3a");
  ctx.fillStyle = backpackGrad;
  ctx.beginPath();
  ctx.roundRect(x - size * 0.24, y - size * 0.22, size * 0.48, size * 0.55, size * 0.06);
  ctx.fill();

  // Backpack border
  ctx.strokeStyle = "#5a5a6a";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.roundRect(x - size * 0.24, y - size * 0.22, size * 0.48, size * 0.55, size * 0.06);
  ctx.stroke();

  // Tech panels on backpack
  ctx.fillStyle = "#2a2a3a";
  for (let panel = 0; panel < 4; panel++) {
    ctx.fillRect(x - size * 0.18, y - size * 0.15 + panel * size * 0.12, size * 0.36, size * 0.08);
    // Panel light strip
    const panelGlow = Math.sin(time * 4 + panel * 0.8) * 0.3 + 0.5;
    ctx.fillStyle = `rgba(0, 200, 255, ${panelGlow})`;
    ctx.fillRect(x - size * 0.16, y - size * 0.14 + panel * size * 0.12, size * 0.32, size * 0.02);
    ctx.fillStyle = "#2a2a3a";
  }

  // Central reactor core
  const reactorGrad = ctx.createRadialGradient(x, y + size * 0.08, 0, x, y + size * 0.08, size * 0.1);
  reactorGrad.addColorStop(0, `rgba(0, 255, 200, ${0.8 + dataPulse * 0.2})`);
  reactorGrad.addColorStop(0.5, `rgba(0, 200, 255, ${0.6 + dataPulse * 0.2})`);
  reactorGrad.addColorStop(1, "rgba(0, 100, 150, 0.3)");
  ctx.fillStyle = reactorGrad;
  ctx.shadowColor = "#00ffcc";
  ctx.shadowBlur = 10 * zoom * (0.7 + dataPulse * 0.3);
  ctx.beginPath();
  ctx.arc(x, y + size * 0.08, size * 0.08, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Reactor ring
  ctx.strokeStyle = "#00ccff";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x, y + size * 0.08, size * 0.1, 0, Math.PI * 2);
  ctx.stroke();

  // Exhaust vents
  for (let vent = 0; vent < 3; vent++) {
    const ventX = x - size * 0.15 + vent * size * 0.15;
    ctx.fillStyle = "#1a1a2a";
    ctx.beginPath();
    ctx.ellipse(ventX, y + size * 0.28, size * 0.03, size * 0.02, 0, 0, Math.PI * 2);
    ctx.fill();
    // Vent glow when attacking
    if (isAttacking) {
      ctx.fillStyle = `rgba(255, 150, 50, ${attackIntensity * 0.6})`;
      ctx.beginPath();
      ctx.ellipse(ventX, y + size * 0.28, size * 0.02, size * 0.01, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // === ADVANCED EXOSUIT BODY ===
  const suitGrad = ctx.createLinearGradient(x - size * 0.4, y - size * 0.3, x + size * 0.4, y + size * 0.4);
  suitGrad.addColorStop(0, "#3a4a30");
  suitGrad.addColorStop(0.2, "#5a6a40");
  suitGrad.addColorStop(0.5, "#7a8a50");
  suitGrad.addColorStop(0.8, "#5a6a40");
  suitGrad.addColorStop(1, "#3a4a30");
  ctx.fillStyle = suitGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.38, y + size * 0.48 + breathe);
  ctx.lineTo(x - size * 0.42, y - size * 0.1);
  ctx.lineTo(x - size * 0.3, y - size * 0.25);
  ctx.quadraticCurveTo(x, y - size * 0.32, x + size * 0.3, y - size * 0.25);
  ctx.lineTo(x + size * 0.42, y - size * 0.1);
  ctx.lineTo(x + size * 0.38, y + size * 0.48 + breathe);
  ctx.closePath();
  ctx.fill();

  // Suit border
  ctx.strokeStyle = "#2a3a20";
  ctx.lineWidth = 2;
  ctx.stroke();

  // Armor panel lines
  ctx.strokeStyle = "#4a5a38";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.34, y - size * 0.05);
  ctx.lineTo(x + size * 0.34, y - size * 0.05);
  ctx.moveTo(x - size * 0.32, y + size * 0.15);
  ctx.lineTo(x + size * 0.32, y + size * 0.15);
  ctx.moveTo(x - size * 0.3, y + size * 0.35);
  ctx.lineTo(x + size * 0.3, y + size * 0.35);
  ctx.stroke();

  // Hi-vis orange safety strips (reflective)
  const stripGrad = ctx.createLinearGradient(x - size * 0.35, y, x - size * 0.25, y);
  stripGrad.addColorStop(0, "#cc4400");
  stripGrad.addColorStop(0.3, "#ff6600");
  stripGrad.addColorStop(0.5, "#ffaa44");
  stripGrad.addColorStop(0.7, "#ff6600");
  stripGrad.addColorStop(1, "#cc4400");
  ctx.fillStyle = stripGrad;
  ctx.fillRect(x - size * 0.35, y - size * 0.18, size * 0.1, size * 0.45);
  ctx.fillRect(x + size * 0.25, y - size * 0.18, size * 0.1, size * 0.45);

  // Reflective highlights on strips
  ctx.fillStyle = "rgba(255, 255, 200, 0.3)";
  ctx.fillRect(x - size * 0.34, y - size * 0.16, size * 0.03, size * 0.4);
  ctx.fillRect(x + size * 0.31, y - size * 0.16, size * 0.03, size * 0.4);

  // Chest status display
  ctx.fillStyle = "#1a1a2a";
  ctx.fillRect(x - size * 0.12, y - size * 0.15, size * 0.24, size * 0.12);
  ctx.strokeStyle = "#00aaff";
  ctx.lineWidth = 1;
  ctx.strokeRect(x - size * 0.12, y - size * 0.15, size * 0.24, size * 0.12);

  // Display content (scrolling data)
  ctx.fillStyle = `rgba(0, 255, 200, ${0.6 + dataPulse * 0.3})`;
  const dataOffset = (time * 50) % (size * 0.2);
  for (let line = 0; line < 3; line++) {
    const lineY = y - size * 0.13 + line * size * 0.035;
    ctx.fillRect(x - size * 0.1, lineY, size * 0.08 + Math.sin(time * 3 + line) * size * 0.04, size * 0.015);
  }

  // === ADVANCED UTILITY BELT ===
  const beltGrad = ctx.createLinearGradient(x - size * 0.4, y + size * 0.18, x + size * 0.4, y + size * 0.18);
  beltGrad.addColorStop(0, "#3a3a3a");
  beltGrad.addColorStop(0.5, "#5a5a5a");
  beltGrad.addColorStop(1, "#3a3a3a");
  ctx.fillStyle = beltGrad;
  ctx.fillRect(x - size * 0.4, y + size * 0.16, size * 0.8, size * 0.12);
  ctx.strokeStyle = "#6a6a6a";
  ctx.lineWidth = 1;
  ctx.strokeRect(x - size * 0.4, y + size * 0.16, size * 0.8, size * 0.12);

  // Belt pouches with tech details
  for (let pouch = 0; pouch < 4; pouch++) {
    const pouchX = x - size * 0.34 + pouch * size * 0.2;
    ctx.fillStyle = "#2a2a2a";
    ctx.beginPath();
    ctx.roundRect(pouchX, y + size * 0.13, size * 0.14, size * 0.18, size * 0.02);
    ctx.fill();
    ctx.strokeStyle = "#4a4a4a";
    ctx.stroke();
    // Pouch status light
    ctx.fillStyle = pouch % 2 === 0 ? `rgba(0, 255, 150, ${0.5 + dataPulse * 0.3})` : `rgba(255, 200, 50, ${0.5 + dataPulse * 0.3})`;
    ctx.beginPath();
    ctx.arc(pouchX + size * 0.07, y + size * 0.16, size * 0.015, 0, Math.PI * 2);
    ctx.fill();
  }

  // Belt buckle (tech)
  ctx.fillStyle = "#4a4a5a";
  ctx.beginPath();
  ctx.roundRect(x - size * 0.06, y + size * 0.17, size * 0.12, size * 0.08, size * 0.01);
  ctx.fill();
  ctx.fillStyle = `rgba(234, 179, 8, ${0.6 + dataPulse * 0.3})`;
  ctx.beginPath();
  ctx.arc(x, y + size * 0.21, size * 0.025, 0, Math.PI * 2);
  ctx.fill();

  // === MECHANICAL ARMS WITH TECH TOOLS ===
  // Left arm (with gauntlet)
  const leftArmGrad = ctx.createRadialGradient(
    x - size * 0.42, y - size * 0.05 + workAnimation * size * 0.05, 0,
    x - size * 0.42, y - size * 0.05 + workAnimation * size * 0.05, size * 0.18
  );
  leftArmGrad.addColorStop(0, "#6a7a50");
  leftArmGrad.addColorStop(0.7, "#5a6a40");
  leftArmGrad.addColorStop(1, "#4a5a30");
  ctx.fillStyle = leftArmGrad;
  ctx.beginPath();
  ctx.ellipse(
    x - size * 0.42,
    y - size * 0.05 + workAnimation * size * 0.05,
    size * 0.14,
    size * 0.22,
    -0.25,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Left gauntlet
  ctx.fillStyle = "#3a3a4a";
  ctx.beginPath();
  ctx.ellipse(
    x - size * 0.48,
    y + size * 0.12 + workAnimation * size * 0.05,
    size * 0.1,
    size * 0.08,
    -0.3,
    0,
    Math.PI * 2
  );
  ctx.fill();
  // Gauntlet lights
  ctx.fillStyle = `rgba(0, 200, 255, ${0.6 + dataPulse * 0.3})`;
  for (let light = 0; light < 3; light++) {
    ctx.beginPath();
    ctx.arc(x - size * 0.52 + light * size * 0.04, y + size * 0.1 + workAnimation * size * 0.05, size * 0.012, 0, Math.PI * 2);
    ctx.fill();
  }

  // High-tech wrench tool
  ctx.save();
  ctx.translate(x - size * 0.55, y + size * 0.15 + workAnimation * size * 0.05);
  ctx.rotate(-0.6 + workAnimation * 0.35);

  // Wrench handle (metallic)
  const wrenchGrad = ctx.createLinearGradient(-size * 0.03, 0, size * 0.03, 0);
  wrenchGrad.addColorStop(0, "#5a5a5a");
  wrenchGrad.addColorStop(0.3, "#8a8a8a");
  wrenchGrad.addColorStop(0.7, "#8a8a8a");
  wrenchGrad.addColorStop(1, "#5a5a5a");
  ctx.fillStyle = wrenchGrad;
  ctx.fillRect(-size * 0.025, -size * 0.28, size * 0.05, size * 0.28);

  // Wrench head (adjustable)
  ctx.fillStyle = "#6a6a6a";
  ctx.beginPath();
  ctx.roundRect(-size * 0.07, -size * 0.32, size * 0.14, size * 0.08, size * 0.01);
  ctx.fill();
  // Adjustment mechanism
  ctx.fillStyle = "#4a4a4a";
  ctx.fillRect(-size * 0.06, -size * 0.3, size * 0.04, size * 0.04);
  // Wrench jaw
  ctx.fillStyle = "#7a7a7a";
  ctx.fillRect(-size * 0.06, -size * 0.34, size * 0.12, size * 0.02);

  // Power indicator on wrench
  ctx.fillStyle = `rgba(0, 255, 150, ${0.5 + dataPulse * 0.4})`;
  ctx.beginPath();
  ctx.arc(0, -size * 0.15, size * 0.015, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // Right arm (with plasma tool)
  const rightArmGrad = ctx.createRadialGradient(
    x + size * 0.42, y - size * 0.05 - workAnimation * size * 0.05, 0,
    x + size * 0.42, y - size * 0.05 - workAnimation * size * 0.05, size * 0.18
  );
  rightArmGrad.addColorStop(0, "#6a7a50");
  rightArmGrad.addColorStop(0.7, "#5a6a40");
  rightArmGrad.addColorStop(1, "#4a5a30");
  ctx.fillStyle = rightArmGrad;
  ctx.beginPath();
  ctx.ellipse(
    x + size * 0.42,
    y - size * 0.05 - workAnimation * size * 0.05,
    size * 0.14,
    size * 0.22,
    0.25,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Right gauntlet
  ctx.fillStyle = "#3a3a4a";
  ctx.beginPath();
  ctx.ellipse(
    x + size * 0.48,
    y + size * 0.12 - workAnimation * size * 0.05,
    size * 0.1,
    size * 0.08,
    0.3,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Plasma welding/cutting tool
  ctx.save();
  ctx.translate(x + size * 0.55, y + size * 0.1 - workAnimation * size * 0.05);
  ctx.rotate(0.4 - workAnimation * 0.25);

  // Tool body
  const toolGrad = ctx.createLinearGradient(-size * 0.025, 0, size * 0.025, 0);
  toolGrad.addColorStop(0, "#3a3a4a");
  toolGrad.addColorStop(0.5, "#5a5a6a");
  toolGrad.addColorStop(1, "#3a3a4a");
  ctx.fillStyle = toolGrad;
  ctx.beginPath();
  ctx.roundRect(-size * 0.03, -size * 0.25, size * 0.06, size * 0.25, size * 0.01);
  ctx.fill();

  // Tool grip
  ctx.fillStyle = "#2a2a2a";
  ctx.fillRect(-size * 0.035, -size * 0.1, size * 0.07, size * 0.12);

  // Tool emitter head
  ctx.fillStyle = "#4a4a5a";
  ctx.beginPath();
  ctx.ellipse(0, -size * 0.27, size * 0.04, size * 0.025, 0, 0, Math.PI * 2);
  ctx.fill();

  // Plasma/welding effect
  if (isAttacking || Math.sin(time * 3) > 0.5) {
    const sparkIntensity = isAttacking ? Math.abs(toolSpark) : 0.4 + Math.sin(time * 8) * 0.3;
    
    // Plasma glow
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 15 * zoom * sparkIntensity;
    ctx.fillStyle = `rgba(0, 255, 255, ${sparkIntensity})`;
    ctx.beginPath();
    ctx.arc(0, -size * 0.3, size * 0.03, 0, Math.PI * 2);
    ctx.fill();

    // Plasma beam
    ctx.fillStyle = `rgba(100, 255, 255, ${sparkIntensity * 0.8})`;
    ctx.beginPath();
    ctx.moveTo(-size * 0.01, -size * 0.3);
    ctx.lineTo(0, -size * 0.4 - sparkIntensity * size * 0.1);
    ctx.lineTo(size * 0.01, -size * 0.3);
    ctx.closePath();
    ctx.fill();

    // Spark particles
    for (let spark = 0; spark < 6; spark++) {
      const sparkAngle = time * 15 + spark * Math.PI / 3;
      const sparkDist = size * 0.05 + Math.sin(time * 20 + spark) * size * 0.03;
      ctx.fillStyle = `rgba(255, 200, 50, ${sparkIntensity * (0.5 + Math.sin(time * 10 + spark) * 0.3)})`;
      ctx.beginPath();
      ctx.arc(
        Math.cos(sparkAngle) * sparkDist,
        -size * 0.32 + Math.sin(sparkAngle) * sparkDist * 0.5,
        size * 0.008,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }
    ctx.shadowBlur = 0;
  }
  ctx.restore();

  // === SCI-FI HELMET HEAD ===
  const headY = y - size * 0.45;

  // Face/skin
  ctx.fillStyle = "#d4a574";
  ctx.beginPath();
  ctx.ellipse(x, headY + size * 0.02, size * 0.22, size * 0.2, 0, 0, Math.PI * 2);
  ctx.fill();

  // Advanced hard hat/helmet
  const hatGrad = ctx.createRadialGradient(x - size * 0.05, headY - size * 0.12, 0, x, headY - size * 0.08, size * 0.32);
  hatGrad.addColorStop(0, "#ffcc22");
  hatGrad.addColorStop(0.5, "#eab308");
  hatGrad.addColorStop(1, "#aa8008");
  ctx.fillStyle = hatGrad;
  ctx.beginPath();
  ctx.ellipse(x, headY - size * 0.1, size * 0.3, size * 0.18, 0, 0, Math.PI);
  ctx.fill();

  // Helmet ridge
  ctx.fillStyle = "#ca9a08";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.05, headY - size * 0.28);
  ctx.lineTo(x - size * 0.03, headY - size * 0.1);
  ctx.lineTo(x + size * 0.03, headY - size * 0.1);
  ctx.lineTo(x + size * 0.05, headY - size * 0.28);
  ctx.closePath();
  ctx.fill();

  // Helmet brim (tech enhanced)
  const brimGrad = ctx.createLinearGradient(x - size * 0.35, headY - size * 0.02, x + size * 0.35, headY - size * 0.02);
  brimGrad.addColorStop(0, "#9a7a08");
  brimGrad.addColorStop(0.3, "#ca9a08");
  brimGrad.addColorStop(0.7, "#ca9a08");
  brimGrad.addColorStop(1, "#9a7a08");
  ctx.fillStyle = brimGrad;
  ctx.beginPath();
  ctx.ellipse(x, headY - size * 0.02, size * 0.35, size * 0.1, 0, 0, Math.PI * 2);
  ctx.fill();

  // Helmet border
  ctx.strokeStyle = "#8a6a08";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(x, headY - size * 0.02, size * 0.35, size * 0.1, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Main headlamp
  ctx.shadowColor = "#ffffff";
  ctx.shadowBlur = 12 * zoom * (0.6 + dataPulse * 0.4);
  ctx.fillStyle = `rgba(255, 255, 220, ${0.7 + dataPulse * 0.3})`;
  ctx.beginPath();
  ctx.ellipse(x, headY - size * 0.14, size * 0.06, size * 0.04, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Headlamp housing
  ctx.fillStyle = "#5a5a5a";
  ctx.beginPath();
  ctx.ellipse(x, headY - size * 0.14, size * 0.08, size * 0.05, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Side indicator lights
  ctx.fillStyle = `rgba(0, 255, 150, ${0.6 + dataPulse * 0.3})`;
  ctx.beginPath();
  ctx.arc(x - size * 0.2, headY - size * 0.08, size * 0.02, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = `rgba(255, 100, 50, ${0.6 + dataPulse * 0.3})`;
  ctx.beginPath();
  ctx.arc(x + size * 0.2, headY - size * 0.08, size * 0.02, 0, Math.PI * 2);
  ctx.fill();

  // === ADVANCED HUD GOGGLES ===
  // Goggle frame
  ctx.fillStyle = "#1a1a2a";
  ctx.beginPath();
  ctx.roundRect(x - size * 0.22, headY - size * 0.02, size * 0.44, size * 0.1, size * 0.02);
  ctx.fill();
  ctx.strokeStyle = "#3a3a4a";
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Left lens (with HUD display)
  const leftLensGrad = ctx.createLinearGradient(x - size * 0.2, headY, x - size * 0.02, headY + size * 0.06);
  leftLensGrad.addColorStop(0, `rgba(0, 150, 255, ${0.6 * holoFlicker})`);
  leftLensGrad.addColorStop(0.5, `rgba(0, 200, 255, ${0.7 * holoFlicker})`);
  leftLensGrad.addColorStop(1, `rgba(0, 100, 200, ${0.5 * holoFlicker})`);
  ctx.fillStyle = leftLensGrad;
  ctx.beginPath();
  ctx.roundRect(x - size * 0.2, headY, size * 0.17, size * 0.07, size * 0.01);
  ctx.fill();

  // Left lens HUD elements
  ctx.strokeStyle = `rgba(0, 255, 200, ${0.5 * holoFlicker})`;
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.18, headY + size * 0.02);
  ctx.lineTo(x - size * 0.08, headY + size * 0.02);
  ctx.moveTo(x - size * 0.18, headY + size * 0.04);
  ctx.lineTo(x - size * 0.12, headY + size * 0.04);
  ctx.stroke();

  // Right lens
  const rightLensGrad = ctx.createLinearGradient(x + size * 0.02, headY, x + size * 0.2, headY + size * 0.06);
  rightLensGrad.addColorStop(0, `rgba(0, 100, 200, ${0.5 * holoFlicker})`);
  rightLensGrad.addColorStop(0.5, `rgba(0, 200, 255, ${0.7 * holoFlicker})`);
  rightLensGrad.addColorStop(1, `rgba(0, 150, 255, ${0.6 * holoFlicker})`);
  ctx.fillStyle = rightLensGrad;
  ctx.beginPath();
  ctx.roundRect(x + size * 0.03, headY, size * 0.17, size * 0.07, size * 0.01);
  ctx.fill();

  // Right lens targeting reticle
  ctx.strokeStyle = `rgba(255, 100, 50, ${0.6 * holoFlicker})`;
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.arc(x + size * 0.115, headY + size * 0.035, size * 0.02, 0, Math.PI * 2);
  ctx.moveTo(x + size * 0.095, headY + size * 0.035);
  ctx.lineTo(x + size * 0.135, headY + size * 0.035);
  ctx.moveTo(x + size * 0.115, headY + size * 0.015);
  ctx.lineTo(x + size * 0.115, headY + size * 0.055);
  ctx.stroke();

  // Nose bridge
  ctx.fillStyle = "#2a2a3a";
  ctx.fillRect(x - size * 0.02, headY + size * 0.01, size * 0.04, size * 0.04);

  // Mouth (determined expression)
  ctx.fillStyle = "#8b5030";
  ctx.beginPath();
  ctx.arc(x, headY + size * 0.12, size * 0.045, 0.1, Math.PI - 0.1);
  ctx.stroke();

  // Chin stubble dots
  ctx.fillStyle = "#9a7050";
  for (let stubble = 0; stubble < 5; stubble++) {
    ctx.beginPath();
    ctx.arc(x - size * 0.04 + stubble * size * 0.02, headY + size * 0.15, size * 0.004, 0, Math.PI * 2);
    ctx.fill();
  }

  // === FLOATING HOLOGRAPHIC GEARS ===
  for (let g = 0; g < 5; g++) {
    const gearAngle = time * 1.8 + g * Math.PI * 0.4;
    const gearDist = size * 0.62;
    const gearX = x + Math.cos(gearAngle) * gearDist;
    const gearY = y - size * 0.05 + Math.sin(gearAngle) * gearDist * 0.4;
    const gearSize = size * (0.06 + Math.sin(time * 2 + g) * 0.015);
    const gearAlpha = 0.4 + Math.sin(time * 3 + g * 0.8) * 0.2;

    // Gear glow
    ctx.shadowColor = "#00ccff";
    ctx.shadowBlur = 5 * zoom;

    ctx.strokeStyle = `rgba(0, 200, 255, ${gearAlpha})`;
    ctx.lineWidth = 1.5 * zoom;
    ctx.beginPath();
    for (let tooth = 0; tooth < 8; tooth++) {
      const tAngle = (tooth / 8) * Math.PI * 2 + time * (3 + g * 0.3);
      const innerR = gearSize * 0.5;
      const outerR = gearSize;
      if (tooth === 0) {
        ctx.moveTo(gearX + Math.cos(tAngle) * outerR, gearY + Math.sin(tAngle) * outerR * 0.5);
      } else {
        ctx.lineTo(gearX + Math.cos(tAngle) * outerR, gearY + Math.sin(tAngle) * outerR * 0.5);
      }
      ctx.lineTo(gearX + Math.cos(tAngle + Math.PI / 8) * innerR, gearY + Math.sin(tAngle + Math.PI / 8) * innerR * 0.5);
    }
    ctx.closePath();
    ctx.stroke();

    // Gear center
    ctx.fillStyle = `rgba(0, 255, 200, ${gearAlpha * 0.6})`;
    ctx.beginPath();
    ctx.arc(gearX, gearY, gearSize * 0.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // === HOLOGRAPHIC DATA PROJECTION (when attacking) ===
  if (isAttacking) {
    const holoAlpha = attackIntensity * 0.7;
    
    // Holographic schematic lines
    ctx.strokeStyle = `rgba(0, 255, 200, ${holoAlpha})`;
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 3]);
    
    // Turret schematic outline
    ctx.beginPath();
    ctx.moveTo(x - size * 0.3, y - size * 0.7);
    ctx.lineTo(x - size * 0.3, y - size * 0.9);
    ctx.lineTo(x + size * 0.3, y - size * 0.9);
    ctx.lineTo(x + size * 0.3, y - size * 0.7);
    ctx.lineTo(x - size * 0.3, y - size * 0.7);
    ctx.stroke();
    
    // Turret barrel
    ctx.beginPath();
    ctx.moveTo(x, y - size * 0.9);
    ctx.lineTo(x, y - size * 1.1);
    ctx.stroke();
    
    ctx.setLineDash([]);
    
    // Deployment indicator rings
    for (let ring = 0; ring < 3; ring++) {
      const ringRadius = size * (0.15 + ring * 0.1 + attackIntensity * 0.1);
      ctx.strokeStyle = `rgba(234, 179, 8, ${holoAlpha * (1 - ring * 0.25)})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(x, y + size * 0.6, ringRadius, ringRadius * 0.3, 0, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    // "DEPLOYING" text effect
    ctx.fillStyle = `rgba(0, 255, 200, ${holoAlpha * holoFlicker})`;
    ctx.font = `bold ${8 * zoom}px monospace`;
    ctx.textAlign = "center";
    ctx.fillText("DEPLOYING", x, y - size * 0.75);
  }

  // === TECH ENERGY AURA ===
  const energyGlow = 0.25 + Math.sin(time * 4) * 0.1 + attackIntensity * 0.25;
  ctx.strokeStyle = `rgba(0, 200, 255, ${energyGlow})`;
  ctx.lineWidth = (1.5 + attackIntensity * 1.5) * zoom;
  ctx.setLineDash([4 * zoom, 3 * zoom]);
  ctx.beginPath();
  ctx.ellipse(x, y, size * 0.55, size * 0.65, 0, 0, Math.PI * 2);
  ctx.stroke();
  ctx.setLineDash([]);
}

function drawDefaultHero(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // Default hero fallback
  const bodyGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 0.6);
  bodyGrad.addColorStop(0, lightenColor(color, 30));
  bodyGrad.addColorStop(0.7, color);
  bodyGrad.addColorStop(1, darkenColor(color, 40));
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.ellipse(x, y, size * 0.45, size * 0.55, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = darkenColor(color, 50);
  ctx.lineWidth = 2;
  ctx.stroke();

  ctx.fillStyle = "#ffdbac";
  ctx.beginPath();
  ctx.arc(x, y - size * 0.25, size * 0.28, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "#333";
  ctx.beginPath();
  ctx.arc(x - size * 0.1, y - size * 0.27, size * 0.05, 0, Math.PI * 2);
  ctx.arc(x + size * 0.1, y - size * 0.27, size * 0.05, 0, Math.PI * 2);
  ctx.fill();
}

// ============================================================================
// TROOP RENDERING - Epic detailed troop sprites
// 
// ============================================================================
export function renderTroop(
  ctx: CanvasRenderingContext2D,
  troop: Troop,
  canvasWidth: number,
  canvasHeight: number,
  dpr: number,
  cameraOffset?: Position,
  cameraZoom?: number,
  targetPos?: Position
) {
  const screenPos = worldToScreen(
    troop.pos,
    canvasWidth,
    canvasHeight,
    dpr,
    cameraOffset,
    cameraZoom
  );
  const zoom = cameraZoom || 1;
  const tData = TROOP_DATA[troop.type];
  const time = Date.now() / 1000;

  // Check for large troops
  const isLargeTroop =
    troop.type === "elite" ||
    troop.type === "centaur" ||
    troop.type === "cavalry" ||
    troop.type === "knight" ||
    troop.type === "turret";
  const sizeScale = isLargeTroop ? 1.6 : 1;

  // Selection indicator - scaled for large troops
  if (troop.selected) {
    ctx.strokeStyle = "#c9a227";
    ctx.lineWidth = 2 * zoom;
    ctx.setLineDash([4, 3]);
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      screenPos.y + 2 * zoom,
      28 * zoom * sizeScale,
      14 * zoom * sizeScale,
      0,
      0,
      Math.PI * 2
    );
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Shadow - scale based on troop type
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    screenPos.y + 5 * zoom,
    15 * zoom * sizeScale,
    7 * zoom * sizeScale,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Scale up level 3 elite troops and level 4 mounted troops
  let baseSize = 22;
  if (troop.type === "elite") baseSize = 31; // Level 3 Elite Guard - larger
  else if (troop.type === "centaur") baseSize = 32; // Level 4 Centaur - mounted
  else if (troop.type === "cavalry")
    baseSize = 32; // Level 4 Royal Cavalry - mounted
  else if (troop.type === "knight") baseSize = 32; // Level 4 Knight - mounted
  else if (troop.type === "turret") baseSize = 34; // Engineer's turret - medium-large
  const size = baseSize * zoom;
  const attackPhase = troop.attackAnim > 0 ? troop.attackAnim / 300 : 0;
  const attackScale = attackPhase > 0 ? 1 + attackPhase * 0.15 : 1;

  ctx.save();
  ctx.translate(screenPos.x, screenPos.y - size / 2);
  ctx.scale(attackScale, attackScale);

  // Draw specific troop type with attack animation
  drawTroopSprite(
    ctx,
    0,
    0,
    size,
    troop.type,
    tData.color,
    time,
    zoom,
    attackPhase
  );

  ctx.restore();

  // HP Bar - scaled for larger troops
  if (troop.hp < troop.maxHp) {
    const barWidth = 30 * zoom * sizeScale;
    const barHeight = 4 * zoom;
    const barY = screenPos.y - size - 8 * zoom;

    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(
      screenPos.x - barWidth / 2 - 1,
      barY - 1,
      barWidth + 2,
      barHeight + 2
    );
    ctx.fillStyle = "#333";
    ctx.fillRect(screenPos.x - barWidth / 2, barY, barWidth, barHeight);

    const hpPercent = troop.hp / troop.maxHp;
    ctx.fillStyle =
      hpPercent > 0.5 ? "#4ade80" : hpPercent > 0.25 ? "#fbbf24" : "#ef4444";
    ctx.fillRect(
      screenPos.x - barWidth / 2,
      barY,
      barWidth * hpPercent,
      barHeight
    );
  }
}

function drawTroopSprite(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  type: string,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0,
  targetPos?: Position
) {
  switch (type) {
    case "soldier":
    case "footsoldier":
      drawSoldierTroop(ctx, x, y, size, color, time, zoom, attackPhase);
      break;
    case "cavalry":
      drawCavalryTroop(ctx, x, y, size, color, time, zoom, attackPhase);
      break;
    case "centaur":
      drawCentaurTroop(ctx, x, y, size, color, time, zoom, attackPhase);
      break;
    case "elite":
      drawEliteTroop(ctx, x, y, size, color, time, zoom, attackPhase);
      break;
    case "knight":
    case "armored":
      drawKnightTroop(ctx, x, y, size, color, time, zoom, attackPhase);
      break;
    case "turret":
      drawTurretTroop(
        ctx,
        x,
        y,
        size,
        color,
        time,
        zoom,
        attackPhase,
        targetPos
      );
      break;
    default:
      drawDefaultTroop(ctx, x, y, size, color, time, zoom, attackPhase);
  }
}

function drawSoldierTroop(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // Elite Princeton Soldier - Roman Legionnaire style with epic attack animations
  const stance = Math.sin(time * 4) * 1.5;
  const breathe = Math.sin(time * 2) * 0.5;
  const footTap = Math.abs(Math.sin(time * 3)) * 1;

  // Attack animation calculations
  const isAttacking = attackPhase > 0;
  const attackSwing = isAttacking
    ? Math.sin(attackPhase * Math.PI * 2) * 1.5
    : 0;
  const attackLunge = isAttacking
    ? Math.sin(attackPhase * Math.PI) * size * 0.15
    : 0;
  const bodyTwist = isAttacking ? Math.sin(attackPhase * Math.PI) * 0.2 : 0;

  ctx.save();
  ctx.translate(attackLunge * 0.5, 0);
  ctx.rotate(bodyTwist);

  // === LEGS (animated idle stance, spread during attack) ===
  const legSpread = isAttacking ? size * 0.05 : 0;
  ctx.fillStyle = "#1a1a1a";
  // Left leg
  ctx.save();
  ctx.translate(x - size * 0.1 - legSpread, y + size * 0.35);
  ctx.rotate(-0.05 + footTap * 0.02 - (isAttacking ? 0.15 : 0));
  ctx.fillRect(-size * 0.06, 0, size * 0.12, size * 0.22);
  ctx.fillStyle = "#2a2a2a";
  ctx.fillRect(-size * 0.08, size * 0.18, size * 0.16, size * 0.08);
  ctx.restore();
  // Right leg
  ctx.save();
  ctx.translate(x + size * 0.1 + legSpread, y + size * 0.35);
  ctx.rotate(0.05 - footTap * 0.02 + (isAttacking ? 0.15 : 0));
  ctx.fillStyle = "#1a1a1a";
  ctx.fillRect(-size * 0.06, 0, size * 0.12, size * 0.22);
  ctx.fillStyle = "#2a2a2a";
  ctx.fillRect(-size * 0.08, size * 0.18, size * 0.16, size * 0.08);
  ctx.restore();

  // === BODY (armored torso with Princeton orange) ===
  ctx.fillStyle = "#8a8a9a";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.22, y + size * 0.38);
  ctx.lineTo(x - size * 0.25, y - size * 0.05);
  ctx.lineTo(x + size * 0.25, y - size * 0.05);
  ctx.lineTo(x + size * 0.22, y + size * 0.38);
  ctx.closePath();
  ctx.fill();

  const chestGrad = ctx.createLinearGradient(
    x - size * 0.2,
    y,
    x + size * 0.2,
    y
  );
  chestGrad.addColorStop(0, "#cc5500");
  chestGrad.addColorStop(0.3, "#ff6600");
  chestGrad.addColorStop(0.7, "#ff6600");
  chestGrad.addColorStop(1, "#cc5500");
  ctx.fillStyle = chestGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.2, y + size * 0.35 + breathe);
  ctx.lineTo(x - size * 0.23, y - size * 0.08 + breathe);
  ctx.quadraticCurveTo(
    x,
    y - size * 0.18 + breathe,
    x + size * 0.23,
    y - size * 0.08 + breathe
  );
  ctx.lineTo(x + size * 0.2, y + size * 0.35 + breathe);
  ctx.closePath();
  ctx.fill();

  ctx.strokeStyle = "rgba(0,0,0,0.3)";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.1 + breathe);
  ctx.lineTo(x, y + size * 0.2 + breathe);
  ctx.stroke();

  ctx.fillStyle = "#1a1a1a";
  ctx.font = `bold ${8 * zoom}px Arial`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("P", x, y + size * 0.1 + breathe);

  ctx.fillStyle = "#1a1a1a";
  ctx.fillRect(x - size * 0.2, y + size * 0.25, size * 0.4, size * 0.06);
  ctx.fillStyle = "#c9a227";
  ctx.fillRect(x - size * 0.04, y + size * 0.26, size * 0.08, size * 0.04);

  // === SHIELD ARM (thrusts forward during attack) ===
  const shieldX = x - size * 0.38 + (isAttacking ? attackLunge * 0.8 : 0);
  const shieldY = y + size * 0.1 - (isAttacking ? size * 0.1 * attackSwing : 0);

  ctx.fillStyle = "#ffe0bd";
  ctx.save();
  ctx.translate(x - size * 0.28, y + size * 0.05);
  ctx.rotate(-0.3 - (isAttacking ? 0.4 : 0));
  ctx.fillRect(-size * 0.05, 0, size * 0.1, size * 0.2);
  ctx.restore();

  // === SHIELD (moves forward and tilts during attack) ===
  ctx.save();
  ctx.translate(shieldX, shieldY);
  ctx.rotate(isAttacking ? -0.3 - attackSwing * 0.3 : -0.2);
  ctx.fillStyle = "#8a8a9a";
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.18, size * 0.16, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#1a1a1a";
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.15, size * 0.13, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#ff6600";
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.1, size * 0.085, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#c0c0c0";
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.04, 0, Math.PI * 2);
  ctx.fill();
  // Shield spike for attack
  if (isAttacking) {
    ctx.fillStyle = "#e0e0e0";
    ctx.beginPath();
    ctx.moveTo(0, -size * 0.06);
    ctx.lineTo(-size * 0.02, 0);
    ctx.lineTo(size * 0.02, 0);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();

  // === SPEAR ARM (dramatic thrust during attack) ===
  ctx.save();
  ctx.translate(x + size * 0.28, y + size * 0.05);
  const armSwing = isAttacking ? -1.2 + attackPhase * 2.4 : 0.2 + stance * 0.02;
  ctx.rotate(armSwing);
  ctx.fillStyle = "#ffe0bd";
  ctx.fillRect(-size * 0.05, 0, size * 0.1, size * 0.2);
  ctx.restore();

  // === SPEAR (thrusting attack animation) ===
  ctx.save();
  const spearAngle = isAttacking
    ? -0.8 + attackPhase * 1.6
    : -0.15 + stance * 0.03;
  const spearX = x + size * 0.38 + (isAttacking ? attackLunge * 1.5 : 0);
  const spearY =
    y - size * 0.1 - (isAttacking ? size * 0.2 * (1 - attackPhase) : 0);
  ctx.translate(spearX, spearY);
  ctx.rotate(spearAngle);

  const shaftGrad = ctx.createLinearGradient(-size * 0.02, 0, size * 0.02, 0);
  shaftGrad.addColorStop(0, "#5a3a1a");
  shaftGrad.addColorStop(0.5, "#7b5030");
  shaftGrad.addColorStop(1, "#5a3a1a");
  ctx.fillStyle = shaftGrad;
  ctx.fillRect(-size * 0.025, -size * 0.55, size * 0.05, size * 0.7);

  const headGrad = ctx.createLinearGradient(
    -size * 0.05,
    -size * 0.65,
    size * 0.05,
    -size * 0.55
  );
  headGrad.addColorStop(0, "#e0e0e0");
  headGrad.addColorStop(0.5, "#ffffff");
  headGrad.addColorStop(1, "#a0a0a0");
  ctx.fillStyle = headGrad;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.7);
  ctx.lineTo(-size * 0.05, -size * 0.55);
  ctx.lineTo(-size * 0.02, -size * 0.53);
  ctx.lineTo(size * 0.02, -size * 0.53);
  ctx.lineTo(size * 0.05, -size * 0.55);
  ctx.closePath();
  ctx.fill();

  // Spear glint (more intense during attack)
  ctx.fillStyle = isAttacking ? "rgba(255,255,255,1)" : "rgba(255,255,255,0.8)";
  ctx.beginPath();
  ctx.ellipse(
    0,
    -size * 0.62,
    size * (isAttacking ? 0.025 : 0.015),
    size * 0.04,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Attack trail effect
  if (isAttacking && attackPhase < 0.5) {
    ctx.strokeStyle = `rgba(255, 200, 100, ${0.8 - attackPhase * 1.6})`;
    ctx.lineWidth = 3 * zoom;
    ctx.beginPath();
    ctx.moveTo(0, -size * 0.7);
    ctx.lineTo(0, -size * 0.3);
    ctx.stroke();
  }
  ctx.restore();

  // === HEAD ===
  ctx.fillStyle = "#ffe0bd";
  ctx.fillRect(x - size * 0.06, y - size * 0.2, size * 0.12, size * 0.1);
  ctx.beginPath();
  ctx.arc(x, y - size * 0.35, size * 0.16, 0, Math.PI * 2);
  ctx.fill();

  // === HELMET ===
  ctx.fillStyle = "#7a7a8a";
  ctx.beginPath();
  ctx.ellipse(
    x,
    y - size * 0.42,
    size * 0.18,
    size * 0.12,
    0,
    Math.PI,
    Math.PI * 2
  );
  ctx.fill();
  ctx.fillStyle = "#6a6a7a";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.17, y - size * 0.35);
  ctx.lineTo(x - size * 0.2, y - size * 0.25);
  ctx.lineTo(x - size * 0.12, y - size * 0.28);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.17, y - size * 0.35);
  ctx.lineTo(x + size * 0.2, y - size * 0.25);
  ctx.lineTo(x + size * 0.12, y - size * 0.28);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = "#8a8a9a";
  ctx.fillRect(x - size * 0.02, y - size * 0.42, size * 0.04, size * 0.15);

  // Epic orange plume (more dynamic during attack)
  ctx.fillStyle = "#ff6600";
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.52);
  const plumeWave = Math.sin(time * 6) + (isAttacking ? attackSwing * 2 : 0);
  for (let i = 0; i < 8; i++) {
    const t = i / 7;
    const px = x + (t - 0.5) * size * 0.25 + plumeWave * 2 * (1 - t);
    const py =
      y - size * 0.52 - t * size * 0.35 - Math.sin(t * Math.PI) * size * 0.12;
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  for (let i = 7; i >= 0; i--) {
    const t = i / 7;
    const px = x + (t - 0.5) * size * 0.25 + plumeWave * 2 * (1 - t);
    const py =
      y - size * 0.52 - t * size * 0.3 - Math.sin(t * Math.PI) * size * 0.08;
    ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = "#ff8833";
  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const t = i / 5;
    const px = x + (t - 0.5) * size * 0.15 + plumeWave * 1.5 * (1 - t);
    const py =
      y - size * 0.55 - t * size * 0.28 - Math.sin(t * Math.PI) * size * 0.08;
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  for (let i = 5; i >= 0; i--) {
    const t = i / 5;
    const px = x + (t - 0.5) * size * 0.15 + plumeWave * 1.5 * (1 - t);
    const py = y - size * 0.55 - t * size * 0.25;
    ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fill();

  // === FACE (battle cry during attack) ===
  ctx.fillStyle = "#4a3520";
  ctx.beginPath();
  ctx.ellipse(
    x - size * 0.06,
    y - size * 0.36,
    size * 0.03,
    size * (isAttacking ? 0.015 : 0.025),
    0,
    0,
    Math.PI * 2
  );
  ctx.ellipse(
    x + size * 0.06,
    y - size * 0.36,
    size * 0.03,
    size * (isAttacking ? 0.015 : 0.025),
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(x - size * 0.055, y - size * 0.365, size * 0.01, 0, Math.PI * 2);
  ctx.arc(x + size * 0.065, y - size * 0.365, size * 0.01, 0, Math.PI * 2);
  ctx.fill();

  // Battle cry mouth
  if (isAttacking) {
    ctx.fillStyle = "#4a2a1a";
    ctx.beginPath();
    ctx.ellipse(
      x,
      y - size * 0.28,
      size * 0.04,
      size * 0.03 * (1 + attackPhase * 0.5),
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
  } else {
    ctx.strokeStyle = "#8b6b5b";
    ctx.lineWidth = 1 * zoom;
    ctx.beginPath();
    ctx.moveTo(x - size * 0.04, y - size * 0.28);
    ctx.lineTo(x + size * 0.04, y - size * 0.28);
    ctx.stroke();
  }

  // Aggressive eyebrows during attack
  ctx.strokeStyle = "#5a4030";
  ctx.lineWidth = 1.5 * zoom;
  const browAnger = isAttacking ? 0.1 : 0;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.1, y - size * (0.4 - browAnger));
  ctx.lineTo(x - size * 0.03, y - size * (0.42 + browAnger));
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.1, y - size * (0.4 - browAnger));
  ctx.lineTo(x + size * 0.03, y - size * (0.42 + browAnger));
  ctx.stroke();

  ctx.restore();
}

function drawCavalryTroop(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // ROYAL CAVALRY CHAMPION - Epic Knight of Princeton with Ornate Detail
  const gallop = Math.sin(time * 8) * 3;
  const legCycle = Math.sin(time * 8) * 0.35;
  const headBob = Math.sin(time * 8 + 0.5) * 2;
  const breathe = Math.sin(time * 2) * 0.3;
  const shimmer = Math.sin(time * 5) * 0.5 + 0.5;
  const gemPulse = Math.sin(time * 2.5) * 0.3 + 0.7;

  // Attack animation
  const isAttacking = attackPhase > 0;
  const lanceThrust = isAttacking ? Math.sin(attackPhase * Math.PI) * 2.5 : 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0

  // === MULTI-LAYERED ROYAL AURA ===
  const auraIntensity = isAttacking ? 0.65 : 0.4;
  const auraPulse = 0.85 + Math.sin(time * 3) * 0.15;

  // Multiple layered aura for depth
  for (let auraLayer = 0; auraLayer < 3; auraLayer++) {
    const layerOffset = auraLayer * 0.12;
  const auraGrad = ctx.createRadialGradient(
      x, y + size * 0.1, size * (0.08 + layerOffset),
      x, y + size * 0.1, size * (0.9 + layerOffset * 0.3)
    );
    auraGrad.addColorStop(0, `rgba(224, 96, 0, ${auraIntensity * auraPulse * (0.5 - auraLayer * 0.12)})`);
    auraGrad.addColorStop(0.4, `rgba(255, 140, 40, ${auraIntensity * auraPulse * (0.3 - auraLayer * 0.08)})`);
    auraGrad.addColorStop(0.7, `rgba(200, 80, 0, ${auraIntensity * auraPulse * (0.15 - auraLayer * 0.04)})`);
  auraGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
    ctx.ellipse(x, y + size * 0.15, size * (0.8 + layerOffset * 0.2), size * (0.52 + layerOffset * 0.12), 0, 0, Math.PI * 2);
  ctx.fill();
  }

  // Floating royal rune particles
  for (let p = 0; p < 8; p++) {
    const pAngle = (time * 1.8 + p * Math.PI * 0.25) % (Math.PI * 2);
    const pDist = size * 0.55 + Math.sin(time * 2.5 + p * 0.8) * size * 0.12;
    const px = x + Math.cos(pAngle) * pDist;
    const py = y + size * 0.1 + Math.sin(pAngle) * pDist * 0.35;
    const pAlpha = 0.5 + Math.sin(time * 3.5 + p * 0.5) * 0.3;
    ctx.fillStyle = `rgba(255, 160, 40, ${pAlpha})`;
    ctx.beginPath();
    ctx.arc(px, py, size * 0.018, 0, Math.PI * 2);
    ctx.fill();
    // Inner glow
    ctx.fillStyle = `rgba(255, 220, 150, ${pAlpha * 0.6})`;
    ctx.beginPath();
    ctx.arc(px, py, size * 0.008, 0, Math.PI * 2);
    ctx.fill();
  }

  // Attack energy rings with spark trails
  if (isAttacking) {
    for (let ring = 0; ring < 4; ring++) {
      const ringPhase = (attackPhase * 2.5 + ring * 0.12) % 1;
      const ringAlpha = (1 - ringPhase) * 0.6 * attackIntensity;
      ctx.strokeStyle = `rgba(224, 96, 0, ${ringAlpha})`;
      ctx.lineWidth = (3.5 - ring * 0.5) * zoom;
      ctx.beginPath();
      ctx.ellipse(
        x, y + size * 0.1,
        size * (0.45 + ringPhase * 0.45),
        size * (0.3 + ringPhase * 0.28),
        0, 0, Math.PI * 2
      );
      ctx.stroke();
    }
    // Spark particles during attack
    for (let sp = 0; sp < 6; sp++) {
      const spAngle = time * 8 + sp * Math.PI / 3;
      const spDist = size * 0.4 + attackIntensity * size * 0.3;
      const spX = x + Math.cos(spAngle) * spDist;
      const spY = y + size * 0.1 + Math.sin(spAngle) * spDist * 0.4;
      ctx.fillStyle = `rgba(255, 200, 100, ${attackIntensity * 0.7})`;
      ctx.beginPath();
      ctx.arc(spX, spY, size * 0.012, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // === MAJESTIC ROYAL WAR STEED ===
  // Shadow with depth
  const shadowGrad = ctx.createRadialGradient(x, y + size * 0.55, 0, x, y + size * 0.55, size * 0.5);
  shadowGrad.addColorStop(0, "rgba(0, 0, 0, 0.5)");
  shadowGrad.addColorStop(0.6, "rgba(0, 0, 0, 0.3)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.55, size * 0.52, size * 0.15, 0, 0, Math.PI * 2);
  ctx.fill();

  // Horse body with rich gradient
  const bodyGrad = ctx.createRadialGradient(
    x - size * 0.1, y + size * 0.05, 0,
    x, y + size * 0.15, size * 0.55
  );
  bodyGrad.addColorStop(0, "#4a3a2a");
  bodyGrad.addColorStop(0.3, "#3a2a1a");
  bodyGrad.addColorStop(0.6, "#2a1a0a");
  bodyGrad.addColorStop(1, "#1a0a00");
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.ellipse(
    x, y + size * 0.18 + gallop * 0.15,
    size * 0.48, size * 0.31,
    0, 0, Math.PI * 2
  );
  ctx.fill();

  // Muscular definition on horse body
  ctx.strokeStyle = "rgba(60, 40, 20, 0.4)";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(x - size * 0.15, y + size * 0.15 + gallop * 0.15, size * 0.18, size * 0.12, -0.3, 0, Math.PI * 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.ellipse(x + size * 0.15, y + size * 0.2 + gallop * 0.15, size * 0.2, size * 0.14, 0.2, 0, Math.PI * 2);
  ctx.stroke();

  // === ORNATE ROYAL BARDING (horse armor) ===
  // Base barding plate with gradient
  const bardingGrad = ctx.createLinearGradient(
    x - size * 0.4, y + size * 0.1,
    x + size * 0.4, y + size * 0.25
  );
  bardingGrad.addColorStop(0, "#3a3a42");
  bardingGrad.addColorStop(0.2, "#5a5a62");
  bardingGrad.addColorStop(0.5, "#6a6a72");
  bardingGrad.addColorStop(0.8, "#5a5a62");
  bardingGrad.addColorStop(1, "#3a3a42");
  ctx.fillStyle = bardingGrad;
  ctx.beginPath();
  ctx.ellipse(
    x, y + size * 0.18 + gallop * 0.15,
    size * 0.44, size * 0.24,
    0, Math.PI * 0.65, Math.PI * 2.35
  );
  ctx.fill();

  // Barding edge highlights
  ctx.strokeStyle = "#7a7a82";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.ellipse(
    x, y + size * 0.18 + gallop * 0.15,
    size * 0.44, size * 0.24,
    0, Math.PI * 0.7, Math.PI * 2.3
  );
  ctx.stroke();

  // Orange trim on barding with double line
  ctx.strokeStyle = "#e06000";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.ellipse(
    x, y + size * 0.18 + gallop * 0.15,
    size * 0.44, size * 0.24,
    0, Math.PI * 0.75, Math.PI * 2.25
  );
  ctx.stroke();
  ctx.strokeStyle = "#ff8030";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.ellipse(
    x, y + size * 0.16 + gallop * 0.15,
    size * 0.42, size * 0.22,
    0, Math.PI * 0.8, Math.PI * 2.2
  );
  ctx.stroke();

  // Engraved filigree patterns on barding
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 0.8;
  ctx.globalAlpha = 0.7;
  // Left swirl
  ctx.beginPath();
  ctx.moveTo(x - size * 0.3, y + size * 0.08 + gallop * 0.15);
  ctx.quadraticCurveTo(x - size * 0.35, y + size * 0.15, x - size * 0.28, y + size * 0.18 + gallop * 0.15);
  ctx.quadraticCurveTo(x - size * 0.22, y + size * 0.22, x - size * 0.28, y + size * 0.28 + gallop * 0.15);
  ctx.stroke();
  // Right swirl
  ctx.beginPath();
  ctx.moveTo(x + size * 0.2, y + size * 0.06 + gallop * 0.15);
  ctx.quadraticCurveTo(x + size * 0.28, y + size * 0.12, x + size * 0.22, y + size * 0.16 + gallop * 0.15);
  ctx.quadraticCurveTo(x + size * 0.16, y + size * 0.2, x + size * 0.22, y + size * 0.26 + gallop * 0.15);
  ctx.stroke();
  ctx.globalAlpha = 1;

  // Ornate decorative medallions with gems
  ctx.shadowColor = "#c9a227";
  ctx.shadowBlur = 5 * zoom;
  for (let i = 0; i < 5; i++) {
    const medX = x - size * 0.28 + i * size * 0.14;
    const medY = y + size * 0.04 + gallop * 0.15 + Math.sin(i * 0.8) * size * 0.02;
    // Gold medallion base
    ctx.fillStyle = "#c9a227";
    ctx.beginPath();
    ctx.arc(medX, medY, size * 0.032, 0, Math.PI * 2);
    ctx.fill();
    // Inner medallion detail
    ctx.fillStyle = "#dab32f";
    ctx.beginPath();
    ctx.arc(medX, medY, size * 0.02, 0, Math.PI * 2);
    ctx.fill();
    // Center gem (alternating colors)
    ctx.fillStyle = i % 2 === 0 ? "#ff4400" : "#00aaff";
    ctx.shadowColor = i % 2 === 0 ? "#ff6600" : "#00ccff";
    ctx.shadowBlur = 4 * zoom * gemPulse;
    ctx.beginPath();
    ctx.arc(medX, medY, size * 0.012, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.shadowBlur = 0;

  // Saddle blanket visible edge
  ctx.fillStyle = "#1a0a3a";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.15, y + size * 0.02 + gallop * 0.15);
  ctx.lineTo(x - size * 0.2, y + size * 0.12 + gallop * 0.15);
  ctx.lineTo(x + size * 0.1, y + size * 0.14 + gallop * 0.15);
  ctx.lineTo(x + size * 0.12, y + size * 0.04 + gallop * 0.15);
  ctx.closePath();
  ctx.fill();
  // Gold fringe on blanket
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.2, y + size * 0.12 + gallop * 0.15);
  ctx.lineTo(x + size * 0.1, y + size * 0.14 + gallop * 0.15);
  ctx.stroke();

  // === HORSE LEGS (muscular with ornate armor) ===
  const legGrad = ctx.createLinearGradient(0, 0, 0, size * 0.35);
  legGrad.addColorStop(0, "#3a2a1a");
  legGrad.addColorStop(0.5, "#2a1a0a");
  legGrad.addColorStop(1, "#1a0a00");

  // Front left leg
  ctx.save();
  ctx.translate(x - size * 0.25, y + size * 0.38 + gallop * 0.15);
  ctx.rotate(legCycle * 1.2);
  ctx.fillStyle = legGrad;
  ctx.fillRect(-size * 0.05, 0, size * 0.1, size * 0.34);
  // Leg muscle highlight
  ctx.fillStyle = "rgba(60, 40, 20, 0.3)";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.08, size * 0.04, size * 0.06, 0, 0, Math.PI * 2);
  ctx.fill();
  // Ornate armored greave with gradient
  const greaveGrad = ctx.createLinearGradient(-size * 0.055, 0, size * 0.055, 0);
  greaveGrad.addColorStop(0, "#4a4a52");
  greaveGrad.addColorStop(0.3, "#6a6a72");
  greaveGrad.addColorStop(0.7, "#6a6a72");
  greaveGrad.addColorStop(1, "#4a4a52");
  ctx.fillStyle = greaveGrad;
  ctx.fillRect(-size * 0.055, size * 0.06, size * 0.11, size * 0.12);
  // Greave engraving
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.moveTo(-size * 0.03, size * 0.08);
  ctx.lineTo(0, size * 0.12);
  ctx.lineTo(size * 0.03, size * 0.08);
  ctx.stroke();
  // Orange trim
  ctx.strokeStyle = "#e06000";
  ctx.lineWidth = 1.5 * zoom;
  ctx.strokeRect(-size * 0.055, size * 0.06, size * 0.11, size * 0.12);
  // Ornate golden hoof with glow
  ctx.fillStyle = "#c9a227";
  ctx.shadowColor = "#ffaa00";
  ctx.shadowBlur = 6 * zoom * gemPulse;
  ctx.beginPath();
  ctx.ellipse(0, size * 0.36, size * 0.06, size * 0.035, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#dab32f";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.355, size * 0.04, size * 0.02, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // Front right leg
  ctx.save();
  ctx.translate(x - size * 0.08, y + size * 0.38 + gallop * 0.15);
  ctx.rotate(-legCycle * 0.9);
  ctx.fillStyle = legGrad;
  ctx.fillRect(-size * 0.05, 0, size * 0.1, size * 0.34);
  ctx.fillStyle = "rgba(60, 40, 20, 0.3)";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.08, size * 0.04, size * 0.06, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = greaveGrad;
  ctx.fillRect(-size * 0.055, size * 0.06, size * 0.11, size * 0.12);
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.moveTo(-size * 0.03, size * 0.08);
  ctx.lineTo(0, size * 0.12);
  ctx.lineTo(size * 0.03, size * 0.08);
  ctx.stroke();
  ctx.strokeStyle = "#e06000";
  ctx.lineWidth = 1.5 * zoom;
  ctx.strokeRect(-size * 0.055, size * 0.06, size * 0.11, size * 0.12);
  ctx.fillStyle = "#c9a227";
  ctx.shadowColor = "#ffaa00";
  ctx.shadowBlur = 6 * zoom * gemPulse;
  ctx.beginPath();
  ctx.ellipse(0, size * 0.36, size * 0.06, size * 0.035, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#dab32f";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.355, size * 0.04, size * 0.02, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // Back left leg
  ctx.save();
  ctx.translate(x + size * 0.13, y + size * 0.38 + gallop * 0.15);
  ctx.rotate(-legCycle * 1.1);
  ctx.fillStyle = legGrad;
  ctx.fillRect(-size * 0.05, 0, size * 0.1, size * 0.34);
  ctx.fillStyle = "rgba(60, 40, 20, 0.3)";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.08, size * 0.04, size * 0.06, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = greaveGrad;
  ctx.fillRect(-size * 0.055, size * 0.06, size * 0.11, size * 0.12);
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.moveTo(-size * 0.03, size * 0.08);
  ctx.lineTo(0, size * 0.12);
  ctx.lineTo(size * 0.03, size * 0.08);
  ctx.stroke();
  ctx.strokeStyle = "#e06000";
  ctx.lineWidth = 1.5 * zoom;
  ctx.strokeRect(-size * 0.055, size * 0.06, size * 0.11, size * 0.12);
  ctx.fillStyle = "#c9a227";
  ctx.shadowColor = "#ffaa00";
  ctx.shadowBlur = 6 * zoom * gemPulse;
  ctx.beginPath();
  ctx.ellipse(0, size * 0.36, size * 0.06, size * 0.035, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#dab32f";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.355, size * 0.04, size * 0.02, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // Back right leg
  ctx.save();
  ctx.translate(x + size * 0.3, y + size * 0.38 + gallop * 0.15);
  ctx.rotate(legCycle * 0.8);
  ctx.fillStyle = legGrad;
  ctx.fillRect(-size * 0.05, 0, size * 0.1, size * 0.34);
  ctx.fillStyle = "rgba(60, 40, 20, 0.3)";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.08, size * 0.04, size * 0.06, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = greaveGrad;
  ctx.fillRect(-size * 0.055, size * 0.06, size * 0.11, size * 0.12);
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.moveTo(-size * 0.03, size * 0.08);
  ctx.lineTo(0, size * 0.12);
  ctx.lineTo(size * 0.03, size * 0.08);
  ctx.stroke();
  ctx.strokeStyle = "#e06000";
  ctx.lineWidth = 1.5 * zoom;
  ctx.strokeRect(-size * 0.055, size * 0.06, size * 0.11, size * 0.12);
  ctx.fillStyle = "#c9a227";
  ctx.shadowColor = "#ffaa00";
  ctx.shadowBlur = 6 * zoom * gemPulse;
  ctx.beginPath();
  ctx.ellipse(0, size * 0.36, size * 0.06, size * 0.035, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#dab32f";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.355, size * 0.04, size * 0.02, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // === HORSE NECK AND HEAD ===
  // Neck with gradient
  const neckGrad = ctx.createLinearGradient(
    x - size * 0.35, y + size * 0.1,
    x - size * 0.6, y - size * 0.1
  );
  neckGrad.addColorStop(0, "#3a2a1a");
  neckGrad.addColorStop(0.5, "#2a1a0a");
  neckGrad.addColorStop(1, "#1a0a00");
  ctx.fillStyle = neckGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.36, y + size * 0.08 + gallop * 0.15);
  ctx.quadraticCurveTo(
    x - size * 0.52, y - size * 0.18 + headBob * 0.5,
    x - size * 0.6, y - size * 0.06 + headBob
  );
  ctx.lineTo(x - size * 0.72, y - size * 0.03 + headBob);
  ctx.lineTo(x - size * 0.58, y + size * 0.06 + headBob);
  ctx.quadraticCurveTo(
    x - size * 0.42, y + size * 0.14 + gallop * 0.15,
    x - size * 0.28, y + size * 0.2 + gallop * 0.15
  );
  ctx.fill();

  // Neck armor plate (crinet)
  ctx.fillStyle = "#5a5a62";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.38, y + size * 0.02 + gallop * 0.15);
  ctx.quadraticCurveTo(
    x - size * 0.48, y - size * 0.12 + headBob * 0.5,
    x - size * 0.54, y - size * 0.08 + headBob
  );
  ctx.lineTo(x - size * 0.5, y - size * 0.02 + headBob);
  ctx.quadraticCurveTo(
    x - size * 0.44, y + size * 0.06 + gallop * 0.15,
    x - size * 0.36, y + size * 0.08 + gallop * 0.15
  );
  ctx.closePath();
  ctx.fill();
  // Crinet gold trim
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.2;
  ctx.stroke();

  // === ORNATE CHANFRON (head armor) ===
  // Base chanfron
  const chanfronGrad = ctx.createLinearGradient(
    x - size * 0.7, y - size * 0.05,
    x - size * 0.5, y - size * 0.15
  );
  chanfronGrad.addColorStop(0, "#4a4a52");
  chanfronGrad.addColorStop(0.5, "#6a6a72");
  chanfronGrad.addColorStop(1, "#5a5a62");
  ctx.fillStyle = chanfronGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.56, y - size * 0.16 + headBob);
  ctx.lineTo(x - size * 0.72, y - size * 0.03 + headBob);
  ctx.lineTo(x - size * 0.6, y + size * 0.05 + headBob);
  ctx.lineTo(x - size * 0.52, y - size * 0.1 + headBob);
  ctx.closePath();
  ctx.fill();
  
  // Chanfron engravings
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 0.8;
  ctx.globalAlpha = 0.8;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.58, y - size * 0.1 + headBob);
  ctx.quadraticCurveTo(x - size * 0.64, y - size * 0.06, x - size * 0.6, y - size * 0.02 + headBob);
  ctx.stroke();
  ctx.globalAlpha = 1;

  // Orange accent lines on chanfron
  ctx.strokeStyle = "#e06000";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.56, y - size * 0.15 + headBob);
  ctx.lineTo(x - size * 0.68, y - size * 0.03 + headBob);
  ctx.stroke();

  // Elaborate golden crest with multiple spikes
  ctx.fillStyle = "#c9a227";
  ctx.shadowColor = "#ffaa00";
  ctx.shadowBlur = 6 * zoom;
  // Center spike
  ctx.beginPath();
  ctx.moveTo(x - size * 0.54, y - size * 0.16 + headBob);
  ctx.lineTo(x - size * 0.52, y - size * 0.3 + headBob);
  ctx.lineTo(x - size * 0.5, y - size * 0.16 + headBob);
  ctx.closePath();
  ctx.fill();
  // Side spikes
  ctx.beginPath();
  ctx.moveTo(x - size * 0.58, y - size * 0.14 + headBob);
  ctx.lineTo(x - size * 0.6, y - size * 0.24 + headBob);
  ctx.lineTo(x - size * 0.56, y - size * 0.14 + headBob);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x - size * 0.5, y - size * 0.14 + headBob);
  ctx.lineTo(x - size * 0.46, y - size * 0.22 + headBob);
  ctx.lineTo(x - size * 0.48, y - size * 0.14 + headBob);
  ctx.closePath();
  ctx.fill();
  ctx.shadowBlur = 0;

  // Chanfron gem
  ctx.fillStyle = "#ff4400";
  ctx.shadowColor = "#ff6600";
  ctx.shadowBlur = 5 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x - size * 0.58, y - size * 0.08 + headBob, size * 0.022, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Glowing orange eyes with inner fire
  ctx.fillStyle = "#d07000";
  ctx.shadowColor = "#ff6000";
  ctx.shadowBlur = 8 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.58, y - size * 0.02 + headBob, size * 0.035, 0, Math.PI * 2);
  ctx.fill();
  // Eye inner glow
  ctx.fillStyle = "#ff9030";
  ctx.beginPath();
  ctx.arc(x - size * 0.58, y - size * 0.02 + headBob, size * 0.02, 0, Math.PI * 2);
  ctx.fill();
  // Eye highlight
  ctx.fillStyle = `rgba(255, 255, 200, ${shimmer})`;
  ctx.beginPath();
  ctx.arc(x - size * 0.59, y - size * 0.025 + headBob, size * 0.008, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Proud armored ears
  ctx.fillStyle = "#2a1a0a";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.54, y - size * 0.14 + headBob);
  ctx.lineTo(x - size * 0.6, y - size * 0.26 + headBob);
  ctx.lineTo(x - size * 0.5, y - size * 0.16 + headBob);
  ctx.fill();
  // Ear armor tips
  ctx.fillStyle = "#5a5a62";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.58, y - size * 0.2 + headBob);
  ctx.lineTo(x - size * 0.6, y - size * 0.26 + headBob);
  ctx.lineTo(x - size * 0.56, y - size * 0.2 + headBob);
  ctx.closePath();
  ctx.fill();

  // === FLOWING MANE WITH FIRE EFFECT ===
  // Base mane (dark)
  ctx.fillStyle = "#1a0a00";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.46, y - size * 0.14 + headBob);
  for (let i = 0; i < 10; i++) {
    const t = i / 9;
    const maneX = x - size * 0.46 + t * size * 0.6;
    const maneWave = Math.sin(time * 8 + i * 0.6) * 5;
    const maneY = y - size * 0.28 + maneWave + gallop * (0.1 - t * 0.08) + t * size * 0.16;
    ctx.lineTo(maneX, maneY);
  }
  ctx.lineTo(x + size * 0.14, y - size * 0.04 + gallop * 0.15);
  ctx.closePath();
  ctx.fill();

  // Mane highlight strands
  ctx.strokeStyle = "#3a2a1a";
  ctx.lineWidth = 1.5;
  for (let strand = 0; strand < 5; strand++) {
    ctx.beginPath();
    const startX = x - size * 0.44 + strand * size * 0.1;
    ctx.moveTo(startX, y - size * 0.14 + headBob);
    const waveOffset = Math.sin(time * 8 + strand * 0.8) * 4;
    ctx.quadraticCurveTo(
      startX + size * 0.05 + waveOffset, y - size * 0.22,
      startX + size * 0.1 + waveOffset, y - size * 0.08 + gallop * 0.1
    );
    ctx.stroke();
  }

  // Orange flame tips on mane
  const maneGlow = 0.6 + Math.sin(time * 6) * 0.3;
  for (let i = 0; i < 8; i++) {
    const t = i / 7;
    const tipX = x - size * 0.42 + t * size * 0.56;
    const tipY = y - size * 0.32 + Math.sin(time * 8 + i * 0.7) * 5 + gallop * 0.08;
    // Outer glow
    ctx.fillStyle = `rgba(224, 96, 0, ${maneGlow * 0.5})`;
    ctx.beginPath();
    ctx.arc(tipX, tipY, size * 0.025, 0, Math.PI * 2);
    ctx.fill();
    // Inner bright
    ctx.fillStyle = `rgba(255, 180, 80, ${maneGlow})`;
    ctx.beginPath();
    ctx.arc(tipX, tipY, size * 0.015, 0, Math.PI * 2);
    ctx.fill();
  }

  // === MAJESTIC TAIL WITH FIRE ===
  // Base tail
  ctx.strokeStyle = "#1a0a00";
  ctx.lineWidth = 8 * zoom;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(x + size * 0.42, y + size * 0.12 + gallop * 0.15);
  const tailWave1 = Math.sin(time * 6) * 10;
  const tailWave2 = Math.sin(time * 6 + 1) * 12;
  ctx.quadraticCurveTo(
    x + size * 0.62 + tailWave1,
    y + size * 0.28,
    x + size * 0.58 + tailWave2,
    y + size * 0.52
  );
  ctx.stroke();

  // Tail highlight
  ctx.strokeStyle = "#2a1a0a";
  ctx.lineWidth = 4 * zoom;
  ctx.beginPath();
  ctx.moveTo(x + size * 0.42, y + size * 0.12 + gallop * 0.15);
  ctx.quadraticCurveTo(
    x + size * 0.6 + tailWave1,
    y + size * 0.26,
    x + size * 0.56 + tailWave2,
    y + size * 0.48
  );
  ctx.stroke();

  // Fire tip on tail
  ctx.fillStyle = `rgba(224, 96, 0, ${maneGlow})`;
  ctx.beginPath();
  ctx.arc(x + size * 0.58 + tailWave2, y + size * 0.52, size * 0.03, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = `rgba(255, 180, 80, ${maneGlow})`;
  ctx.beginPath();
  ctx.arc(x + size * 0.58 + tailWave2, y + size * 0.52, size * 0.018, 0, Math.PI * 2);
  ctx.fill();

  // === ROYAL KNIGHT RIDER ===
  // Elaborate ornate armored body
  const armorGrad = ctx.createLinearGradient(
    x - size * 0.17, y - size * 0.5,
    x + size * 0.17, y - size * 0.1
  );
  armorGrad.addColorStop(0, "#4a4a52");
  armorGrad.addColorStop(0.2, "#5a5a62");
  armorGrad.addColorStop(0.4, "#6a6a72");
  armorGrad.addColorStop(0.6, "#7a7a82");
  armorGrad.addColorStop(0.8, "#6a6a72");
  armorGrad.addColorStop(1, "#4a4a52");
  ctx.fillStyle = armorGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.16, y - size * 0.08 + gallop * 0.15 + breathe);
  ctx.lineTo(x - size * 0.18, y - size * 0.48 + gallop * 0.08 + breathe);
  ctx.quadraticCurveTo(
    x, y - size * 0.56 + gallop * 0.08 + breathe,
    x + size * 0.18, y - size * 0.48 + gallop * 0.08 + breathe
  );
  ctx.lineTo(x + size * 0.16, y - size * 0.08 + gallop * 0.15 + breathe);
  ctx.closePath();
  ctx.fill();

  // Armor edge highlight
  ctx.strokeStyle = "#8a8a92";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.17, y - size * 0.1 + gallop * 0.15 + breathe);
  ctx.lineTo(x - size * 0.17, y - size * 0.46 + gallop * 0.08 + breathe);
  ctx.stroke();

  // Armor segment lines
  ctx.strokeStyle = "#3a3a42";
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.15, y - size * 0.2 + gallop * 0.12 + breathe);
  ctx.lineTo(x + size * 0.15, y - size * 0.2 + gallop * 0.12 + breathe);
  ctx.moveTo(x - size * 0.14, y - size * 0.32 + gallop * 0.1 + breathe);
  ctx.lineTo(x + size * 0.14, y - size * 0.32 + gallop * 0.1 + breathe);
  ctx.stroke();

  // Gold filigree on armor
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 0.8;
  ctx.globalAlpha = 0.7;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.1, y - size * 0.15 + gallop * 0.13 + breathe);
  ctx.quadraticCurveTo(x - size * 0.14, y - size * 0.22, x - size * 0.08, y - size * 0.26 + breathe);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.1, y - size * 0.15 + gallop * 0.13 + breathe);
  ctx.quadraticCurveTo(x + size * 0.14, y - size * 0.22, x + size * 0.08, y - size * 0.26 + breathe);
  ctx.stroke();
  ctx.globalAlpha = 1;

  // Ornate orange tabard with layered design
  // Tabard shadow
  ctx.fillStyle = "#a04000";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.12, y - size * 0.06 + gallop * 0.15);
  ctx.lineTo(x - size * 0.14, y - size * 0.4 + gallop * 0.1);
  ctx.lineTo(x + size * 0.14, y - size * 0.4 + gallop * 0.1);
  ctx.lineTo(x + size * 0.12, y - size * 0.06 + gallop * 0.15);
  ctx.closePath();
  ctx.fill();
  // Main tabard
  ctx.fillStyle = "#e06000";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.11, y - size * 0.08 + gallop * 0.15);
  ctx.lineTo(x - size * 0.13, y - size * 0.38 + gallop * 0.1);
  ctx.lineTo(x + size * 0.13, y - size * 0.38 + gallop * 0.1);
  ctx.lineTo(x + size * 0.11, y - size * 0.08 + gallop * 0.15);
  ctx.closePath();
  ctx.fill();
  // Double gold trim
  ctx.strokeStyle = "#dab32f";
  ctx.lineWidth = 2 * zoom;
  ctx.stroke();
  ctx.strokeStyle = "#a08020";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.1, y - size * 0.1 + gallop * 0.15);
  ctx.lineTo(x - size * 0.12, y - size * 0.36 + gallop * 0.1);
  ctx.lineTo(x + size * 0.12, y - size * 0.36 + gallop * 0.1);
  ctx.lineTo(x + size * 0.1, y - size * 0.1 + gallop * 0.15);
  ctx.closePath();
  ctx.stroke();

  // Embroidered Princeton "P" emblem with shadow
  ctx.fillStyle = "#0a0a0a";
  ctx.font = `bold ${size * 0.14}px serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("P", x + size * 0.005, y - size * 0.23 + gallop * 0.12);
  ctx.fillStyle = "#1a1a1a";
  ctx.fillText("P", x, y - size * 0.24 + gallop * 0.12);

  // Layered pauldrons (shoulder armor)
  // Left pauldron
  ctx.save();
  ctx.translate(x - size * 0.18, y - size * 0.4 + gallop * 0.1 + breathe);
  const pauldronGradL = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.12);
  pauldronGradL.addColorStop(0, "#7a7a82");
  pauldronGradL.addColorStop(0.6, "#5a5a62");
  pauldronGradL.addColorStop(1, "#4a4a52");
  ctx.fillStyle = pauldronGradL;
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.1, size * 0.07, -0.4, 0, Math.PI * 2);
  ctx.fill();
  // Pauldron layers
  ctx.fillStyle = "#6a6a72";
  ctx.beginPath();
  ctx.ellipse(size * 0.02, size * 0.03, size * 0.07, size * 0.045, -0.4, 0, Math.PI * 2);
  ctx.fill();
  // Gold trim and spike
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.1, size * 0.07, -0.4, 0, Math.PI * 2);
  ctx.stroke();
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.moveTo(-size * 0.08, -size * 0.02);
  ctx.lineTo(-size * 0.14, -size * 0.06);
  ctx.lineTo(-size * 0.06, 0);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // Right pauldron
  ctx.save();
  ctx.translate(x + size * 0.18, y - size * 0.4 + gallop * 0.1 + breathe);
  const pauldronGradR = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.12);
  pauldronGradR.addColorStop(0, "#7a7a82");
  pauldronGradR.addColorStop(0.6, "#5a5a62");
  pauldronGradR.addColorStop(1, "#4a4a52");
  ctx.fillStyle = pauldronGradR;
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.1, size * 0.07, 0.4, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#6a6a72";
  ctx.beginPath();
  ctx.ellipse(-size * 0.02, size * 0.03, size * 0.07, size * 0.045, 0.4, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.1, size * 0.07, 0.4, 0, Math.PI * 2);
  ctx.stroke();
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.moveTo(size * 0.08, -size * 0.02);
  ctx.lineTo(size * 0.14, -size * 0.06);
  ctx.lineTo(size * 0.06, 0);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // === MAGNIFICENT GREAT HELM ===
  // Helm base with gradient
  const helmGrad = ctx.createRadialGradient(
    x - size * 0.04, y - size * 0.64 + gallop * 0.08, size * 0.02,
    x, y - size * 0.58 + gallop * 0.08, size * 0.18
  );
  helmGrad.addColorStop(0, "#8a8a92");
  helmGrad.addColorStop(0.5, "#6a6a72");
  helmGrad.addColorStop(1, "#4a4a52");
  ctx.fillStyle = helmGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.58 + gallop * 0.08, size * 0.17, 0, Math.PI * 2);
  ctx.fill();

  // Helm crest ridge
  ctx.fillStyle = "#5a5a62";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.02, y - size * 0.75 + gallop * 0.08);
  ctx.lineTo(x - size * 0.025, y - size * 0.55 + gallop * 0.08);
  ctx.lineTo(x + size * 0.025, y - size * 0.55 + gallop * 0.08);
  ctx.lineTo(x + size * 0.02, y - size * 0.75 + gallop * 0.08);
  ctx.closePath();
  ctx.fill();

  // Decorative gold rim with pattern
  ctx.strokeStyle = "#dab32f";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.58 + gallop * 0.08, size * 0.17, 0, Math.PI * 2);
  ctx.stroke();
  ctx.strokeStyle = "#a08020";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.58 + gallop * 0.08, size * 0.15, Math.PI * 0.3, Math.PI * 0.7);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(x, y - size * 0.58 + gallop * 0.08, size * 0.15, Math.PI * 1.3, Math.PI * 1.7);
  ctx.stroke();

  // Crown points on helm
  ctx.fillStyle = "#c9a227";
  for (let cp = 0; cp < 3; cp++) {
    const cpAngle = Math.PI * 1.25 + cp * Math.PI * 0.25;
    const cpX = x + Math.cos(cpAngle) * size * 0.17;
    const cpY = y - size * 0.58 + gallop * 0.08 + Math.sin(cpAngle) * size * 0.17;
    ctx.beginPath();
    ctx.moveTo(cpX, cpY);
    ctx.lineTo(cpX + Math.cos(cpAngle) * size * 0.04, cpY + Math.sin(cpAngle) * size * 0.04 - size * 0.02);
    ctx.lineTo(cpX + Math.cos(cpAngle + 0.25) * size * 0.02, cpY + Math.sin(cpAngle + 0.25) * size * 0.02);
    ctx.closePath();
    ctx.fill();
  }

  // Visor with detailed construction
  ctx.fillStyle = "#2a2a32";
  ctx.fillRect(x - size * 0.13, y - size * 0.62 + gallop * 0.08, size * 0.26, size * 0.08);
  // Visor slits
  ctx.fillStyle = "#1a1a22";
  for (let slit = 0; slit < 3; slit++) {
  ctx.fillRect(
      x - size * 0.1 + slit * size * 0.07,
    y - size * 0.6 + gallop * 0.08,
      size * 0.04,
      size * 0.012
    );
  }
  // Orange glow through visor
  ctx.fillStyle = `rgba(224, 96, 0, ${0.7 + Math.sin(time * 4) * 0.25})`;
  ctx.shadowColor = "#ff6000";
  ctx.shadowBlur = 8 * zoom;
  ctx.fillRect(x - size * 0.11, y - size * 0.6 + gallop * 0.08, size * 0.22, size * 0.04);
  ctx.shadowBlur = 0;
  // Visor breaths (air holes)
  ctx.fillStyle = "#1a1a22";
  for (let hole = 0; hole < 4; hole++) {
  ctx.beginPath();
    ctx.arc(x - size * 0.08 + hole * size * 0.05, y - size * 0.54 + gallop * 0.08, size * 0.008, 0, Math.PI * 2);
    ctx.fill();
  }

  // Central helm gem
  ctx.fillStyle = "#ff4400";
  ctx.shadowColor = "#ff6600";
  ctx.shadowBlur = 6 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.75 + gallop * 0.08, size * 0.022, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // === MAGNIFICENT MULTI-LAYERED PLUME ===
  const plumeWave = Math.sin(time * 5) * 3;
  const plumeWave2 = Math.sin(time * 5.5 + 0.5) * 2;

  // Plume shadow layer
  ctx.fillStyle = "#a04000";
  ctx.beginPath();
  ctx.moveTo(x + size * 0.02, y - size * 0.72 + gallop * 0.08);
  for (let i = 0; i < 7; i++) {
    const pY = y - size * 0.72 - i * size * 0.045 + gallop * 0.08;
    const pW = size * (0.05 + i * 0.018) + Math.sin(time * 7 + i * 0.8) * 2.5;
    ctx.lineTo(x - pW + plumeWave + size * 0.02, pY);
  }
  for (let i = 6; i >= 0; i--) {
    const pY = y - size * 0.72 - i * size * 0.045 + gallop * 0.08;
    const pW = size * (0.05 + i * 0.018) + Math.sin(time * 7 + i * 0.8) * 2.5;
    ctx.lineTo(x + pW + plumeWave + size * 0.02, pY);
  }
  ctx.closePath();
  ctx.fill();

  // Main plume
  const plumeGrad = ctx.createLinearGradient(x, y - size * 0.72, x, y - size * 1.0);
  plumeGrad.addColorStop(0, "#e06000");
  plumeGrad.addColorStop(0.3, "#ff7020");
  plumeGrad.addColorStop(0.7, "#e06000");
  plumeGrad.addColorStop(1, "#c04000");
  ctx.fillStyle = plumeGrad;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.72 + gallop * 0.08);
  for (let i = 0; i < 7; i++) {
    const pY = y - size * 0.72 - i * size * 0.045 + gallop * 0.08;
    const pW = size * (0.045 + i * 0.016) + Math.sin(time * 7 + i * 0.8) * 2;
    ctx.lineTo(x - pW + plumeWave, pY);
  }
  for (let i = 6; i >= 0; i--) {
    const pY = y - size * 0.72 - i * size * 0.045 + gallop * 0.08;
    const pW = size * (0.045 + i * 0.016) + Math.sin(time * 7 + i * 0.8) * 2;
    ctx.lineTo(x + pW + plumeWave, pY);
  }
  ctx.closePath();
  ctx.fill();

  // Plume feather highlights
  ctx.strokeStyle = "#ff9040";
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.6;
  for (let feather = 0; feather < 5; feather++) {
    const fOffset = (feather - 2) * size * 0.015;
    ctx.beginPath();
    ctx.moveTo(x + fOffset, y - size * 0.74 + gallop * 0.08);
    const fWave = Math.sin(time * 7 + feather * 0.6) * 2;
    ctx.quadraticCurveTo(
      x + fOffset + fWave, y - size * 0.88,
      x + fOffset + plumeWave * 0.5, y - size * 1.0 + gallop * 0.08
    );
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Secondary smaller plume
  ctx.fillStyle = "#ff8030";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.06, y - size * 0.7 + gallop * 0.08);
  for (let i = 0; i < 4; i++) {
    const pY = y - size * 0.7 - i * size * 0.035 + gallop * 0.08;
    const pW = size * (0.03 + i * 0.01) + Math.sin(time * 8 + i) * 1.5;
    ctx.lineTo(x - size * 0.06 - pW + plumeWave2, pY);
  }
  for (let i = 3; i >= 0; i--) {
    const pY = y - size * 0.7 - i * size * 0.035 + gallop * 0.08;
    const pW = size * (0.03 + i * 0.01) + Math.sin(time * 8 + i) * 1.5;
    ctx.lineTo(x - size * 0.06 + pW + plumeWave2, pY);
  }
  ctx.closePath();
  ctx.fill();

  // === ORNATE ROYAL LANCE ===
  ctx.save();
  const lanceAngle = isAttacking ? -0.35 - lanceThrust * 0.35 : -0.35;
  const lanceLunge = isAttacking ? size * 0.32 * Math.sin(attackPhase * Math.PI) : 0;
  ctx.translate(
    x + size * 0.26 + lanceLunge * 0.5,
    y - size * 0.32 + gallop * 0.12 - lanceLunge * 0.3
  );
  ctx.rotate(lanceAngle);

  // Ornate lance shaft with wood grain gradient
  const lanceGrad = ctx.createLinearGradient(-size * 0.04, 0, size * 0.04, 0);
  lanceGrad.addColorStop(0, "#4a2a10");
  lanceGrad.addColorStop(0.2, "#6a4a2a");
  lanceGrad.addColorStop(0.5, "#8a6a4a");
  lanceGrad.addColorStop(0.8, "#6a4a2a");
  lanceGrad.addColorStop(1, "#4a2a10");
  ctx.fillStyle = lanceGrad;
  ctx.fillRect(-size * 0.04, -size * 0.85, size * 0.08, size * 1.0);

  // Spiral leather wrapping
  ctx.strokeStyle = "#3a1a0a";
  ctx.lineWidth = 1.5;
  for (let wrap = 0; wrap < 8; wrap++) {
    const wrapY = -size * 0.15 + wrap * size * 0.1;
    ctx.beginPath();
    ctx.moveTo(-size * 0.04, wrapY);
    ctx.lineTo(size * 0.04, wrapY + size * 0.04);
    ctx.stroke();
  }

  // Ornate gold bands on shaft with gems
  ctx.fillStyle = "#c9a227";
  for (let i = 0; i < 4; i++) {
    const bandY = -size * 0.2 - i * size * 0.2;
    ctx.fillRect(-size * 0.045, bandY, size * 0.09, size * 0.04);
    // Band engraving
    ctx.strokeStyle = "#a08020";
    ctx.lineWidth = 0.8;
    ctx.beginPath();
    ctx.moveTo(-size * 0.03, bandY + size * 0.02);
    ctx.lineTo(size * 0.03, bandY + size * 0.02);
    ctx.stroke();
    // Band gem
    if (i < 3) {
      ctx.fillStyle = "#ff4400";
      ctx.shadowColor = "#ff6600";
      ctx.shadowBlur = 3 * zoom * gemPulse;
      ctx.beginPath();
      ctx.arc(0, bandY + size * 0.02, size * 0.01, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = "#c9a227";
    }
  }

  // Elaborate gleaming lance tip
  const tipGrad = ctx.createLinearGradient(-size * 0.08, -size * 0.85, size * 0.08, -size * 0.85);
  tipGrad.addColorStop(0, "#b0b0b0");
  tipGrad.addColorStop(0.3, "#e0e0e0");
  tipGrad.addColorStop(0.5, "#f0f0f0");
  tipGrad.addColorStop(0.7, "#e0e0e0");
  tipGrad.addColorStop(1, "#b0b0b0");
  ctx.fillStyle = tipGrad;
  ctx.beginPath();
  ctx.moveTo(0, -size * 1.08);
  ctx.lineTo(-size * 0.07, -size * 0.85);
  ctx.lineTo(size * 0.07, -size * 0.85);
  ctx.closePath();
  ctx.fill();

  // Lance tip edge highlight
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 0.8;
  ctx.globalAlpha = 0.6;
  ctx.beginPath();
  ctx.moveTo(0, -size * 1.06);
  ctx.lineTo(-size * 0.05, -size * 0.86);
  ctx.stroke();
  ctx.globalAlpha = 1;

  // Gold inlay pattern on tip
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, -size * 1.02);
  ctx.lineTo(0, -size * 0.88);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-size * 0.025, -size * 0.95);
  ctx.lineTo(size * 0.025, -size * 0.95);
  ctx.stroke();

  // Ornate coronet below tip
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.moveTo(-size * 0.08, -size * 0.85);
  ctx.lineTo(-size * 0.06, -size * 0.88);
  ctx.lineTo(size * 0.06, -size * 0.88);
  ctx.lineTo(size * 0.08, -size * 0.85);
  ctx.closePath();
  ctx.fill();

  // Orange energy during attack
  if (isAttacking && attackPhase > 0.15 && attackPhase < 0.85) {
    const fireIntensity = 1 - Math.abs(attackPhase - 0.5) * 2.5;
    // Outer flame
    ctx.fillStyle = `rgba(224, 96, 0, ${fireIntensity * 0.5})`;
    ctx.shadowColor = "#ff6000";
    ctx.shadowBlur = 20 * zoom;
    ctx.beginPath();
    ctx.moveTo(0, -size * 1.08);
    ctx.lineTo(-size * 0.08, -size * 1.35);
    ctx.lineTo(size * 0.08, -size * 1.35);
    ctx.closePath();
    ctx.fill();
    // Inner bright flame
    ctx.fillStyle = `rgba(255, 180, 80, ${fireIntensity * 0.7})`;
    ctx.beginPath();
    ctx.moveTo(0, -size * 1.08);
    ctx.lineTo(-size * 0.04, -size * 1.28);
    ctx.lineTo(size * 0.04, -size * 1.28);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;
    // Fire particles
    for (let fp = 0; fp < 5; fp++) {
      const fpY = -size * 1.1 - fp * size * 0.05;
      const fpX = Math.sin(time * 12 + fp * 1.5) * size * 0.04;
      ctx.fillStyle = `rgba(255, 200, 100, ${fireIntensity * (1 - fp * 0.15)})`;
      ctx.beginPath();
      ctx.arc(fpX, fpY, size * 0.012, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Ornate multi-layer pennant
  const pennantWave = Math.sin(time * 8) * 4 + (isAttacking ? lanceThrust * 6 : 0);
  // Pennant shadow
  ctx.fillStyle = "#a04000";
  ctx.beginPath();
  ctx.moveTo(-size * 0.03, -size * 0.74);
  ctx.quadraticCurveTo(
    -size * 0.22 + pennantWave,
    -size * 0.68,
    -size * 0.3 + pennantWave * 1.5,
    -size * 0.64
  );
  ctx.lineTo(-size * 0.03, -size * 0.58);
  ctx.closePath();
  ctx.fill();
  // Main pennant
  ctx.fillStyle = "#e06000";
  ctx.beginPath();
  ctx.moveTo(-size * 0.025, -size * 0.75);
  ctx.quadraticCurveTo(
    -size * 0.2 + pennantWave,
    -size * 0.69,
    -size * 0.28 + pennantWave * 1.5,
    -size * 0.65
  );
  ctx.lineTo(-size * 0.025, -size * 0.6);
  ctx.closePath();
  ctx.fill();
  // Pennant gold trim
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.2;
  ctx.stroke();
  // Pennant inner highlight
  ctx.fillStyle = "#ff8030";
  ctx.beginPath();
  ctx.moveTo(-size * 0.04, -size * 0.73);
  ctx.quadraticCurveTo(
    -size * 0.15 + pennantWave,
    -size * 0.69,
    -size * 0.2 + pennantWave * 1.2,
    -size * 0.66
  );
  ctx.lineTo(-size * 0.04, -size * 0.62);
  ctx.closePath();
  ctx.fill();
  // Black "P" on pennant with gold outline
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 0.8;
  ctx.font = `bold ${size * 0.07}px serif`;
  ctx.strokeText("P", -size * 0.12 + pennantWave * 0.6, -size * 0.67);
  ctx.fillStyle = "#1a1a1a";
  ctx.fillText("P", -size * 0.12 + pennantWave * 0.6, -size * 0.67);
  ctx.restore();

  // === ORNATE ROYAL SHIELD ===
  ctx.save();
  ctx.translate(x - size * 0.26, y - size * 0.18 + gallop * 0.12);
  ctx.rotate(-0.15);

  // Shield shadow
  ctx.fillStyle = "rgba(0,0,0,0.3)";
  ctx.beginPath();
  ctx.moveTo(size * 0.02, -size * 0.22);
  ctx.lineTo(-size * 0.13, -size * 0.11);
  ctx.lineTo(-size * 0.11, size * 0.2);
  ctx.lineTo(size * 0.02, size * 0.28);
  ctx.lineTo(size * 0.14, size * 0.2);
  ctx.lineTo(size * 0.16, -size * 0.11);
  ctx.closePath();
  ctx.fill();

  // Ornate kite shield with gradient
  const shieldGrad = ctx.createLinearGradient(-size * 0.15, 0, size * 0.15, 0);
  shieldGrad.addColorStop(0, "#2a2a32");
  shieldGrad.addColorStop(0.3, "#4a4a52");
  shieldGrad.addColorStop(0.5, "#5a5a62");
  shieldGrad.addColorStop(0.7, "#4a4a52");
  shieldGrad.addColorStop(1, "#2a2a32");
  ctx.fillStyle = shieldGrad;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.26);
  ctx.lineTo(-size * 0.15, -size * 0.14);
  ctx.lineTo(-size * 0.13, size * 0.2);
  ctx.lineTo(0, size * 0.28);
  ctx.lineTo(size * 0.13, size * 0.2);
  ctx.lineTo(size * 0.15, -size * 0.14);
  ctx.closePath();
  ctx.fill();

  // Shield edge highlight
  ctx.strokeStyle = "#6a6a72";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-size * 0.01, -size * 0.25);
  ctx.lineTo(-size * 0.14, -size * 0.13);
  ctx.stroke();

  // Orange field with gradient
  const fieldGrad = ctx.createLinearGradient(0, -size * 0.18, 0, size * 0.2);
  fieldGrad.addColorStop(0, "#ff7020");
  fieldGrad.addColorStop(0.5, "#e06000");
  fieldGrad.addColorStop(1, "#c04000");
  ctx.fillStyle = fieldGrad;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.2);
  ctx.lineTo(-size * 0.11, -size * 0.09);
  ctx.lineTo(-size * 0.09, size * 0.15);
  ctx.lineTo(0, size * 0.21);
  ctx.lineTo(size * 0.09, size * 0.15);
  ctx.lineTo(size * 0.11, -size * 0.09);
  ctx.closePath();
  ctx.fill();

  // Shield filigree engravings
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 0.8;
  ctx.globalAlpha = 0.6;
  // Top swirl
  ctx.beginPath();
  ctx.moveTo(-size * 0.06, -size * 0.12);
  ctx.quadraticCurveTo(-size * 0.08, -size * 0.06, -size * 0.04, -size * 0.02);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(size * 0.06, -size * 0.12);
  ctx.quadraticCurveTo(size * 0.08, -size * 0.06, size * 0.04, -size * 0.02);
  ctx.stroke();
  // Bottom swirl
  ctx.beginPath();
  ctx.moveTo(-size * 0.04, size * 0.1);
  ctx.quadraticCurveTo(-size * 0.06, size * 0.14, -size * 0.02, size * 0.16);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(size * 0.04, size * 0.1);
  ctx.quadraticCurveTo(size * 0.06, size * 0.14, size * 0.02, size * 0.16);
  ctx.stroke();
  ctx.globalAlpha = 1;

  // Double gold trim
  ctx.strokeStyle = "#dab32f";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.26);
  ctx.lineTo(-size * 0.15, -size * 0.14);
  ctx.lineTo(-size * 0.13, size * 0.2);
  ctx.lineTo(0, size * 0.28);
  ctx.lineTo(size * 0.13, size * 0.2);
  ctx.lineTo(size * 0.15, -size * 0.14);
  ctx.closePath();
  ctx.stroke();
  ctx.strokeStyle = "#a08020";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.23);
  ctx.lineTo(-size * 0.12, -size * 0.12);
  ctx.lineTo(-size * 0.1, size * 0.17);
  ctx.lineTo(0, size * 0.24);
  ctx.lineTo(size * 0.1, size * 0.17);
  ctx.lineTo(size * 0.12, -size * 0.12);
  ctx.closePath();
  ctx.stroke();

  // Corner gems on shield
  ctx.fillStyle = "#ff4400";
  ctx.shadowColor = "#ff6600";
  ctx.shadowBlur = 4 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(0, -size * 0.22, size * 0.018, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(-size * 0.1, size * 0.12, size * 0.012, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(size * 0.1, size * 0.12, size * 0.012, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Ornate "P" emblem with shadow
  ctx.fillStyle = "#0a0a0a";
  ctx.font = `bold ${size * 0.12}px serif`;
  ctx.textAlign = "center";
  ctx.fillText("P", size * 0.005, size * 0.065);
  ctx.fillStyle = "#1a1a1a";
  ctx.fillText("P", 0, size * 0.06);
  // Gold outline on P
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 0.6;
  ctx.strokeText("P", 0, size * 0.06);

  // Shield boss (center boss)
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.arc(0, size * 0.02, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#dab32f";
  ctx.beginPath();
  ctx.arc(0, size * 0.02, size * 0.015, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawCentaurTroop(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // EPIC ORNATE CENTAUR ARCHER - Golden War Champion of Princeton
  const gallop = Math.sin(time * 7) * 4;
  const legCycle = Math.sin(time * 7) * 0.4;
  const breathe = Math.sin(time * 2) * 0.5;
  const tailSwish = Math.sin(time * 5);
  const hairFlow = Math.sin(time * 4);
  const shimmer = Math.sin(time * 5) * 0.5 + 0.5;
  const gemPulse = Math.sin(time * 2.5) * 0.3 + 0.7;

  // Attack animation - bow draw and release
  const isAttacking = attackPhase > 0;
  const bowDraw = isAttacking ? Math.sin(attackPhase * Math.PI) : 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0

  // === MULTI-LAYERED MAJESTIC GOLDEN AURA ===
  const auraIntensity = isAttacking ? 0.6 : 0.35;
  const auraPulse = 0.85 + Math.sin(time * 3) * 0.15;

  // Multiple layered auras for depth
  for (let auraLayer = 0; auraLayer < 3; auraLayer++) {
    const layerOffset = auraLayer * 0.12;
  const auraGrad = ctx.createRadialGradient(
      x + size * 0.05, y + size * 0.1, size * (0.08 + layerOffset),
      x + size * 0.05, y + size * 0.1, size * (0.9 + layerOffset * 0.3)
    );
    auraGrad.addColorStop(0, `rgba(255, 215, 80, ${auraIntensity * auraPulse * (0.5 - auraLayer * 0.12)})`);
    auraGrad.addColorStop(0.3, `rgba(255, 180, 50, ${auraIntensity * auraPulse * (0.35 - auraLayer * 0.08)})`);
    auraGrad.addColorStop(0.6, `rgba(200, 140, 20, ${auraIntensity * auraPulse * (0.2 - auraLayer * 0.05)})`);
    auraGrad.addColorStop(1, "rgba(200, 100, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
    ctx.ellipse(x + size * 0.05, y + size * 0.15, size * (0.8 + layerOffset * 0.2), size * (0.55 + layerOffset * 0.15), 0, 0, Math.PI * 2);
  ctx.fill();
  }

  // Floating golden rune particles
  for (let p = 0; p < 10; p++) {
    const pAngle = (time * 1.5 + p * Math.PI * 0.2) % (Math.PI * 2);
    const pDist = size * 0.55 + Math.sin(time * 2.5 + p * 0.7) * size * 0.12;
    const px = x + Math.cos(pAngle) * pDist;
    const py = y + size * 0.1 + Math.sin(pAngle) * pDist * 0.38;
    const pAlpha = 0.5 + Math.sin(time * 4 + p * 0.6) * 0.3;
    // Outer glow
    ctx.fillStyle = `rgba(255, 215, 0, ${pAlpha * 0.5})`;
    ctx.beginPath();
    ctx.arc(px, py, size * 0.022, 0, Math.PI * 2);
    ctx.fill();
    // Inner bright
    ctx.fillStyle = `rgba(255, 240, 150, ${pAlpha})`;
    ctx.beginPath();
    ctx.arc(px, py, size * 0.012, 0, Math.PI * 2);
    ctx.fill();
  }

  // === ENERGY RINGS (during attack) ===
  if (isAttacking) {
    for (let ring = 0; ring < 4; ring++) {
      const ringPhase = (attackPhase * 2.5 + ring * 0.12) % 1;
      const ringAlpha = (1 - ringPhase) * 0.6 * attackIntensity;
      ctx.strokeStyle = `rgba(255, 215, 80, ${ringAlpha})`;
      ctx.lineWidth = (3.5 - ring * 0.5) * zoom;
      ctx.beginPath();
      ctx.ellipse(
        x, y + size * 0.1,
        size * (0.5 + ringPhase * 0.45),
        size * (0.32 + ringPhase * 0.28),
        0, 0, Math.PI * 2
      );
      ctx.stroke();
    }
    // Golden spark particles
    for (let sp = 0; sp < 8; sp++) {
      const spAngle = time * 6 + sp * Math.PI / 4;
      const spDist = size * 0.35 + attackIntensity * size * 0.35;
      const spX = x + Math.cos(spAngle) * spDist;
      const spY = y + size * 0.1 + Math.sin(spAngle) * spDist * 0.4;
      ctx.fillStyle = `rgba(255, 230, 120, ${attackIntensity * 0.8})`;
      ctx.beginPath();
      ctx.arc(spX, spY, size * 0.015, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // === SHADOW WITH DEPTH ===
  const shadowGrad = ctx.createRadialGradient(x + size * 0.05, y + size * 0.55, 0, x + size * 0.05, y + size * 0.55, size * 0.55);
  shadowGrad.addColorStop(0, "rgba(0, 0, 0, 0.5)");
  shadowGrad.addColorStop(0.6, "rgba(0, 0, 0, 0.3)");
  shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x + size * 0.05, y + size * 0.55, size * 0.55, size * 0.16, 0, 0, Math.PI * 2);
  ctx.fill();

  // === POWERFUL HORSE BODY WITH DETAILED COAT ===
  // Main body with rich golden gradient
  const bodyGrad = ctx.createRadialGradient(
    x + size * 0.02, y + size * 0.05, 0,
    x + size * 0.08, y + size * 0.15, size * 0.55
  );
  bodyGrad.addColorStop(0, "#f0d878");
  bodyGrad.addColorStop(0.25, "#e8c868");
  bodyGrad.addColorStop(0.5, "#c09838");
  bodyGrad.addColorStop(0.75, "#9a7820");
  bodyGrad.addColorStop(1, "#6b5010");
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.ellipse(
    x + size * 0.08, y + size * 0.15 + gallop * 0.12,
    size * 0.46, size * 0.28,
    0, 0, Math.PI * 2
  );
  ctx.fill();

  // Muscle definition highlights
  ctx.strokeStyle = "rgba(240, 220, 150, 0.4)";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.1, y + size * 0.08 + gallop * 0.12, size * 0.14, 0.4, 2.2);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(x + size * 0.3, y + size * 0.06 + gallop * 0.12, size * 0.12, 0.5, 2.0);
  ctx.stroke();

  // Muscle definition shadows
  ctx.strokeStyle = "rgba(107,80,16,0.5)";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.arc(x - size * 0.08, y + size * 0.14 + gallop * 0.12, size * 0.17, 0.3, 2.5);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(x + size * 0.28, y + size * 0.12 + gallop * 0.12, size * 0.15, 0.4, 2.3);
  ctx.stroke();

  // Battle scars (honorable marks)
  ctx.strokeStyle = "rgba(100, 70, 30, 0.35)";
  ctx.lineWidth = 1.2 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.12, y + size * 0.04 + gallop * 0.12);
  ctx.lineTo(x - size * 0.02, y + size * 0.16 + gallop * 0.12);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.15, y + size * 0.02 + gallop * 0.12);
  ctx.lineTo(x + size * 0.22, y + size * 0.12 + gallop * 0.12);
  ctx.stroke();

  // === ORNATE ARMORED BARDING ===
  // Chest armor plate with gradient
  const chestArmorGrad = ctx.createLinearGradient(
    x - size * 0.35, y + size * 0.1,
    x - size * 0.1, y + size * 0.25
  );
  chestArmorGrad.addColorStop(0, "#6b5010");
  chestArmorGrad.addColorStop(0.3, "#9a7820");
  chestArmorGrad.addColorStop(0.6, "#8b6914");
  chestArmorGrad.addColorStop(1, "#6b5010");
  ctx.fillStyle = chestArmorGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.27, y + size * 0.03 + gallop * 0.12);
  ctx.lineTo(x - size * 0.38, y + size * 0.22 + gallop * 0.12);
  ctx.lineTo(x - size * 0.22, y + size * 0.28 + gallop * 0.12);
  ctx.lineTo(x - size * 0.08, y + size * 0.08 + gallop * 0.12);
  ctx.closePath();
  ctx.fill();

  // Armor edge highlight
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.5 * zoom;
  ctx.stroke();

  // Engraved filigree on chest armor
  ctx.strokeStyle = "#dab32f";
  ctx.lineWidth = 0.8;
  ctx.globalAlpha = 0.7;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.28, y + size * 0.1 + gallop * 0.12);
  ctx.quadraticCurveTo(x - size * 0.32, y + size * 0.16, x - size * 0.26, y + size * 0.2 + gallop * 0.12);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x - size * 0.22, y + size * 0.08 + gallop * 0.12);
  ctx.quadraticCurveTo(x - size * 0.26, y + size * 0.14, x - size * 0.2, y + size * 0.18 + gallop * 0.12);
  ctx.stroke();
  ctx.globalAlpha = 1;

  // Chest armor gem
  ctx.fillStyle = "#ff4400";
  ctx.shadowColor = "#ff6600";
  ctx.shadowBlur = 5 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x - size * 0.25, y + size * 0.14 + gallop * 0.12, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Back armor plate
  const backArmorGrad = ctx.createLinearGradient(
    x + size * 0.2, y + size * 0.0,
    x + size * 0.4, y + size * 0.2
  );
  backArmorGrad.addColorStop(0, "#8b6914");
  backArmorGrad.addColorStop(0.5, "#9a7820");
  backArmorGrad.addColorStop(1, "#6b5010");
  ctx.fillStyle = backArmorGrad;
  ctx.beginPath();
  ctx.moveTo(x + size * 0.25, y + gallop * 0.12);
  ctx.lineTo(x + size * 0.42, y + size * 0.08 + gallop * 0.12);
  ctx.lineTo(x + size * 0.38, y + size * 0.22 + gallop * 0.12);
  ctx.lineTo(x + size * 0.22, y + size * 0.18 + gallop * 0.12);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.2 * zoom;
  ctx.stroke();

  // Back armor gem
  ctx.fillStyle = "#00aaff";
  ctx.shadowColor = "#00ccff";
  ctx.shadowBlur = 4 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x + size * 0.32, y + size * 0.1 + gallop * 0.12, size * 0.02, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Decorative medallion chain across body
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.2, y + size * 0.22 + gallop * 0.12);
  ctx.quadraticCurveTo(x, y + size * 0.26 + gallop * 0.12, x + size * 0.2, y + size * 0.22 + gallop * 0.12);
  ctx.stroke();
  // Medallions on chain
  for (let med = 0; med < 5; med++) {
    const medX = x - size * 0.16 + med * size * 0.09;
    const medY = y + size * 0.24 + Math.sin(med * 0.8) * size * 0.015 + gallop * 0.12;
    ctx.fillStyle = "#dab32f";
    ctx.beginPath();
    ctx.arc(medX, medY, size * 0.018, 0, Math.PI * 2);
    ctx.fill();
  }

  // === POWERFUL LEGS WITH ORNATE ARMOR ===
  // Leg gradient
  const legGrad = ctx.createLinearGradient(-size * 0.06, 0, size * 0.06, 0);
  legGrad.addColorStop(0, "#9a7820");
  legGrad.addColorStop(0.3, "#c09838");
  legGrad.addColorStop(0.7, "#c09838");
  legGrad.addColorStop(1, "#9a7820");

  // Front left leg
  ctx.save();
  ctx.translate(x - size * 0.2, y + size * 0.34 + gallop * 0.1);
  ctx.rotate(legCycle * 1.1);
  // Upper leg (muscular)
  ctx.fillStyle = legGrad;
  ctx.beginPath();
  ctx.moveTo(-size * 0.06, 0);
  ctx.quadraticCurveTo(-size * 0.09, size * 0.1, -size * 0.05, size * 0.18);
  ctx.lineTo(size * 0.05, size * 0.18);
  ctx.quadraticCurveTo(size * 0.09, size * 0.1, size * 0.06, 0);
  ctx.closePath();
  ctx.fill();
  // Muscle highlight
  ctx.fillStyle = "rgba(240, 220, 150, 0.3)";
  ctx.beginPath();
  ctx.ellipse(size * 0.02, size * 0.08, size * 0.025, size * 0.05, 0, 0, Math.PI * 2);
  ctx.fill();
  // Lower leg
  ctx.fillStyle = "#a08028";
  ctx.fillRect(-size * 0.045, size * 0.16, size * 0.09, size * 0.17);
  // Leg armor band
  ctx.fillStyle = "#8b6914";
  ctx.fillRect(-size * 0.05, size * 0.12, size * 0.1, size * 0.04);
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1;
  ctx.strokeRect(-size * 0.05, size * 0.12, size * 0.1, size * 0.04);
  // Ornate hoof with glow
  ctx.fillStyle = "#c9a227";
  ctx.shadowColor = "#ffcc00";
  ctx.shadowBlur = 6 * zoom * gemPulse;
  ctx.beginPath();
  ctx.ellipse(0, size * 0.34, size * 0.06, size * 0.032, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#dab32f";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.335, size * 0.04, size * 0.02, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // Front right leg
  ctx.save();
  ctx.translate(x - size * 0.05, y + size * 0.34 + gallop * 0.1);
  ctx.rotate(-legCycle * 0.85);
  ctx.fillStyle = legGrad;
  ctx.beginPath();
  ctx.moveTo(-size * 0.06, 0);
  ctx.quadraticCurveTo(-size * 0.08, size * 0.1, -size * 0.045, size * 0.18);
  ctx.lineTo(size * 0.045, size * 0.18);
  ctx.quadraticCurveTo(size * 0.08, size * 0.1, size * 0.06, 0);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = "rgba(240, 220, 150, 0.3)";
  ctx.beginPath();
  ctx.ellipse(size * 0.02, size * 0.08, size * 0.025, size * 0.05, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#a08028";
  ctx.fillRect(-size * 0.045, size * 0.16, size * 0.09, size * 0.17);
  ctx.fillStyle = "#8b6914";
  ctx.fillRect(-size * 0.05, size * 0.12, size * 0.1, size * 0.04);
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1;
  ctx.strokeRect(-size * 0.05, size * 0.12, size * 0.1, size * 0.04);
  ctx.fillStyle = "#c9a227";
  ctx.shadowColor = "#ffcc00";
  ctx.shadowBlur = 6 * zoom * gemPulse;
  ctx.beginPath();
  ctx.ellipse(0, size * 0.34, size * 0.06, size * 0.032, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#dab32f";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.335, size * 0.04, size * 0.02, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // Back left leg
  ctx.save();
  ctx.translate(x + size * 0.22, y + size * 0.34 + gallop * 0.1);
  ctx.rotate(-legCycle * 1.0);
  ctx.fillStyle = legGrad;
  ctx.beginPath();
  ctx.moveTo(-size * 0.06, 0);
  ctx.quadraticCurveTo(-size * 0.09, size * 0.1, -size * 0.05, size * 0.18);
  ctx.lineTo(size * 0.05, size * 0.18);
  ctx.quadraticCurveTo(size * 0.09, size * 0.1, size * 0.06, 0);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = "rgba(240, 220, 150, 0.3)";
  ctx.beginPath();
  ctx.ellipse(size * 0.02, size * 0.08, size * 0.025, size * 0.05, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#a08028";
  ctx.fillRect(-size * 0.045, size * 0.16, size * 0.09, size * 0.17);
  ctx.fillStyle = "#8b6914";
  ctx.fillRect(-size * 0.05, size * 0.12, size * 0.1, size * 0.04);
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1;
  ctx.strokeRect(-size * 0.05, size * 0.12, size * 0.1, size * 0.04);
  ctx.fillStyle = "#c9a227";
  ctx.shadowColor = "#ffcc00";
  ctx.shadowBlur = 6 * zoom * gemPulse;
  ctx.beginPath();
  ctx.ellipse(0, size * 0.34, size * 0.06, size * 0.032, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#dab32f";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.335, size * 0.04, size * 0.02, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // Back right leg
  ctx.save();
  ctx.translate(x + size * 0.37, y + size * 0.34 + gallop * 0.1);
  ctx.rotate(legCycle * 0.9);
  ctx.fillStyle = legGrad;
  ctx.beginPath();
  ctx.moveTo(-size * 0.06, 0);
  ctx.quadraticCurveTo(-size * 0.08, size * 0.1, -size * 0.045, size * 0.18);
  ctx.lineTo(size * 0.045, size * 0.18);
  ctx.quadraticCurveTo(size * 0.08, size * 0.1, size * 0.06, 0);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = "rgba(240, 220, 150, 0.3)";
  ctx.beginPath();
  ctx.ellipse(size * 0.02, size * 0.08, size * 0.025, size * 0.05, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#a08028";
  ctx.fillRect(-size * 0.045, size * 0.16, size * 0.09, size * 0.17);
  ctx.fillStyle = "#8b6914";
  ctx.fillRect(-size * 0.05, size * 0.12, size * 0.1, size * 0.04);
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1;
  ctx.strokeRect(-size * 0.05, size * 0.12, size * 0.1, size * 0.04);
  ctx.fillStyle = "#c9a227";
  ctx.shadowColor = "#ffcc00";
  ctx.shadowBlur = 6 * zoom * gemPulse;
  ctx.beginPath();
  ctx.ellipse(0, size * 0.34, size * 0.06, size * 0.032, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#dab32f";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.335, size * 0.04, size * 0.02, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // === MAJESTIC FLOWING TAIL ===
  // Tail base (dark)
  ctx.strokeStyle = "#5a4010";
  ctx.lineWidth = 9 * zoom;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(x + size * 0.5, y + size * 0.06 + gallop * 0.12);
  ctx.quadraticCurveTo(
    x + size * 0.72 + tailSwish * 12,
    y + size * 0.14,
    x + size * 0.62 + tailSwish * 16,
    y + size * 0.46
  );
  ctx.stroke();

  // Tail main layer
  ctx.strokeStyle = "#6b5010";
  ctx.lineWidth = 7 * zoom;
  ctx.beginPath();
  ctx.moveTo(x + size * 0.5, y + size * 0.07 + gallop * 0.12);
  ctx.quadraticCurveTo(
    x + size * 0.7 + tailSwish * 11,
    y + size * 0.15,
    x + size * 0.6 + tailSwish * 15,
    y + size * 0.44
  );
  ctx.stroke();

  // Tail highlight strands
  ctx.strokeStyle = "#c09838";
  ctx.lineWidth = 3 * zoom;
  ctx.beginPath();
  ctx.moveTo(x + size * 0.5, y + size * 0.08 + gallop * 0.12);
  ctx.quadraticCurveTo(
    x + size * 0.65 + tailSwish * 8,
    y + size * 0.14,
    x + size * 0.56 + tailSwish * 12,
    y + size * 0.38
  );
  ctx.stroke();

  // Golden tail tip glow
  ctx.fillStyle = `rgba(255, 215, 100, ${0.5 + Math.sin(time * 4) * 0.3})`;
  ctx.beginPath();
  ctx.arc(x + size * 0.62 + tailSwish * 16, y + size * 0.46, size * 0.025, 0, Math.PI * 2);
  ctx.fill();

  // === MUSCULAR HUMAN TORSO ===
  // Back muscles layer
  ctx.fillStyle = "#c89050";
  ctx.beginPath();
  ctx.ellipse(
    x, y - size * 0.06 + gallop * 0.08 + breathe,
    size * 0.24, size * 0.2,
    0, 0, Math.PI * 2
  );
  ctx.fill();

  // Main torso with rich gradient
  const torsoGrad = ctx.createLinearGradient(
    x - size * 0.24, y - size * 0.25,
    x + size * 0.24, y + size * 0.05
  );
  torsoGrad.addColorStop(0, "#c08040");
  torsoGrad.addColorStop(0.2, "#d8a060");
  torsoGrad.addColorStop(0.4, "#e8b878");
  torsoGrad.addColorStop(0.6, "#e8b070");
  torsoGrad.addColorStop(0.8, "#d8a060");
  torsoGrad.addColorStop(1, "#c08040");
  ctx.fillStyle = torsoGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.22, y + size * 0.02 + gallop * 0.08 + breathe);
  ctx.lineTo(x - size * 0.28, y - size * 0.32 + gallop * 0.04 + breathe * 0.5);
  ctx.quadraticCurveTo(
    x, y - size * 0.46 + gallop * 0.04 + breathe * 0.3,
    x + size * 0.28, y - size * 0.32 + gallop * 0.04 + breathe * 0.5
  );
  ctx.lineTo(x + size * 0.22, y + size * 0.02 + gallop * 0.08 + breathe);
  ctx.closePath();
  ctx.fill();

  // Chest/pec definition
  ctx.strokeStyle = "rgba(180, 130, 80, 0.4)";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.18, y - size * 0.24 + gallop * 0.05 + breathe * 0.4);
  ctx.quadraticCurveTo(
    x, y - size * 0.18 + gallop * 0.05 + breathe * 0.4,
    x + size * 0.18, y - size * 0.24 + gallop * 0.05 + breathe * 0.4
  );
  ctx.stroke();
  // Ab definition lines
  ctx.strokeStyle = "rgba(139,90,50,0.35)";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.3 + gallop * 0.05 + breathe * 0.3);
  ctx.lineTo(x, y - size * 0.05 + gallop * 0.08 + breathe);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x - size * 0.1, y - size * 0.16 + gallop * 0.06 + breathe * 0.5);
  ctx.lineTo(x + size * 0.1, y - size * 0.16 + gallop * 0.06 + breathe * 0.5);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x - size * 0.08, y - size * 0.08 + gallop * 0.07 + breathe * 0.7);
  ctx.lineTo(x + size * 0.08, y - size * 0.08 + gallop * 0.07 + breathe * 0.7);
  ctx.stroke();

  // Ornate warrior sash with detail
  const sashGrad = ctx.createLinearGradient(
    x - size * 0.22, y - size * 0.26,
    x + size * 0.1, y - size * 0.04
  );
  sashGrad.addColorStop(0, "#e06000");
  sashGrad.addColorStop(0.5, "#ff7020");
  sashGrad.addColorStop(1, "#d04000");
  ctx.fillStyle = sashGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.22, y - size * 0.27 + gallop * 0.05);
  ctx.lineTo(x + size * 0.14, y - size * 0.08 + gallop * 0.08);
  ctx.lineTo(x + size * 0.1, y - size * 0.02 + gallop * 0.08);
  ctx.lineTo(x - size * 0.26, y - size * 0.22 + gallop * 0.05);
  ctx.closePath();
  ctx.fill();
  // Sash gold trim
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.2;
  ctx.stroke();
  // Sash medallion
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.arc(x - size * 0.06, y - size * 0.16 + gallop * 0.06, size * 0.025, 0, Math.PI * 2);
  ctx.fill();

  // === POWERFUL ARMS WITH BRACERS ===
  // Left arm (drawing bow)
  ctx.save();
  ctx.translate(x - size * 0.3, y - size * 0.2 + gallop * 0.05);
  ctx.rotate(-0.55);
  // Upper arm
  const armGrad = ctx.createRadialGradient(0, size * 0.08, 0, 0, size * 0.08, size * 0.12);
  armGrad.addColorStop(0, "#e8b878");
  armGrad.addColorStop(1, "#c89050");
  ctx.fillStyle = armGrad;
  ctx.beginPath();
  ctx.ellipse(0, size * 0.08, size * 0.065, size * 0.13, 0, 0, Math.PI * 2);
  ctx.fill();
  // Forearm
  ctx.fillStyle = "#e0a868";
  ctx.beginPath();
  ctx.ellipse(-size * 0.05, size * 0.22, size * 0.055, size * 0.11, -0.3, 0, Math.PI * 2);
  ctx.fill();
  // Ornate bracer
  ctx.fillStyle = "#8b6914";
  ctx.beginPath();
  ctx.ellipse(-size * 0.06, size * 0.2, size * 0.06, size * 0.05, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1;
  ctx.stroke();
  // Bracer gem
  ctx.fillStyle = "#ff4400";
  ctx.shadowColor = "#ff6600";
  ctx.shadowBlur = 3 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(-size * 0.06, size * 0.2, size * 0.015, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // Right arm (holding bowstring back)
  ctx.save();
  ctx.translate(x + size * 0.3, y - size * 0.2 + gallop * 0.05);
  ctx.rotate(0.45);
  ctx.fillStyle = armGrad;
  ctx.beginPath();
  ctx.ellipse(0, size * 0.08, size * 0.065, size * 0.13, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#e0a868";
  ctx.beginPath();
  ctx.ellipse(size * 0.04, size * 0.2, size * 0.055, size * 0.11, 0.25, 0, Math.PI * 2);
  ctx.fill();
  // Bracer
  ctx.fillStyle = "#8b6914";
  ctx.beginPath();
  ctx.ellipse(size * 0.05, size * 0.18, size * 0.06, size * 0.05, 0.25, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.fillStyle = "#00aaff";
  ctx.shadowColor = "#00ccff";
  ctx.shadowBlur = 3 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(size * 0.05, size * 0.18, size * 0.015, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // === ORNATE HEAD ===
  // Neck with highlights
  const neckGrad = ctx.createLinearGradient(x - size * 0.06, y - size * 0.42, x + size * 0.06, y - size * 0.42);
  neckGrad.addColorStop(0, "#c89050");
  neckGrad.addColorStop(0.5, "#e0a868");
  neckGrad.addColorStop(1, "#c89050");
  ctx.fillStyle = neckGrad;
  ctx.fillRect(x - size * 0.07, y - size * 0.42 + gallop * 0.04, size * 0.14, size * 0.12);

  // Face with gradient
  const faceGrad = ctx.createRadialGradient(
    x - size * 0.02, y - size * 0.52 + gallop * 0.04, 0,
    x, y - size * 0.5 + gallop * 0.04, size * 0.15
  );
  faceGrad.addColorStop(0, "#f0c890");
  faceGrad.addColorStop(0.6, "#e8b878");
  faceGrad.addColorStop(1, "#d8a060");
  ctx.fillStyle = faceGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.52 + gallop * 0.04, size * 0.15, 0, Math.PI * 2);
  ctx.fill();

  // === FLOWING GOLDEN HAIR WITH DETAIL ===
  // Hair shadow layer
  ctx.fillStyle = "#9a7820";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.14, y - size * 0.6 + gallop * 0.04);
  for (let i = 0; i < 10; i++) {
    const hairAngle = -1.0 + i * 0.24;
    const hairWave = Math.sin(time * 5.5 + i * 0.5) * 4 + hairFlow * 2.5;
    const hairLen = size * (0.22 + (i > 4 ? 0.12 : 0));
    ctx.lineTo(
      x + Math.cos(hairAngle) * hairLen + hairWave * 0.6,
      y - size * 0.52 + Math.sin(hairAngle) * hairLen * 0.85 + hairWave + gallop * 0.04
    );
  }
  ctx.closePath();
  ctx.fill();

  // Main hair
  ctx.fillStyle = "#c09838";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.13, y - size * 0.62 + gallop * 0.04);
  for (let i = 0; i < 9; i++) {
    const hairAngle = -0.95 + i * 0.25;
    const hairWave = Math.sin(time * 5 + i * 0.5) * 3.5 + hairFlow * 2;
    const hairLen = size * (0.2 + (i > 4 ? 0.1 : 0));
    ctx.lineTo(
      x + Math.cos(hairAngle) * hairLen + hairWave * 0.5,
      y - size * 0.52 + Math.sin(hairAngle) * hairLen * 0.82 + hairWave + gallop * 0.04
    );
  }
  ctx.closePath();
  ctx.fill();

  // Hair highlight strands
  ctx.fillStyle = "#e0c058";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.09, y - size * 0.64 + gallop * 0.04);
  for (let i = 0; i < 6; i++) {
    const hairAngle = -0.75 + i * 0.32;
    const hairWave = Math.sin(time * 5 + i * 0.6) * 2.5 + hairFlow * 1.5;
    ctx.lineTo(
      x + Math.cos(hairAngle) * size * 0.16 + hairWave * 0.35,
      y - size * 0.54 + Math.sin(hairAngle) * size * 0.13 + hairWave * 0.55 + gallop * 0.04
    );
  }
  ctx.closePath();
  ctx.fill();

  // Brightest highlights
  ctx.strokeStyle = "#f0d878";
  ctx.lineWidth = 1.2;
  ctx.globalAlpha = 0.6;
  for (let strand = 0; strand < 4; strand++) {
    const strandAngle = -0.6 + strand * 0.4;
    const strandWave = Math.sin(time * 5 + strand * 0.8) * 2;
  ctx.beginPath();
    ctx.moveTo(x + Math.cos(strandAngle) * size * 0.08, y - size * 0.58 + gallop * 0.04);
    ctx.quadraticCurveTo(
      x + Math.cos(strandAngle) * size * 0.14 + strandWave,
      y - size * 0.52 + Math.sin(strandAngle) * size * 0.08,
      x + Math.cos(strandAngle) * size * 0.18 + strandWave * 1.5,
      y - size * 0.46 + Math.sin(strandAngle) * size * 0.12 + gallop * 0.04
  );
  ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // === ORNATE LAUREL CROWN ===
  // Crown base band
  ctx.strokeStyle = "#dab32f";
  ctx.lineWidth = 2.5 * zoom;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.57 + gallop * 0.04, size * 0.14, Math.PI * 0.75, Math.PI * 0.25, true);
  ctx.stroke();
  ctx.strokeStyle = "#a08020";
  ctx.lineWidth = 1 * zoom;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.57 + gallop * 0.04, size * 0.12, Math.PI * 0.8, Math.PI * 0.2, true);
  ctx.stroke();

  // Elaborate laurel leaves
  ctx.fillStyle = "#c9a227";
  for (let side = -1; side <= 1; side += 2) {
    for (let i = 0; i < 6; i++) {
      const leafAngle = side === -1 ? Math.PI * 0.75 - i * 0.12 : Math.PI * 0.25 + i * 0.12;
      const leafX = x + Math.cos(leafAngle) * size * 0.14;
      const leafY = y - size * 0.57 + Math.sin(leafAngle) * size * 0.14 + gallop * 0.04;
      const leafSize = size * (0.028 - i * 0.002);
    ctx.beginPath();
      ctx.ellipse(leafX, leafY, leafSize, leafSize * 0.45, leafAngle + Math.PI * 0.5 * side, 0, Math.PI * 2);
    ctx.fill();
    }
  }

  // Crown center gem
  ctx.fillStyle = "#ff4400";
  ctx.shadowColor = "#ff6600";
  ctx.shadowBlur = 6 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.71 + gallop * 0.04, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Gem highlight
  ctx.fillStyle = `rgba(255, 255, 200, ${shimmer * 0.8})`;
  ctx.beginPath();
  ctx.arc(x - size * 0.008, y - size * 0.715 + gallop * 0.04, size * 0.008, 0, Math.PI * 2);
  ctx.fill();

  // Side crown gems
  ctx.fillStyle = "#00aaff";
  ctx.shadowColor = "#00ccff";
  ctx.shadowBlur = 4 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x - size * 0.12, y - size * 0.62 + gallop * 0.04, size * 0.015, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + size * 0.12, y - size * 0.62 + gallop * 0.04, size * 0.015, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // === FIERCE GLOWING EYES ===
  // Eye base
  ctx.fillStyle = "#3070b0";
  ctx.beginPath();
  ctx.ellipse(x - size * 0.05, y - size * 0.54 + gallop * 0.04, size * 0.028, size * 0.022, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.05, y - size * 0.54 + gallop * 0.04, size * 0.028, size * 0.022, 0, 0, Math.PI * 2);
  ctx.fill();
  // Eye glow
  ctx.fillStyle = "#60a0d0";
  ctx.shadowColor = "#80c0ff";
  ctx.shadowBlur = 4 * zoom;
  ctx.beginPath();
  ctx.ellipse(x - size * 0.05, y - size * 0.54 + gallop * 0.04, size * 0.02, size * 0.015, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.05, y - size * 0.54 + gallop * 0.04, size * 0.02, size * 0.015, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Eye shine
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(x - size * 0.045, y - size * 0.545 + gallop * 0.04, size * 0.01, 0, Math.PI * 2);
  ctx.arc(x + size * 0.055, y - size * 0.545 + gallop * 0.04, size * 0.01, 0, Math.PI * 2);
  ctx.fill();

  // Determined eyebrows
  ctx.strokeStyle = "#9a7820";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.09, y - size * 0.58 + gallop * 0.04);
  ctx.lineTo(x - size * 0.02, y - size * 0.6 + gallop * 0.04);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + size * 0.09, y - size * 0.58 + gallop * 0.04);
  ctx.lineTo(x + size * 0.02, y - size * 0.6 + gallop * 0.04);
  ctx.stroke();

  // Noble expression
  ctx.strokeStyle = "#b08060";
  ctx.lineWidth = 1.2 * zoom;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.47 + gallop * 0.04, size * 0.035, 0.15, Math.PI - 0.15);
  ctx.stroke();

  // === ORNATE EPIC BOW ===
  ctx.save();
  ctx.translate(x + size * 0.18, y - size * 0.27 + gallop * 0.06);
  ctx.rotate(0.28 + (isAttacking ? bowDraw * 0.18 : 0));

  // Bow flexes during draw
  const bowBend = isAttacking ? 0.58 + bowDraw * 0.18 : 0.58;

  // Bow outer layer (dark wood)
  ctx.strokeStyle = "#4a2a10";
  ctx.lineWidth = 6 * zoom;
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.32, Math.PI - bowBend * Math.PI, Math.PI + bowBend * Math.PI);
  ctx.stroke();

  // Bow main layer (rich wood)
  const bowGrad = ctx.createLinearGradient(-size * 0.32, 0, size * 0.1, 0);
  bowGrad.addColorStop(0, "#5a3a1a");
  bowGrad.addColorStop(0.3, "#7a5a3a");
  bowGrad.addColorStop(0.7, "#6b4a2a");
  bowGrad.addColorStop(1, "#5a3a1a");
  ctx.strokeStyle = bowGrad;
  ctx.lineWidth = 4.5 * zoom;
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.3, Math.PI - bowBend * Math.PI, Math.PI + bowBend * Math.PI);
  ctx.stroke();

  // Ornate gold inlay patterns
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.8 * zoom;
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.3, Math.PI * 0.45, Math.PI * 0.55);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.3, Math.PI * 1.45, Math.PI * 1.55);
  ctx.stroke();

  // Bow tip decorations
  const topTipX = Math.cos(Math.PI - bowBend * Math.PI) * size * 0.32;
  const topTipY = Math.sin(Math.PI - bowBend * Math.PI) * size * 0.32;
  const botTipX = Math.cos(Math.PI + bowBend * Math.PI) * size * 0.32;
  const botTipY = Math.sin(Math.PI + bowBend * Math.PI) * size * 0.32;

  // Gold tip caps
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.arc(topTipX, topTipY, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(botTipX, botTipY, size * 0.025, 0, Math.PI * 2);
  ctx.fill();

  // Center grip decoration
  ctx.fillStyle = "#3a2010";
  ctx.fillRect(-size * 0.28, -size * 0.04, size * 0.08, size * 0.08);
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1;
  ctx.strokeRect(-size * 0.28, -size * 0.04, size * 0.08, size * 0.08);
  // Grip gem
  ctx.fillStyle = "#ff4400";
  ctx.shadowColor = "#ff6600";
  ctx.shadowBlur = 4 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(-size * 0.24, 0, size * 0.018, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Bowstring (magical glow when drawn)
  const stringPull = -size * (0.18 + (isAttacking ? bowDraw * 0.18 : 0));
  if (isAttacking) {
    ctx.shadowColor = "#ffcc00";
    ctx.shadowBlur = 6 * zoom * bowDraw;
  }
  ctx.strokeStyle = isAttacking ? "#fff8dc" : "#f8f8dc";
  ctx.lineWidth = (isAttacking ? 2.5 : 2) * zoom;
  ctx.beginPath();
  ctx.moveTo(topTipX, topTipY);
  ctx.lineTo(stringPull, 0);
  ctx.lineTo(botTipX, botTipY);
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Arrow (nocked and ready)
  if (!isAttacking || attackPhase < 0.5) {
    const arrowOffset = isAttacking ? bowDraw * size * 0.12 : 0;

    // Arrow shaft with gradient
    const shaftGrad = ctx.createLinearGradient(stringPull - size * 0.45, 0, stringPull, 0);
    shaftGrad.addColorStop(0, "#3a2010");
    shaftGrad.addColorStop(0.5, "#5a4020");
    shaftGrad.addColorStop(1, "#3a2010");
    ctx.fillStyle = shaftGrad;
    ctx.fillRect(stringPull + arrowOffset * 0.5 - size * 0.45, -size * 0.018, size * 0.45, size * 0.036);

    // Arrow gold bands
    ctx.fillStyle = "#c9a227";
    ctx.fillRect(stringPull + arrowOffset * 0.5 - size * 0.2, -size * 0.02, size * 0.025, size * 0.04);
    ctx.fillRect(stringPull + arrowOffset * 0.5 - size * 0.35, -size * 0.02, size * 0.025, size * 0.04);

    // Elaborate fletching
    ctx.fillStyle = "#e06000";
    ctx.beginPath();
    ctx.moveTo(stringPull + arrowOffset * 0.3 + size * 0.02, 0);
    ctx.lineTo(stringPull + arrowOffset * 0.5 + size * 0.08, -size * 0.04);
    ctx.lineTo(stringPull + arrowOffset * 0.3 - size * 0.04, 0);
    ctx.lineTo(stringPull + arrowOffset * 0.5 + size * 0.08, size * 0.04);
    ctx.closePath();
    ctx.fill();
    // Fletching highlight
    ctx.fillStyle = "#ff8030";
    ctx.beginPath();
    ctx.moveTo(stringPull + arrowOffset * 0.3 + size * 0.01, 0);
    ctx.lineTo(stringPull + arrowOffset * 0.4 + size * 0.05, -size * 0.025);
    ctx.lineTo(stringPull + arrowOffset * 0.3 - size * 0.02, 0);
    ctx.lineTo(stringPull + arrowOffset * 0.4 + size * 0.05, size * 0.025);
    ctx.closePath();
    ctx.fill();

    // Ornate arrowhead (glows during draw)
    if (isAttacking) {
      ctx.shadowColor = "#ffcc00";
      ctx.shadowBlur = 8 * zoom * bowDraw;
    }
    const headGrad = ctx.createLinearGradient(stringPull - size * 0.5, -size * 0.04, stringPull - size * 0.5, size * 0.04);
    headGrad.addColorStop(0, "#c0c0c0");
    headGrad.addColorStop(0.5, isAttacking ? "#ffffff" : "#e8e8e8");
    headGrad.addColorStop(1, "#a0a0a0");
    ctx.fillStyle = headGrad;
    ctx.beginPath();
    ctx.moveTo(stringPull - size * 0.48, 0);
    ctx.lineTo(stringPull - size * 0.38, -size * 0.04);
    ctx.lineTo(stringPull - size * 0.4, 0);
    ctx.lineTo(stringPull - size * 0.38, size * 0.04);
    ctx.closePath();
    ctx.fill();
    // Arrowhead gold inlay
    ctx.strokeStyle = "#c9a227";
    ctx.lineWidth = 0.8;
    ctx.beginPath();
    ctx.moveTo(stringPull - size * 0.46, 0);
    ctx.lineTo(stringPull - size * 0.4, 0);
    ctx.stroke();
    ctx.shadowBlur = 0;
  }
  ctx.restore();

  // === FLYING ARROW WITH TRAIL ===
  if (isAttacking && attackPhase > 0.4) {
    const flyPhase = (attackPhase - 0.4) / 0.6;
    const arrowX = x + flyPhase * size * 2.8;
    const arrowY = y - size * 0.27 + gallop * 0.06 - flyPhase * size * 0.22;

    ctx.save();
    ctx.translate(arrowX, arrowY);
    ctx.rotate(-0.18);

    // Golden trailing glow
    ctx.shadowColor = "#ffcc00";
    ctx.shadowBlur = 15 * zoom * (1 - flyPhase);

    // Trail particles
    for (let tp = 0; tp < 6; tp++) {
      const trailX = -size * 0.1 - tp * size * 0.08;
      const trailY = Math.sin(time * 20 + tp) * size * 0.02;
      const trailAlpha = (1 - flyPhase) * (1 - tp * 0.15);
      ctx.fillStyle = `rgba(255, 215, 100, ${trailAlpha * 0.6})`;
      ctx.beginPath();
      ctx.arc(trailX, trailY, size * (0.02 - tp * 0.002), 0, Math.PI * 2);
      ctx.fill();
    }

    // Arrow shaft
    ctx.fillStyle = "#5a4020";
    ctx.fillRect(-size * 0.18, -size * 0.015, size * 0.4, size * 0.03);

    // Fletching
    ctx.fillStyle = "#e06000";
    ctx.beginPath();
    ctx.moveTo(-size * 0.15, 0);
    ctx.lineTo(-size * 0.2, -size * 0.035);
    ctx.lineTo(-size * 0.08, 0);
    ctx.lineTo(-size * 0.2, size * 0.035);
    ctx.closePath();
    ctx.fill();

    // Glowing arrowhead
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.moveTo(size * 0.26, 0);
    ctx.lineTo(size * 0.16, -size * 0.035);
    ctx.lineTo(size * 0.18, 0);
    ctx.lineTo(size * 0.16, size * 0.035);
    ctx.closePath();
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.restore();
  }
}

// Elite Guard - Level 3 station troop with ornate royal armor and halberd
function drawEliteTroop(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  const stance = Math.sin(time * 3) * 1.2;
  const breathe = Math.sin(time * 2) * 0.5;
  const capeWave = Math.sin(time * 3.5);
  const capeWave2 = Math.sin(time * 4.2 + 0.5);
  const shimmer = Math.sin(time * 6) * 0.5 + 0.5;
  const gemPulse = Math.sin(time * 2.5) * 0.3 + 0.7;

  // Attack animation - halberd swing
  const isAttacking = attackPhase > 0;
  const halberdSwing = isAttacking
    ? Math.sin(attackPhase * Math.PI * 1.5) * 1.8
    : 0;
  const bodyLean = isAttacking ? Math.sin(attackPhase * Math.PI) * 0.15 : 0;

  // === ELITE AURA (always present, stronger during attack) ===
  const auraIntensity = isAttacking ? 0.6 : 0.3;
  const auraPulse = 0.8 + Math.sin(time * 4) * 0.2;

  // Multiple layered aura rings for depth
  for (let auraLayer = 0; auraLayer < 3; auraLayer++) {
    const layerOffset = auraLayer * 0.15;
    const auraGrad = ctx.createRadialGradient(
      x, y + size * 0.1, size * (0.05 + layerOffset),
      x, y + size * 0.1, size * (0.6 + layerOffset)
    );
    auraGrad.addColorStop(0, `rgba(255, 108, 0, ${auraIntensity * auraPulse * (0.4 - auraLayer * 0.1)})`);
    auraGrad.addColorStop(0.4, `rgba(255, 140, 40, ${auraIntensity * auraPulse * (0.25 - auraLayer * 0.06)})`);
    auraGrad.addColorStop(0.7, `rgba(255, 180, 80, ${auraIntensity * auraPulse * (0.15 - auraLayer * 0.04)})`);
  auraGrad.addColorStop(1, "rgba(255, 108, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
    ctx.ellipse(x, y + size * 0.15, size * (0.7 + layerOffset * 0.3), size * (0.55 + layerOffset * 0.2), 0, 0, Math.PI * 2);
  ctx.fill();
  }

  // Floating rune particles around the elite
  for (let p = 0; p < 6; p++) {
    const pAngle = (time * 0.8 + p * Math.PI / 3) % (Math.PI * 2);
    const pRadius = size * 0.5 + Math.sin(time * 2 + p) * size * 0.1;
    const pX = x + Math.cos(pAngle) * pRadius;
    const pY = y + Math.sin(pAngle) * pRadius * 0.4 + size * 0.1;
    const pAlpha = 0.4 + Math.sin(time * 3 + p * 0.7) * 0.3;
    ctx.fillStyle = `rgba(255, 180, 60, ${pAlpha})`;
    ctx.beginPath();
    ctx.arc(pX, pY, size * 0.02, 0, Math.PI * 2);
    ctx.fill();
  }

  // Energy rings during attack
  if (isAttacking) {
    for (let ring = 0; ring < 3; ring++) {
      const ringPhase = (attackPhase * 2.5 + ring * 0.15) % 1;
      const ringAlpha = (1 - ringPhase) * 0.6;
      ctx.strokeStyle = `rgba(255, 150, 50, ${ringAlpha})`;
      ctx.lineWidth = (3 - ring * 0.5) * zoom;
      ctx.beginPath();
      ctx.ellipse(
        x,
        y + size * 0.1,
        size * (0.35 + ringPhase * 0.4),
        size * (0.22 + ringPhase * 0.25),
        0,
        0,
        Math.PI * 2
      );
      ctx.stroke();
    }
  }

  // === ROYAL CAPE (multi-layered with intricate patterns) ===
  // Cape shadow layer (deepest)
  ctx.fillStyle = "#050515";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.16, y - size * 0.08 + breathe);
  ctx.quadraticCurveTo(
    x - size * 0.3 + capeWave * 5,
    y + size * 0.35,
    x - size * 0.26 + capeWave * 6,
    y + size * 0.68
  );
  ctx.lineTo(x + size * 0.14 + capeWave * 4, y + size * 0.62);
  ctx.quadraticCurveTo(
    x + size * 0.08,
    y + size * 0.25,
    x + size * 0.14,
    y - size * 0.06 + breathe
  );
  ctx.closePath();
  ctx.fill();

  // Cape inner layer (royal purple)
  const capeInnerGrad = ctx.createLinearGradient(
    x - size * 0.2, y - size * 0.1,
    x + size * 0.1, y + size * 0.6
  );
  capeInnerGrad.addColorStop(0, "#1a0a3a");
  capeInnerGrad.addColorStop(0.3, "#0d0520");
  capeInnerGrad.addColorStop(0.7, "#150830");
  capeInnerGrad.addColorStop(1, "#0a0418");
  ctx.fillStyle = capeInnerGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.14, y - size * 0.1 + breathe);
  ctx.quadraticCurveTo(
    x - size * 0.26 + capeWave * 4,
    y + size * 0.3,
    x - size * 0.22 + capeWave * 5,
    y + size * 0.6
  );
  ctx.lineTo(x + size * 0.1 + capeWave * 3, y + size * 0.55);
  ctx.quadraticCurveTo(
    x + size * 0.06,
    y + size * 0.2,
    x + size * 0.12,
    y - size * 0.08 + breathe
  );
  ctx.closePath();
  ctx.fill();

  // Cape middle layer with gradient
  const capeGrad = ctx.createLinearGradient(
    x - size * 0.15, y,
    x + size * 0.1, y + size * 0.5
  );
  capeGrad.addColorStop(0, "#2a1a5a");
  capeGrad.addColorStop(0.4, "#1d1045");
  capeGrad.addColorStop(1, "#120830");
  ctx.fillStyle = capeGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.12, y - size * 0.12 + breathe);
  ctx.quadraticCurveTo(
    x - size * 0.22 + capeWave * 3,
    y + size * 0.2,
    x - size * 0.18 + capeWave * 4,
    y + size * 0.5
  );
  ctx.lineTo(x + size * 0.08 + capeWave * 2, y + size * 0.45);
  ctx.quadraticCurveTo(
    x + size * 0.05,
    y + size * 0.15,
    x + size * 0.1,
    y - size * 0.1 + breathe
  );
  ctx.closePath();
  ctx.fill();

  // Cape embroidered pattern (gold thread design)
  ctx.save();
  ctx.globalAlpha = 0.6;
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 0.8;
  // Decorative swirl patterns on cape
  for (let row = 0; row < 3; row++) {
    const rowY = y + size * (0.15 + row * 0.12);
    const waveOffset = capeWave * (2 + row);
    ctx.beginPath();
    ctx.moveTo(x - size * 0.1 + waveOffset, rowY);
    ctx.quadraticCurveTo(
      x - size * 0.05 + waveOffset, rowY - size * 0.03,
      x + waveOffset, rowY
    );
    ctx.quadraticCurveTo(
      x + size * 0.05 + waveOffset, rowY + size * 0.03,
      x + size * 0.08 + waveOffset, rowY
    );
    ctx.stroke();
  }
  ctx.restore();

  // Cape outer gold trim with decorative pattern
  ctx.strokeStyle = "#dab32f";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.18 + capeWave * 4, y + size * 0.5);
  ctx.lineTo(x + size * 0.08 + capeWave * 2, y + size * 0.45);
  ctx.stroke();

  // Inner trim line
  ctx.strokeStyle = "#a08020";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.17 + capeWave * 4, y + size * 0.48);
  ctx.lineTo(x + size * 0.07 + capeWave * 2, y + size * 0.43);
  ctx.stroke();

  // Cape clasp gem at shoulder
  ctx.fillStyle = "#ff4400";
  ctx.shadowColor = "#ff6600";
  ctx.shadowBlur = 6 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x - size * 0.1, y - size * 0.08 + breathe, size * 0.035, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Gem highlight
  ctx.fillStyle = "rgba(255,255,200,0.7)";
  ctx.beginPath();
  ctx.arc(x - size * 0.11, y - size * 0.09 + breathe, size * 0.012, 0, Math.PI * 2);
  ctx.fill();

  // === LEGS (ornate greaves with engravings) ===
  // Left leg
  ctx.save();
  ctx.translate(x - size * 0.07, y + size * 0.28);
  ctx.rotate(-0.06 + stance * 0.015);
  
  // Greave base with metallic gradient
  const legGradL = ctx.createLinearGradient(-size * 0.06, 0, size * 0.06, 0);
  legGradL.addColorStop(0, "#4a4a5a");
  legGradL.addColorStop(0.3, "#6a6a7a");
  legGradL.addColorStop(0.7, "#7a7a8a");
  legGradL.addColorStop(1, "#5a5a6a");
  ctx.fillStyle = legGradL;
  ctx.fillRect(-size * 0.06, 0, size * 0.12, size * 0.22);
  
  // Leg armor segments
  ctx.strokeStyle = "#3a3a4a";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-size * 0.055, size * 0.06);
  ctx.lineTo(size * 0.055, size * 0.06);
  ctx.moveTo(-size * 0.055, size * 0.12);
  ctx.lineTo(size * 0.055, size * 0.12);
  ctx.stroke();
  
  // Ornate knee guard with layered design
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.08, size * 0.07, size * 0.05, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#dab32f";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.08, size * 0.045, size * 0.03, 0, 0, Math.PI * 2);
  ctx.fill();
  // Knee gem
  ctx.fillStyle = "#ff3300";
  ctx.shadowColor = "#ff4400";
  ctx.shadowBlur = 3 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(0, size * 0.08, size * 0.018, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  
  // Detailed boot with buckles
  ctx.fillStyle = "#2a2a3a";
  ctx.fillRect(-size * 0.065, size * 0.17, size * 0.13, size * 0.09);
  // Boot cuff
  ctx.fillStyle = "#3a3a4a";
  ctx.fillRect(-size * 0.07, size * 0.17, size * 0.14, size * 0.025);
  // Gold buckle
  ctx.fillStyle = "#c9a227";
  ctx.fillRect(-size * 0.025, size * 0.19, size * 0.05, size * 0.02);
  ctx.restore();

  // Right leg
  ctx.save();
  ctx.translate(x + size * 0.07, y + size * 0.28);
  ctx.rotate(0.06 - stance * 0.015);
  
  // Greave base
  const legGradR = ctx.createLinearGradient(-size * 0.06, 0, size * 0.06, 0);
  legGradR.addColorStop(0, "#5a5a6a");
  legGradR.addColorStop(0.3, "#7a7a8a");
  legGradR.addColorStop(0.7, "#6a6a7a");
  legGradR.addColorStop(1, "#4a4a5a");
  ctx.fillStyle = legGradR;
  ctx.fillRect(-size * 0.06, 0, size * 0.12, size * 0.22);
  
  // Leg armor segments
  ctx.strokeStyle = "#3a3a4a";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-size * 0.055, size * 0.06);
  ctx.lineTo(size * 0.055, size * 0.06);
  ctx.moveTo(-size * 0.055, size * 0.12);
  ctx.lineTo(size * 0.055, size * 0.12);
  ctx.stroke();
  
  // Ornate knee guard
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.08, size * 0.07, size * 0.05, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#dab32f";
  ctx.beginPath();
  ctx.ellipse(0, size * 0.08, size * 0.045, size * 0.03, 0, 0, Math.PI * 2);
  ctx.fill();
  // Knee gem
  ctx.fillStyle = "#ff3300";
  ctx.shadowColor = "#ff4400";
  ctx.shadowBlur = 3 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(0, size * 0.08, size * 0.018, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  
  // Boot with buckles
  ctx.fillStyle = "#2a2a3a";
  ctx.fillRect(-size * 0.065, size * 0.17, size * 0.13, size * 0.09);
  ctx.fillStyle = "#3a3a4a";
  ctx.fillRect(-size * 0.07, size * 0.17, size * 0.14, size * 0.025);
  ctx.fillStyle = "#c9a227";
  ctx.fillRect(-size * 0.025, size * 0.19, size * 0.05, size * 0.02);
  ctx.restore();

  // === BODY (highly ornate plate armor with filigree) ===
  // Back plate
  ctx.fillStyle = "#3a3a4a";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.21, y + size * 0.32 + breathe);
  ctx.lineTo(x - size * 0.24, y - size * 0.1 + breathe * 0.5);
  ctx.lineTo(x + size * 0.24, y - size * 0.1 + breathe * 0.5);
  ctx.lineTo(x + size * 0.21, y + size * 0.32 + breathe);
  ctx.closePath();
  ctx.fill();

  // Front chest plate with elaborate metallic gradient
  const plateGrad = ctx.createLinearGradient(
    x - size * 0.2, y - size * 0.1,
    x + size * 0.2, y + size * 0.3
  );
  plateGrad.addColorStop(0, "#5a5a6a");
  plateGrad.addColorStop(0.15, "#7a7a8a");
  plateGrad.addColorStop(0.3, "#9a9aaa");
  plateGrad.addColorStop(0.5, "#8a8a9a");
  plateGrad.addColorStop(0.7, "#9a9aaa");
  plateGrad.addColorStop(0.85, "#7a7a8a");
  plateGrad.addColorStop(1, "#5a5a6a");
  ctx.fillStyle = plateGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.19, y + size * 0.3 + breathe);
  ctx.lineTo(x - size * 0.22, y - size * 0.08 + breathe * 0.5);
  ctx.quadraticCurveTo(
    x,
    y - size * 0.14 + breathe * 0.3,
    x + size * 0.22,
    y - size * 0.08 + breathe * 0.5
  );
  ctx.lineTo(x + size * 0.19, y + size * 0.3 + breathe);
  ctx.closePath();
  ctx.fill();

  // Chest plate edge highlight
  ctx.strokeStyle = "#a0a0b0";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.19, y + size * 0.28 + breathe);
  ctx.lineTo(x - size * 0.21, y - size * 0.06 + breathe * 0.5);
  ctx.quadraticCurveTo(
    x,
    y - size * 0.12 + breathe * 0.3,
    x + size * 0.21,
    y - size * 0.06 + breathe * 0.5
  );
  ctx.stroke();

  // Armor segment lines (muscle cuirass detail)
  ctx.strokeStyle = "#4a4a5a";
  ctx.lineWidth = 1.2;
  // Center line
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.06 + breathe);
  ctx.lineTo(x, y + size * 0.22 + breathe);
  ctx.stroke();
  // Pectoral lines
  ctx.beginPath();
  ctx.moveTo(x - size * 0.15, y + size * 0.02 + breathe);
  ctx.quadraticCurveTo(x - size * 0.08, y + size * 0.08, x - size * 0.02, y + size * 0.04 + breathe);
  ctx.moveTo(x + size * 0.15, y + size * 0.02 + breathe);
  ctx.quadraticCurveTo(x + size * 0.08, y + size * 0.08, x + size * 0.02, y + size * 0.04 + breathe);
  ctx.stroke();
  // Abdominal segments
  ctx.beginPath();
  ctx.moveTo(x - size * 0.12, y + size * 0.12 + breathe);
  ctx.lineTo(x + size * 0.12, y + size * 0.12 + breathe);
  ctx.moveTo(x - size * 0.1, y + size * 0.18 + breathe);
  ctx.lineTo(x + size * 0.1, y + size * 0.18 + breathe);
  ctx.stroke();

  // Gold filigree patterns on armor
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 0.8;
  ctx.globalAlpha = 0.8;
  // Left filigree swirl
  ctx.beginPath();
  ctx.moveTo(x - size * 0.14, y - size * 0.02 + breathe);
  ctx.quadraticCurveTo(x - size * 0.18, y + size * 0.06, x - size * 0.12, y + size * 0.08 + breathe);
  ctx.quadraticCurveTo(x - size * 0.08, y + size * 0.1, x - size * 0.14, y + size * 0.14 + breathe);
  ctx.stroke();
  // Right filigree swirl
  ctx.beginPath();
  ctx.moveTo(x + size * 0.14, y - size * 0.02 + breathe);
  ctx.quadraticCurveTo(x + size * 0.18, y + size * 0.06, x + size * 0.12, y + size * 0.08 + breathe);
  ctx.quadraticCurveTo(x + size * 0.08, y + size * 0.1, x + size * 0.14, y + size * 0.14 + breathe);
  ctx.stroke();
  ctx.globalAlpha = 1;

  // Ornate gold chest emblem (Princeton shield with detail)
  // Shield base
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.04 + breathe);
  ctx.lineTo(x - size * 0.1, y + size * 0.08 + breathe);
  ctx.lineTo(x, y + size * 0.18 + breathe);
  ctx.lineTo(x + size * 0.1, y + size * 0.08 + breathe);
  ctx.closePath();
  ctx.fill();
  // Shield inner detail
  ctx.fillStyle = "#dab32f";
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.01 + breathe);
  ctx.lineTo(x - size * 0.06, y + size * 0.07 + breathe);
  ctx.lineTo(x, y + size * 0.14 + breathe);
  ctx.lineTo(x + size * 0.06, y + size * 0.07 + breathe);
  ctx.closePath();
  ctx.fill();
  // Center gem on shield
  ctx.fillStyle = "#ff4400";
  ctx.shadowColor = "#ff6600";
  ctx.shadowBlur = 5 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x, y + size * 0.07 + breathe, size * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  // Gem sparkle
  ctx.fillStyle = `rgba(255, 255, 200, ${shimmer * 0.8})`;
  ctx.beginPath();
  ctx.arc(x - size * 0.01, y + size * 0.06 + breathe, size * 0.008, 0, Math.PI * 2);
  ctx.fill();

  // Belt with ornate buckle and pouches
  ctx.fillStyle = "#3a2a1a";
  ctx.fillRect(x - size * 0.18, y + size * 0.22 + breathe, size * 0.36, size * 0.045);
  // Belt buckle
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.roundRect(x - size * 0.06, y + size * 0.215 + breathe, size * 0.12, size * 0.055, size * 0.01);
  ctx.fill();
  ctx.fillStyle = "#dab32f";
  ctx.beginPath();
  ctx.roundRect(x - size * 0.04, y + size * 0.225 + breathe, size * 0.08, size * 0.035, size * 0.005);
  ctx.fill();
  // Buckle gem
  ctx.fillStyle = "#ff4400";
  ctx.beginPath();
  ctx.arc(x, y + size * 0.242 + breathe, size * 0.012, 0, Math.PI * 2);
  ctx.fill();
  // Belt pouches
  ctx.fillStyle = "#4a3a2a";
  ctx.fillRect(x - size * 0.16, y + size * 0.24 + breathe, size * 0.05, size * 0.04);
  ctx.fillRect(x + size * 0.11, y + size * 0.24 + breathe, size * 0.05, size * 0.04);

  // === ORNATE HALBERD (polearm weapon with intricate design) ===
  ctx.save();
  const halberdX =
    x + size * 0.27 + (isAttacking ? halberdSwing * size * 0.18 : 0);
  const halberdY =
    y - size * 0.12 - (isAttacking ? Math.abs(halberdSwing) * size * 0.12 : 0);
  ctx.translate(halberdX, halberdY);
  ctx.rotate(0.15 + stance * 0.02 + halberdSwing);

  // Ornate pole with wrapped leather
  const poleGrad = ctx.createLinearGradient(-size * 0.03, -size * 0.5, size * 0.03, -size * 0.5);
  poleGrad.addColorStop(0, "#3a2a1a");
  poleGrad.addColorStop(0.3, "#5a4a3a");
  poleGrad.addColorStop(0.7, "#5a4a3a");
  poleGrad.addColorStop(1, "#3a2a1a");
  ctx.fillStyle = poleGrad;
  ctx.fillRect(-size * 0.025, -size * 0.55, size * 0.05, size * 1.0);
  
  // Leather wrappings on pole
  ctx.strokeStyle = "#2a1a0a";
  ctx.lineWidth = 1.5;
  for (let wrap = 0; wrap < 6; wrap++) {
    const wrapY = -size * 0.1 + wrap * size * 0.12;
    ctx.beginPath();
    ctx.moveTo(-size * 0.025, wrapY);
    ctx.lineTo(size * 0.025, wrapY + size * 0.03);
    ctx.stroke();
  }

  // Gold pole rings
  ctx.fillStyle = "#c9a227";
  ctx.fillRect(-size * 0.03, -size * 0.52, size * 0.06, size * 0.025);
  ctx.fillRect(-size * 0.03, -size * 0.2, size * 0.06, size * 0.02);
  ctx.fillRect(-size * 0.03, size * 0.25, size * 0.06, size * 0.02);

  // Elaborate axe head (glows during attack)
  if (isAttacking) {
    ctx.shadowColor = "#ff4400";
    ctx.shadowBlur = 15 * zoom * Math.abs(halberdSwing);
  }
  
  // Axe blade with gradient
  const bladeGrad = ctx.createLinearGradient(-size * 0.18, -size * 0.4, -size * 0.02, -size * 0.3);
  bladeGrad.addColorStop(0, isAttacking ? "#e0e0f0" : "#b0b0c0");
  bladeGrad.addColorStop(0.5, isAttacking ? "#f0f0ff" : "#d0d0e0");
  bladeGrad.addColorStop(1, isAttacking ? "#c0c0d0" : "#a0a0b0");
  ctx.fillStyle = bladeGrad;
  ctx.beginPath();
  ctx.moveTo(-size * 0.025, -size * 0.52);
  ctx.lineTo(-size * 0.18, -size * 0.38);
  ctx.quadraticCurveTo(-size * 0.2, -size * 0.32, -size * 0.15, -size * 0.26);
  ctx.lineTo(-size * 0.025, -size * 0.32);
  ctx.closePath();
  ctx.fill();

  // Blade edge highlight
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 0.8;
  ctx.globalAlpha = 0.6;
  ctx.beginPath();
  ctx.moveTo(-size * 0.025, -size * 0.52);
  ctx.lineTo(-size * 0.17, -size * 0.38);
  ctx.quadraticCurveTo(-size * 0.19, -size * 0.33, -size * 0.14, -size * 0.27);
  ctx.stroke();
  ctx.globalAlpha = 1;
  
  // Blade engravings
  ctx.strokeStyle = "#7a7a8a";
  ctx.lineWidth = 0.6;
  ctx.beginPath();
  ctx.moveTo(-size * 0.06, -size * 0.42);
  ctx.quadraticCurveTo(-size * 0.1, -size * 0.38, -size * 0.08, -size * 0.32);
  ctx.stroke();

  // Ornate spike tip
  ctx.fillStyle = isAttacking ? "#e0e0f0" : "#c0c0d0";
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.62);
  ctx.lineTo(-size * 0.04, -size * 0.52);
  ctx.lineTo(size * 0.04, -size * 0.52);
  ctx.closePath();
  ctx.fill();

  // Spike decorative collar
  ctx.fillStyle = "#c9a227";
  ctx.beginPath();
  ctx.moveTo(-size * 0.05, -size * 0.52);
  ctx.lineTo(-size * 0.035, -size * 0.54);
  ctx.lineTo(size * 0.035, -size * 0.54);
  ctx.lineTo(size * 0.05, -size * 0.52);
  ctx.closePath();
  ctx.fill();

  // Back spike with curve
  ctx.fillStyle = isAttacking ? "#d0d0e0" : "#b0b0c0";
  ctx.beginPath();
  ctx.moveTo(size * 0.025, -size * 0.44);
  ctx.quadraticCurveTo(size * 0.12, -size * 0.42, size * 0.1, -size * 0.38);
  ctx.quadraticCurveTo(size * 0.08, -size * 0.34, size * 0.025, -size * 0.36);
  ctx.closePath();
  ctx.fill();
  
  ctx.shadowBlur = 0;

  // Swing trail effect with particles
  if (isAttacking && Math.abs(halberdSwing) > 0.4) {
    // Main trail
    ctx.strokeStyle = `rgba(255, 200, 100, ${Math.abs(halberdSwing) * 0.5})`;
    ctx.lineWidth = 4 * zoom;
    ctx.beginPath();
    ctx.arc(
      0,
      -size * 0.42,
      size * 0.25,
      -Math.PI * 0.5,
      -Math.PI * 0.5 + halberdSwing * 0.9
    );
    ctx.stroke();
    
    // Inner trail
    ctx.strokeStyle = `rgba(255, 255, 200, ${Math.abs(halberdSwing) * 0.3})`;
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.arc(
      0,
      -size * 0.42,
      size * 0.22,
      -Math.PI * 0.5,
      -Math.PI * 0.5 + halberdSwing * 0.85
    );
    ctx.stroke();
    
    // Spark particles
    for (let sp = 0; sp < 4; sp++) {
      const spAngle = -Math.PI * 0.5 + halberdSwing * (0.5 + sp * 0.1);
      const spDist = size * (0.2 + sp * 0.02);
      const spX = Math.cos(spAngle) * spDist;
      const spY = -size * 0.42 + Math.sin(spAngle) * spDist;
      ctx.fillStyle = `rgba(255, 220, 150, ${0.8 - sp * 0.15})`;
      ctx.beginPath();
      ctx.arc(spX, spY, size * 0.015, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.restore();

  // === SHOULDERS (elaborate layered pauldrons) ===
  // Left pauldron - multiple layers
  ctx.save();
  ctx.translate(x - size * 0.19, y - size * 0.04 + breathe);
  
  // Pauldron base layer
  const pauldronGradL = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.12);
  pauldronGradL.addColorStop(0, "#8a8a9a");
  pauldronGradL.addColorStop(0.6, "#6a6a7a");
  pauldronGradL.addColorStop(1, "#4a4a5a");
  ctx.fillStyle = pauldronGradL;
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.12, size * 0.08, -0.3, 0, Math.PI * 2);
  ctx.fill();
  
  // Pauldron ridge layers
  ctx.fillStyle = "#7a7a8a";
  ctx.beginPath();
  ctx.ellipse(size * 0.02, size * 0.03, size * 0.09, size * 0.05, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#6a6a7a";
  ctx.beginPath();
  ctx.ellipse(size * 0.04, size * 0.05, size * 0.06, size * 0.035, -0.3, 0, Math.PI * 2);
  ctx.fill();
  
  // Gold trim and rivets
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.12, size * 0.08, -0.3, 0, Math.PI * 2);
  ctx.stroke();
  
  // Decorative rivets
  ctx.fillStyle = "#dab32f";
  for (let rivet = 0; rivet < 4; rivet++) {
    const rivetAngle = -0.3 + rivet * Math.PI * 0.5;
    const rivetX = Math.cos(rivetAngle) * size * 0.09;
    const rivetY = Math.sin(rivetAngle) * size * 0.06;
    ctx.beginPath();
    ctx.arc(rivetX, rivetY, size * 0.012, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Pauldron spike
  ctx.fillStyle = "#5a5a6a";
  ctx.beginPath();
  ctx.moveTo(-size * 0.08, -size * 0.02);
  ctx.lineTo(-size * 0.14, -size * 0.06);
  ctx.lineTo(-size * 0.06, 0);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // Right pauldron
  ctx.save();
  ctx.translate(x + size * 0.19, y - size * 0.04 + breathe);
  
  const pauldronGradR = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.12);
  pauldronGradR.addColorStop(0, "#8a8a9a");
  pauldronGradR.addColorStop(0.6, "#6a6a7a");
  pauldronGradR.addColorStop(1, "#4a4a5a");
  ctx.fillStyle = pauldronGradR;
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.12, size * 0.08, 0.3, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = "#7a7a8a";
  ctx.beginPath();
  ctx.ellipse(-size * 0.02, size * 0.03, size * 0.09, size * 0.05, 0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#6a6a7a";
  ctx.beginPath();
  ctx.ellipse(-size * 0.04, size * 0.05, size * 0.06, size * 0.035, 0.3, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.12, size * 0.08, 0.3, 0, Math.PI * 2);
  ctx.stroke();

  ctx.fillStyle = "#dab32f";
  for (let rivet = 0; rivet < 4; rivet++) {
    const rivetAngle = 0.3 + rivet * Math.PI * 0.5;
    const rivetX = Math.cos(rivetAngle) * size * 0.09;
    const rivetY = Math.sin(rivetAngle) * size * 0.06;
    ctx.beginPath();
    ctx.arc(rivetX, rivetY, size * 0.012, 0, Math.PI * 2);
    ctx.fill();
  }
  
  ctx.fillStyle = "#5a5a6a";
  ctx.beginPath();
  ctx.moveTo(size * 0.08, -size * 0.02);
  ctx.lineTo(size * 0.14, -size * 0.06);
  ctx.lineTo(size * 0.06, 0);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // === HEAD (elaborate plumed helm with face guard) ===
  // Gorget (neck armor)
  const gorgetGrad = ctx.createLinearGradient(x - size * 0.08, y - size * 0.14, x + size * 0.08, y - size * 0.14);
  gorgetGrad.addColorStop(0, "#4a4a5a");
  gorgetGrad.addColorStop(0.5, "#6a6a7a");
  gorgetGrad.addColorStop(1, "#4a4a5a");
  ctx.fillStyle = gorgetGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.08, y - size * 0.08 + breathe);
  ctx.lineTo(x - size * 0.1, y - size * 0.16 + breathe);
  ctx.quadraticCurveTo(x, y - size * 0.18, x + size * 0.1, y - size * 0.16 + breathe);
  ctx.lineTo(x + size * 0.08, y - size * 0.08 + breathe);
  ctx.closePath();
  ctx.fill();
  // Gorget gold trim
  ctx.strokeStyle = "#c9a227";
  ctx.lineWidth = 1;
  ctx.stroke();

  // Helm base with gradient
  const helmGrad = ctx.createRadialGradient(
    x - size * 0.03, y - size * 0.32 + breathe, size * 0.02,
    x, y - size * 0.28 + breathe, size * 0.14
  );
  helmGrad.addColorStop(0, "#9a9aaa");
  helmGrad.addColorStop(0.4, "#7a7a8a");
  helmGrad.addColorStop(1, "#5a5a6a");
  ctx.fillStyle = helmGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.28 + breathe, size * 0.14, 0, Math.PI * 2);
  ctx.fill();

  // Helm ridge/crest base
  ctx.fillStyle = "#6a6a7a";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.02, y - size * 0.42 + breathe);
  ctx.lineTo(x - size * 0.025, y - size * 0.26 + breathe);
  ctx.lineTo(x + size * 0.025, y - size * 0.26 + breathe);
  ctx.lineTo(x + size * 0.02, y - size * 0.42 + breathe);
  ctx.closePath();
  ctx.fill();

  // Visor with slit detail
  ctx.fillStyle = "#1a1a2a";
  ctx.beginPath();
  ctx.ellipse(
    x,
    y - size * 0.26 + breathe,
    size * 0.1,
    size * 0.05,
    0,
    0,
    Math.PI
  );
  ctx.fill();
  // Visor slits
  ctx.fillStyle = "#0a0a15";
  ctx.fillRect(x - size * 0.08, y - size * 0.26 + breathe, size * 0.16, size * 0.01);
  ctx.fillRect(x - size * 0.06, y - size * 0.24 + breathe, size * 0.12, size * 0.008);
  
  // Eye glow behind visor
  ctx.fillStyle = `rgba(255, 100, 0, ${0.4 + shimmer * 0.3})`;
  ctx.beginPath();
  ctx.ellipse(x - size * 0.03, y - size * 0.26 + breathe, size * 0.015, size * 0.008, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size * 0.03, y - size * 0.26 + breathe, size * 0.015, size * 0.008, 0, 0, Math.PI * 2);
  ctx.fill();

  // Ornate gold crown band with gems
  ctx.strokeStyle = "#dab32f";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(
    x,
    y - size * 0.28 + breathe,
    size * 0.14,
    Math.PI * 1.15,
    Math.PI * 1.85
  );
  ctx.stroke();

  // Crown points
  ctx.fillStyle = "#c9a227";
  for (let cp = 0; cp < 3; cp++) {
    const cpAngle = Math.PI * 1.3 + cp * Math.PI * 0.2;
    const cpX = x + Math.cos(cpAngle) * size * 0.14;
    const cpY = y - size * 0.28 + breathe + Math.sin(cpAngle) * size * 0.14;
  ctx.beginPath();
    ctx.moveTo(cpX, cpY);
    ctx.lineTo(cpX + Math.cos(cpAngle) * size * 0.04, cpY + Math.sin(cpAngle) * size * 0.04 - size * 0.02);
    ctx.lineTo(cpX + Math.cos(cpAngle + 0.3) * size * 0.02, cpY + Math.sin(cpAngle + 0.3) * size * 0.02);
    ctx.closePath();
    ctx.fill();
  }
  
  // Crown center gem
  ctx.fillStyle = "#ff3300";
  ctx.shadowColor = "#ff4400";
  ctx.shadowBlur = 4 * zoom * gemPulse;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.42 + breathe, size * 0.022, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Elaborate multi-layered plume
  // Plume shadow/depth layer
  ctx.fillStyle = "#cc4400";
  ctx.beginPath();
  ctx.moveTo(x + size * 0.02, y - size * 0.42 + breathe);
  ctx.quadraticCurveTo(
    x + size * 0.2 + capeWave * 2.5,
    y - size * 0.58,
    x + size * 0.28 + capeWave * 4,
    y - size * 0.4 + breathe
  );
  ctx.quadraticCurveTo(
    x + size * 0.15,
    y - size * 0.35,
    x + size * 0.02,
    y - size * 0.4 + breathe
  );
  ctx.closePath();
  ctx.fill();

  // Main plume with gradient
  const plumeGrad = ctx.createLinearGradient(
    x, y - size * 0.55,
    x + size * 0.25, y - size * 0.35
  );
  plumeGrad.addColorStop(0, "#ff7700");
  plumeGrad.addColorStop(0.3, "#ff5500");
  plumeGrad.addColorStop(0.7, "#ff6600");
  plumeGrad.addColorStop(1, "#dd4400");
  ctx.fillStyle = plumeGrad;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.42 + breathe);
  ctx.quadraticCurveTo(
    x + size * 0.18 + capeWave * 2,
    y - size * 0.56,
    x + size * 0.24 + capeWave * 3.5,
    y - size * 0.38 + breathe
  );
  ctx.quadraticCurveTo(
    x + size * 0.12,
    y - size * 0.34,
    x,
    y - size * 0.4 + breathe
  );
  ctx.closePath();
  ctx.fill();

  // Plume highlight feathers
  ctx.strokeStyle = "#ffaa44";
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.6;
  for (let feather = 0; feather < 4; feather++) {
    const fOffset = feather * 0.15;
    ctx.beginPath();
    ctx.moveTo(x + size * 0.02, y - size * 0.42 + breathe);
    ctx.quadraticCurveTo(
      x + size * (0.1 + fOffset) + capeWave * (1.5 + feather * 0.3),
      y - size * (0.48 + fOffset * 0.3),
      x + size * (0.15 + fOffset) + capeWave * (2 + feather * 0.4),
      y - size * 0.38 + breathe
    );
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Secondary smaller plume
  ctx.fillStyle = "#ff8800";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.02, y - size * 0.4 + breathe);
  ctx.quadraticCurveTo(
    x + size * 0.08 + capeWave2 * 1.5,
    y - size * 0.48,
    x + size * 0.12 + capeWave2 * 2,
    y - size * 0.36 + breathe
  );
  ctx.quadraticCurveTo(
    x + size * 0.04,
    y - size * 0.34,
    x - size * 0.02,
    y - size * 0.38 + breathe
  );
  ctx.closePath();
  ctx.fill();
}

function drawDefaultTroop(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // Default falls back to knight
  drawKnightTroop(ctx, x, y, size, color, time, zoom, attackPhase);
}

function drawKnightTroop(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0
) {
  // DARK CHAMPION - Elite Princeton Knight with Soul-Forged Greatsword
  const stance = Math.sin(time * 3) * 1;
  const breathe = Math.sin(time * 2) * 0.4;
  const capeWave = Math.sin(time * 4);

  // Attack animation - devastating overhead swing
  const isAttacking = attackPhase > 0;
  const swordSwing = isAttacking
    ? Math.sin(attackPhase * Math.PI * 1.2) * 2.2
    : 0;
  const bodyLean = isAttacking ? Math.sin(attackPhase * Math.PI) * 0.25 : 0;
  const attackIntensity = attackPhase; // Linear decay from 1 (attack start) to 0

  // === DARK FLAME AURA (always present) ===
  const auraIntensity = isAttacking ? 0.6 : 0.35;
  const auraPulse = 0.85 + Math.sin(time * 3.5) * 0.15;

  // Fiery aura gradient
  const auraGrad = ctx.createRadialGradient(
    x,
    y + size * 0.1,
    size * 0.1,
    x,
    y + size * 0.1,
    size * 0.8
  );
  auraGrad.addColorStop(
    0,
    `rgba(255, 100, 20, ${auraIntensity * auraPulse * 0.5})`
  );
  auraGrad.addColorStop(
    0.4,
    `rgba(255, 60, 0, ${auraIntensity * auraPulse * 0.3})`
  );
  auraGrad.addColorStop(1, "rgba(200, 40, 0, 0)");
  ctx.fillStyle = auraGrad;
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.15, size * 0.7, size * 0.5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Flame wisps
  for (let w = 0; w < 3; w++) {
    const wPhase = (time * 3 + w * 1.2) % 2;
    const wAlpha = wPhase < 1 ? (1 - wPhase) * 0.4 : 0;
    const wAngle = (w / 3) * Math.PI - Math.PI * 0.5;
    const wX = x + Math.cos(wAngle) * size * 0.4;
    const wY = y + size * 0.2 - wPhase * size * 0.3;
    ctx.fillStyle = `rgba(255, 150, 50, ${wAlpha})`;
    ctx.beginPath();
    ctx.ellipse(wX, wY, 3 * zoom, 5 * zoom, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // === DARK ENERGY RINGS (during attack) ===
  if (isAttacking) {
    for (let ring = 0; ring < 3; ring++) {
      const ringPhase = (attackPhase * 2 + ring * 0.15) % 1;
      const ringAlpha = (1 - ringPhase) * 0.5 * attackIntensity;
      ctx.strokeStyle = `rgba(255, 80, 20, ${ringAlpha})`;
      ctx.lineWidth = (3.5 - ring) * zoom;
      ctx.beginPath();
      ctx.ellipse(
        x,
        y,
        size * (0.55 + ringPhase * 0.35),
        size * (0.65 + ringPhase * 0.35),
        0,
        0,
        Math.PI * 2
      );
      ctx.stroke();
    }
  }

  // === SHADOW ===
  ctx.fillStyle = "rgba(0, 0, 0, 0.45)";
  ctx.beginPath();
  ctx.ellipse(x, y + size * 0.55, size * 0.45, size * 0.14, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(bodyLean);
  ctx.translate(-x, -y);

  // === FLOWING BATTLE CAPE ===
  const capeGrad = ctx.createLinearGradient(
    x - size * 0.3,
    y - size * 0.2,
    x + size * 0.1,
    y + size * 0.5
  );
  capeGrad.addColorStop(0, "#cc3300");
  capeGrad.addColorStop(0.5, "#ff5500");
  capeGrad.addColorStop(1, "#aa2200");
  ctx.fillStyle = capeGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.15, y - size * 0.15 + breathe);
  ctx.quadraticCurveTo(
    x - size * 0.3 + capeWave * 4,
    y + size * 0.2,
    x - size * 0.25 + capeWave * 6,
    y + size * 0.5
  );
  ctx.lineTo(x + size * 0.12 + capeWave * 3, y + size * 0.45);
  ctx.quadraticCurveTo(
    x + size * 0.08 + capeWave * 1.5,
    y + size * 0.12,
    x + size * 0.14,
    y - size * 0.12 + breathe
  );
  ctx.closePath();
  ctx.fill();

  // Cape inner shadow with pattern
  ctx.fillStyle = "#8b2200";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.1, y - size * 0.1 + breathe);
  ctx.quadraticCurveTo(
    x - size * 0.18 + capeWave * 2.5,
    y + size * 0.12,
    x - size * 0.12 + capeWave * 4,
    y + size * 0.38
  );
  ctx.lineTo(x + capeWave * 1.5, y + size * 0.35);
  ctx.quadraticCurveTo(
    x,
    y + size * 0.08,
    x + size * 0.06,
    y - size * 0.08 + breathe
  );
  ctx.closePath();
  ctx.fill();

  // === ARMORED LEGS ===
  // Dark steel greaves
  for (let side = -1; side <= 1; side += 2) {
    ctx.save();
    ctx.translate(x + side * size * 0.08, y + size * 0.32);
    ctx.rotate(side * (-0.08 + stance * 0.02));

    // Upper leg armor
    const legGrad = ctx.createLinearGradient(-size * 0.06, 0, size * 0.06, 0);
    legGrad.addColorStop(0, "#4a4a5a");
    legGrad.addColorStop(0.3, "#7a7a8a");
    legGrad.addColorStop(0.7, "#8a8a9a");
    legGrad.addColorStop(1, "#5a5a6a");
    ctx.fillStyle = legGrad;
    ctx.fillRect(-size * 0.065, 0, size * 0.13, size * 0.24);

    // Knee guard with spike
    ctx.fillStyle = "#9a9aaa";
    ctx.beginPath();
    ctx.ellipse(0, size * 0.1, size * 0.08, size * 0.055, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#6a6a7a";
    ctx.beginPath();
    ctx.moveTo(0, size * 0.06);
    ctx.lineTo(-size * 0.02, size * 0.02);
    ctx.lineTo(size * 0.02, size * 0.02);
    ctx.closePath();
    ctx.fill();

    // Armored boot
    ctx.fillStyle = "#3a3a4a";
    ctx.fillRect(-size * 0.075, size * 0.2, size * 0.15, size * 0.09);
    ctx.fillStyle = "#5a5a6a";
    ctx.fillRect(-size * 0.08, size * 0.27, size * 0.16, size * 0.04);
    ctx.restore();
  }

  // === DARK PLATE ARMOR ===
  // Back plate
  ctx.fillStyle = "#3a3a4a";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.24, y + size * 0.35 + breathe);
  ctx.lineTo(x - size * 0.26, y - size * 0.12 + breathe * 0.5);
  ctx.lineTo(x + size * 0.26, y - size * 0.12 + breathe * 0.5);
  ctx.lineTo(x + size * 0.24, y + size * 0.35 + breathe);
  ctx.closePath();
  ctx.fill();

  // Front chest plate with gradient
  const plateGrad = ctx.createLinearGradient(
    x - size * 0.22,
    y - size * 0.1,
    x + size * 0.22,
    y + size * 0.2
  );
  plateGrad.addColorStop(0, "#5a5a6a");
  plateGrad.addColorStop(0.2, "#8a8a9a");
  plateGrad.addColorStop(0.5, "#aaaabb");
  plateGrad.addColorStop(0.8, "#8a8a9a");
  plateGrad.addColorStop(1, "#5a5a6a");
  ctx.fillStyle = plateGrad;
  ctx.beginPath();
  ctx.moveTo(x - size * 0.22, y + size * 0.34 + breathe);
  ctx.lineTo(x - size * 0.24, y - size * 0.14 + breathe * 0.5);
  ctx.quadraticCurveTo(
    x,
    y - size * 0.24 + breathe * 0.3,
    x + size * 0.24,
    y - size * 0.14 + breathe * 0.5
  );
  ctx.lineTo(x + size * 0.22, y + size * 0.34 + breathe);
  ctx.closePath();
  ctx.fill();

  // Chest plate battle damage/details
  ctx.strokeStyle = "#4a4a5a";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.17 + breathe * 0.4);
  ctx.lineTo(x, y + size * 0.18 + breathe);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(x, y + breathe * 0.7, size * 0.14, 0.25, Math.PI - 0.25);
  ctx.stroke();

  // Dark sigil on chest
  ctx.fillStyle = "#1a1a2a";
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.05 + breathe);
  ctx.lineTo(x - size * 0.08, y + size * 0.08 + breathe);
  ctx.lineTo(x, y + size * 0.18 + breathe);
  ctx.lineTo(x + size * 0.08, y + size * 0.08 + breathe);
  ctx.closePath();
  ctx.fill();
  // Glowing center
  const sigilGlow = 0.4 + Math.sin(time * 3) * 0.2 + attackIntensity * 0.4;
  ctx.fillStyle = `rgba(200, 80, 0, ${sigilGlow})`;
  ctx.beginPath();
  ctx.arc(x, y + size * 0.08 + breathe, size * 0.03, 0, Math.PI * 2);
  ctx.fill();

  // Battle belt
  ctx.fillStyle = "#2a2a3a";
  ctx.fillRect(
    x - size * 0.2,
    y + size * 0.28 + breathe,
    size * 0.4,
    size * 0.07
  );
  // Belt skull buckle
  ctx.fillStyle = "#c0c0d0";
  ctx.beginPath();
  ctx.arc(x, y + size * 0.315 + breathe, size * 0.035, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#1a1a2a";
  ctx.beginPath();
  ctx.arc(
    x - size * 0.012,
    y + size * 0.31 + breathe,
    size * 0.008,
    0,
    Math.PI * 2
  );
  ctx.arc(
    x + size * 0.012,
    y + size * 0.31 + breathe,
    size * 0.008,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // === MASSIVE PAULDRONS ===
  for (let side = -1; side <= 1; side += 2) {
    const pauldronX = x + side * size * 0.28;
    const pauldronY = y - size * 0.08 + breathe * 0.5;

    // Main pauldron
    ctx.fillStyle = "#7a7a8a";
    ctx.beginPath();
    ctx.ellipse(
      pauldronX,
      pauldronY,
      size * 0.12,
      size * 0.09,
      side * 0.3,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Pauldron spike
    ctx.fillStyle = "#5a5a6a";
    ctx.beginPath();
    ctx.moveTo(pauldronX + side * size * 0.08, pauldronY - size * 0.06);
    ctx.lineTo(pauldronX + side * size * 0.18, pauldronY - size * 0.02);
    ctx.lineTo(pauldronX + side * size * 0.1, pauldronY + size * 0.02);
    ctx.closePath();
    ctx.fill();

    // Pauldron trim
    ctx.fillStyle = "#9a9aaa";
    ctx.beginPath();
    ctx.ellipse(
      pauldronX,
      pauldronY + size * 0.02,
      size * 0.1,
      size * 0.04,
      side * 0.3,
      0,
      Math.PI
    );
    ctx.fill();
  }

  // === ARMS ===
  // Left arm
  ctx.fillStyle = "#5a5a6a";
  ctx.save();
  ctx.translate(x - size * 0.3, y + size * 0.02 + breathe * 0.5);
  ctx.rotate(-0.25 - (isAttacking ? bodyLean * 0.6 : 0));
  ctx.fillRect(-size * 0.055, 0, size * 0.11, size * 0.22);
  ctx.fillStyle = "#7a7a8a";
  ctx.fillRect(-size * 0.065, size * 0.17, size * 0.13, size * 0.09);
  ctx.restore();

  // Right arm (sword arm - swings dramatically)
  ctx.save();
  const armSwing = isAttacking ? -1.2 + attackPhase * 2.8 : 0.2 + stance * 0.03;
  ctx.translate(
    x + size * 0.3,
    y +
      size * 0.02 +
      breathe * 0.5 -
      (isAttacking ? size * 0.12 * swordSwing * 0.3 : 0)
  );
  ctx.rotate(armSwing);
  ctx.fillStyle = "#5a5a6a";
  ctx.fillRect(-size * 0.055, 0, size * 0.11, size * 0.22);
  ctx.fillStyle = "#7a7a8a";
  ctx.fillRect(-size * 0.065, size * 0.17, size * 0.13, size * 0.09);
  ctx.restore();

  // === SOUL-FORGED GREATSWORD ===
  ctx.save();
  const swordAngle = isAttacking
    ? -1.4 + attackPhase * 3.2
    : -0.35 + stance * 0.04;
  const swordX = x + size * 0.4 + (isAttacking ? swordSwing * size * 0.22 : 0);
  const swordY =
    y -
    size * 0.08 +
    breathe * 0.5 -
    (isAttacking ? Math.abs(swordSwing) * size * 0.18 : 0);
  ctx.translate(swordX, swordY);
  ctx.rotate(swordAngle);

  // Wrapped handle
  ctx.fillStyle = "#2a1a10";
  ctx.fillRect(-size * 0.028, size * 0.1, size * 0.056, size * 0.2);
  ctx.strokeStyle = "#4a3525";
  ctx.lineWidth = 2 * zoom;
  for (let i = 0; i < 5; i++) {
    ctx.beginPath();
    ctx.moveTo(-size * 0.028, size * 0.12 + i * size * 0.035);
    ctx.lineTo(size * 0.028, size * 0.14 + i * size * 0.035);
    ctx.stroke();
  }

  // Ornate crossguard
  ctx.fillStyle = "#8b0000";
  ctx.fillRect(-size * 0.12, size * 0.07, size * 0.24, size * 0.05);
  ctx.fillStyle = "#aa2020";
  ctx.beginPath();
  ctx.arc(-size * 0.12, size * 0.095, size * 0.03, 0, Math.PI * 2);
  ctx.arc(size * 0.12, size * 0.095, size * 0.03, 0, Math.PI * 2);
  ctx.fill();
  // Crossguard gems
  ctx.fillStyle = `rgba(255, 200, 50, ${0.7 + attackIntensity * 0.3})`;
  ctx.beginPath();
  ctx.arc(-size * 0.12, size * 0.095, size * 0.015, 0, Math.PI * 2);
  ctx.arc(size * 0.12, size * 0.095, size * 0.015, 0, Math.PI * 2);
  ctx.fill();

  // Massive blade with dark runes
  if (isAttacking) {
    ctx.shadowColor = "#ff6600";
    ctx.shadowBlur = (15 + attackIntensity * 10) * zoom;
  }
  const bladeGrad = ctx.createLinearGradient(-size * 0.05, 0, size * 0.05, 0);
  bladeGrad.addColorStop(0, "#808090");
  bladeGrad.addColorStop(0.15, "#c0c0d0");
  bladeGrad.addColorStop(0.5, "#e8e8f0");
  bladeGrad.addColorStop(0.85, "#c0c0d0");
  bladeGrad.addColorStop(1, "#707080");
  ctx.fillStyle = bladeGrad;
  ctx.beginPath();
  ctx.moveTo(-size * 0.05, size * 0.07);
  ctx.lineTo(-size * 0.055, -size * 0.55);
  ctx.lineTo(0, -size * 0.65);
  ctx.lineTo(size * 0.055, -size * 0.55);
  ctx.lineTo(size * 0.05, size * 0.07);
  ctx.closePath();
  ctx.fill();
  ctx.shadowBlur = 0;

  // Blade runes (glow during attack)
  const runeGlow = 0.3 + Math.sin(time * 4) * 0.15 + attackIntensity * 0.5;
  ctx.fillStyle = `rgba(200, 80, 0, ${runeGlow})`;
  for (let i = 0; i < 4; i++) {
    const runeY = -size * 0.1 - i * size * 0.12;
    ctx.fillRect(-size * 0.015, runeY, size * 0.03, size * 0.06);
  }

  // Blade edge highlight
  ctx.strokeStyle = "rgba(255,255,255,0.7)";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(0, size * 0.05);
  ctx.lineTo(0, -size * 0.62);
  ctx.stroke();

  // Devastating swing trail
  if (isAttacking && attackPhase > 0.15 && attackPhase < 0.85) {
    const trailAlpha = Math.sin(((attackPhase - 0.15) / 0.7) * Math.PI) * 0.7;
    ctx.strokeStyle = `rgba(255, 150, 50, ${trailAlpha})`;
    ctx.lineWidth = 5 * zoom;
    ctx.beginPath();
    ctx.moveTo(0, -size * 0.65);
    ctx.quadraticCurveTo(size * 0.3, -size * 0.45, size * 0.25, -size * 0.1);
    ctx.stroke();

    // Secondary trail
    ctx.strokeStyle = `rgba(255, 200, 100, ${trailAlpha * 0.5})`;
    ctx.lineWidth = 3 * zoom;
    ctx.beginPath();
    ctx.moveTo(0, -size * 0.65);
    ctx.quadraticCurveTo(size * 0.35, -size * 0.5, size * 0.3, -size * 0.15);
    ctx.stroke();
  }

  ctx.restore();

  // === SHIELD (on back) ===
  ctx.save();
  ctx.translate(x - size * 0.35, y + size * 0.05 + breathe);
  ctx.rotate(-0.45);
  ctx.fillStyle = "#1a1a2a";
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.2);
  ctx.lineTo(-size * 0.1, -size * 0.12);
  ctx.lineTo(-size * 0.08, size * 0.14);
  ctx.lineTo(0, size * 0.18);
  ctx.lineTo(size * 0.08, size * 0.14);
  ctx.lineTo(size * 0.1, -size * 0.12);
  ctx.closePath();
  ctx.fill();
  // Shield emblem
  ctx.fillStyle = "#cc4400";
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.14);
  ctx.lineTo(-size * 0.06, -size * 0.06);
  ctx.lineTo(-size * 0.04, size * 0.1);
  ctx.lineTo(0, size * 0.12);
  ctx.lineTo(size * 0.04, size * 0.1);
  ctx.lineTo(size * 0.06, -size * 0.06);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // === GREAT HELM ===
  // Neck guard
  ctx.fillStyle = "#5a5a6a";
  ctx.fillRect(
    x - size * 0.09,
    y - size * 0.24 + breathe * 0.3,
    size * 0.18,
    size * 0.14
  );

  // Great helm base
  const helmGrad = ctx.createRadialGradient(
    x - size * 0.05,
    y - size * 0.42,
    0,
    x,
    y - size * 0.38,
    size * 0.2
  );
  helmGrad.addColorStop(0, "#9a9aaa");
  helmGrad.addColorStop(0.5, "#7a7a8a");
  helmGrad.addColorStop(1, "#5a5a6a");
  ctx.fillStyle = helmGrad;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.4 + breathe * 0.2, size * 0.18, 0, Math.PI * 2);
  ctx.fill();

  // Face plate
  ctx.fillStyle = "#5a5a6a";
  ctx.beginPath();
  ctx.moveTo(x - size * 0.14, y - size * 0.44 + breathe * 0.2);
  ctx.lineTo(x - size * 0.16, y - size * 0.32 + breathe * 0.2);
  ctx.lineTo(x, y - size * 0.26 + breathe * 0.2);
  ctx.lineTo(x + size * 0.16, y - size * 0.32 + breathe * 0.2);
  ctx.lineTo(x + size * 0.14, y - size * 0.44 + breathe * 0.2);
  ctx.closePath();
  ctx.fill();

  // Visor with breathing holes
  ctx.fillStyle = "#1a1a2a";
  ctx.fillRect(
    x - size * 0.12,
    y - size * 0.42 + breathe * 0.2,
    size * 0.24,
    size * 0.05
  );
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.arc(
      x - size * 0.06 + i * size * 0.06,
      y - size * 0.35 + breathe * 0.2,
      size * 0.015,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  // Glowing eyes
  const eyeGlow = 0.6 + Math.sin(time * 3) * 0.3 + attackIntensity * 0.4;
  ctx.fillStyle = `rgba(255, 150, 50, ${eyeGlow})`;
  ctx.shadowColor = "#ff6600";
  ctx.shadowBlur = 6 * zoom;
  ctx.beginPath();
  ctx.arc(
    x - size * 0.05,
    y - size * 0.4 + breathe * 0.2,
    size * 0.018,
    0,
    Math.PI * 2
  );
  ctx.arc(
    x + size * 0.05,
    y - size * 0.4 + breathe * 0.2,
    size * 0.018,
    0,
    Math.PI * 2
  );
  ctx.fill();
  ctx.shadowBlur = 0;

  // Dramatic plume
  ctx.fillStyle = "#dd4400";
  ctx.beginPath();
  ctx.moveTo(x, y - size * 0.56 + breathe * 0.2);
  const crestWave =
    Math.sin(time * 5) * 1.5 + (isAttacking ? swordSwing * 1.2 : 0);
  for (let i = 0; i < 7; i++) {
    const t = i / 6;
    const cx = x + (t - 0.5) * size * 0.25 + crestWave * 2.5 * (1 - t);
    const cy =
      y -
      size * 0.56 -
      t * size * 0.28 -
      Math.sin(t * Math.PI) * size * 0.1 +
      breathe * 0.2;
    ctx.lineTo(cx, cy);
  }
  for (let i = 6; i >= 0; i--) {
    const t = i / 6;
    const cx = x + (t - 0.5) * size * 0.25 + crestWave * 2.5 * (1 - t);
    const cy =
      y -
      size * 0.56 -
      t * size * 0.24 -
      Math.sin(t * Math.PI) * size * 0.06 +
      breathe * 0.2;
    ctx.lineTo(cx, cy);
  }
  ctx.closePath();
  ctx.fill();

  // Battle cry shockwave during attack
  if (isAttacking && attackPhase > 0.25 && attackPhase < 0.65) {
    const cryAlpha = Math.sin(((attackPhase - 0.25) / 0.4) * Math.PI) * 0.5;
    ctx.strokeStyle = `rgba(255, 100, 50, ${cryAlpha})`;
    ctx.lineWidth = 2.5 * zoom;
    for (let r = 1; r <= 3; r++) {
      ctx.beginPath();
      ctx.arc(x, y - size * 0.38, size * (0.2 + r * 0.12), -0.9, 0.9);
      ctx.stroke();
    }
  }

  ctx.restore();
}
// ============================================================================
// TURRET TROOP - Engineer's Deployable Spider Turret (Enhanced)
// ============================================================================
function drawTurretTroop(
  ctx: CanvasRenderingContext2D,
  x: number,
  y2: number,
  size: number,
  color: string,
  time: number,
  zoom: number,
  attackPhase: number = 0,
  targetPos?: Position
) {
  // ENGINEER'S SPIDER TURRET - Mechanical quad-leg sentry platform
  const y = y2 + 12;

  // Scale up the turret
  const scale = 1.4;
  const s = size * scale;

  // Calculate rotation toward target
  let rotation = 0;
  if (targetPos) {
    rotation = Math.atan2(targetPos.y - y, targetPos.x - x);
  } else {
    // Idle scanning when no target
    rotation = Math.sin(time * 1.2) * 3.14;
  }

  const cosR = Math.cos(rotation);
  const sinR = Math.sin(rotation);
  const foreshorten = Math.abs(cosR);

  // Attack timing calculations
  const isAttacking = attackPhase > 0;
  let recoilOffset = 0;
  let turretShake = 0;
  let heatGlow = 0;
  let shieldPulse = 0;

  if (isAttacking) {
    const firePhase = 1 - attackPhase;
    if (firePhase < 0.12) {
      recoilOffset = (firePhase / 0.12) * 5 * zoom;
      turretShake = Math.sin(firePhase * Math.PI * 30) * 2 * zoom;
    } else if (firePhase < 0.45) {
      const returnPhase = (firePhase - 0.12) / 0.33;
      recoilOffset =
        5 * zoom * (1 - returnPhase) * Math.cos(returnPhase * Math.PI * 2);
      turretShake =
        Math.sin(returnPhase * Math.PI * 10) * (1 - returnPhase) * 1.2 * zoom;
    }
    heatGlow = Math.max(0, 1 - firePhase * 1.8);
    shieldPulse = Math.sin(firePhase * Math.PI * 4) * 0.3;
  }

  // Pitch calculation for aiming down
  const towerElevation = s * 0.35;
  const barrelBaseLength = s * 0.45;
  const pitch = Math.atan2(towerElevation, barrelBaseLength * 2.2);
  const pitchCos = Math.cos(pitch);
  const pitchSin = Math.sin(pitch);

  // Apply shake
  const shakeX = turretShake * cosR;
  const shakeY = turretShake * sinR * 0.5;

  // Leg animation
  const legCycle = time * 3;
  const legTwitch = isAttacking ? Math.sin(time * 25) * 2 : 0;

  ctx.save();

  // ========== MECHANICAL SPIDER LEGS ==========
  // Draw 4 legs - 2 front, 2 back
  const legConfigs = [
    { angle: Math.PI * 0.25, side: 1, phase: 0 }, // Front right
    { angle: Math.PI * 0.75, side: 1, phase: 0.5 }, // Back right
    { angle: -Math.PI * 0.25, side: -1, phase: 0.25 }, // Front left
    { angle: -Math.PI * 0.75, side: -1, phase: 0.75 }, // Back left
  ];

  // Draw back legs first (depth sorting)
  legConfigs
    .filter((l) => Math.sin(l.angle + rotation) < 0)
    .forEach((leg) => {
      drawSpiderLeg(
        ctx,
        x,
        y,
        s,
        leg.angle + rotation * 0.3,
        leg.side,
        legCycle + leg.phase,
        legTwitch,
        zoom
      );
    });

  // ========== CENTRAL BODY/CHASSIS ==========
  const bodyY = y - s * 0.08;

  // Lower chassis - armored underbody
  const chassisGrad = ctx.createLinearGradient(
    x - s * 0.4,
    bodyY + s * 0.15,
    x + s * 0.4,
    bodyY - s * 0.2
  );
  chassisGrad.addColorStop(0, "#252530");
  chassisGrad.addColorStop(0.3, "#3a3a48");
  chassisGrad.addColorStop(0.6, "#32323f");
  chassisGrad.addColorStop(1, "#1a1a24");
  ctx.fillStyle = chassisGrad;

  // Isometric hexagonal chassis
  ctx.beginPath();
  ctx.moveTo(x, bodyY + s * 0.28);
  ctx.lineTo(x - s * 0.38, bodyY + s * 0.12);
  ctx.lineTo(x - s * 0.42, bodyY - s * 0.08);
  ctx.lineTo(x - s * 0.3, bodyY - s * 0.22);
  ctx.lineTo(x + s * 0.3, bodyY - s * 0.22);
  ctx.lineTo(x + s * 0.42, bodyY - s * 0.08);
  ctx.lineTo(x + s * 0.38, bodyY + s * 0.12);
  ctx.closePath();
  ctx.fill();

  // Chassis edge highlights
  ctx.strokeStyle = "#4a4a58";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.moveTo(x - s * 0.3, bodyY - s * 0.22);
  ctx.lineTo(x + s * 0.3, bodyY - s * 0.22);
  ctx.lineTo(x + s * 0.42, bodyY - s * 0.08);
  ctx.stroke();

  // ========== ENERGY SHIELD PROJECTOR ==========
  const shieldActive = true; // Could be tied to HP or ability
  const shieldAlpha = 0.25 + Math.sin(time * 3) * 0.1 + shieldPulse;

  if (shieldActive) {
    // Shield dome effect
    const shieldGrad = ctx.createRadialGradient(
      x,
      bodyY - s * 0.1,
      0,
      x,
      bodyY - s * 0.1,
      s * 0.55
    );
    shieldGrad.addColorStop(0, `rgba(100, 200, 255, 0)`);
    shieldGrad.addColorStop(0.6, `rgba(80, 180, 255, ${shieldAlpha * 0.3})`);
    shieldGrad.addColorStop(0.85, `rgba(60, 160, 255, ${shieldAlpha * 0.5})`);
    shieldGrad.addColorStop(0.95, `rgba(100, 200, 255, ${shieldAlpha * 0.8})`);
    shieldGrad.addColorStop(1, `rgba(150, 220, 255, ${shieldAlpha * 0.2})`);

    ctx.fillStyle = shieldGrad;
    ctx.beginPath();
    ctx.ellipse(x, bodyY - s * 0.05, s * 0.52, s * 0.35, 0, 0, Math.PI * 2);
    ctx.fill();

    // Shield hex pattern
    ctx.strokeStyle = `rgba(100, 200, 255, ${shieldAlpha * 0.6})`;
    ctx.lineWidth = 1 * zoom;
    for (let i = 0; i < 6; i++) {
      const hexAngle = (i / 6) * Math.PI * 2 + time * 0.5;
      const hexR = s * 0.4;
      ctx.beginPath();
      ctx.moveTo(
        x + Math.cos(hexAngle) * hexR,
        bodyY - s * 0.05 + Math.sin(hexAngle) * hexR * 0.6
      );
      ctx.lineTo(
        x + Math.cos(hexAngle + Math.PI / 6) * hexR * 0.7,
        bodyY - s * 0.05 + Math.sin(hexAngle + Math.PI / 6) * hexR * 0.42
      );
      ctx.stroke();
    }

    // Shield edge glow
    ctx.strokeStyle = `rgba(100, 200, 255, ${shieldAlpha * 0.4})`;
    ctx.lineWidth = 2 * zoom;
    ctx.beginPath();
    ctx.ellipse(
      x,
      bodyY - s * 0.05,
      s * 0.5,
      s * 0.33,
      0,
      Math.PI * 0.1,
      Math.PI * 0.9
    );
    ctx.stroke();
  }

  // ========== ROTATION RING ==========
  ctx.fillStyle = "#2a2a35";
  ctx.beginPath();
  ctx.ellipse(x, bodyY - s * 0.1, s * 0.32, s * 0.1, 0, 0, Math.PI * 2);
  ctx.fill();

  // Gear teeth on rotation ring
  ctx.fillStyle = "#4a4a58";
  for (let i = 0; i < 16; i++) {
    const toothAngle = rotation + (i / 16) * Math.PI * 2;
    const toothX = x + Math.cos(toothAngle) * s * 0.3;
    const toothY = bodyY - s * 0.1 + Math.sin(toothAngle) * s * 0.09;
    ctx.beginPath();
    ctx.arc(toothX, toothY, s * 0.022, 0, Math.PI * 2);
    ctx.fill();
  }

  // Inner rotation platform
  ctx.fillStyle = "#3a3a48";
  ctx.beginPath();
  ctx.ellipse(x, bodyY - s * 0.12, s * 0.26, s * 0.08, 0, 0, Math.PI * 2);
  ctx.fill();

  // ========== TURRET HOUSING ==========
  const turretX = x + shakeX;
  const turretY = bodyY - s * 0.15 + shakeY;
  const facingAway = sinR < -0.25;

  // Draw barrels behind if facing away
  if (facingAway) {
    drawTurretGunAssembly(
      ctx,
      turretX,
      turretY,
      rotation,
      foreshorten,
      pitch,
      pitchCos,
      pitchSin,
      s,
      zoom,
      time,
      recoilOffset,
      isAttacking,
      heatGlow
    );
  }

  // Main turret dome
  const domeGrad = ctx.createRadialGradient(
    turretX - s * 0.06,
    turretY - s * 0.15,
    0,
    turretX,
    turretY - s * 0.08,
    s * 0.25
  );
  domeGrad.addColorStop(0, "#7a7a88");
  domeGrad.addColorStop(0.3, "#5a5a68");
  domeGrad.addColorStop(0.7, "#4a4a58");
  domeGrad.addColorStop(1, "#3a3a48");
  ctx.fillStyle = domeGrad;

  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - s * 0.06,
    s * 0.22,
    s * 0.14,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Turret top cap
  const capGrad = ctx.createRadialGradient(
    turretX - s * 0.03,
    turretY - s * 0.2,
    0,
    turretX,
    turretY - s * 0.16,
    s * 0.12
  );
  capGrad.addColorStop(0, "#8a8a98");
  capGrad.addColorStop(0.5, "#6a6a78");
  capGrad.addColorStop(1, "#5a5a68");
  ctx.fillStyle = capGrad;

  ctx.beginPath();
  ctx.ellipse(
    turretX,
    turretY - s * 0.16,
    s * 0.14,
    s * 0.07,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // ========== ROTATING ARMOR SEGMENTS ==========
  for (let i = 0; i < 8; i++) {
    const plateAngle = rotation + (i / 8) * Math.PI * 2;
    const plateVisible = Math.cos(plateAngle - rotation);

    if (plateVisible > -0.35) {
      const shade = 0.4 + plateVisible * 0.4;
      const innerR = s * 0.1;
      const outerR = s * 0.2;

      const plateX1 = turretX + Math.cos(plateAngle) * innerR;
      const plateY1 = turretY - s * 0.06 + Math.sin(plateAngle) * innerR * 0.55;
      const plateX2 = turretX + Math.cos(plateAngle) * outerR;
      const plateY2 = turretY - s * 0.06 + Math.sin(plateAngle) * outerR * 0.55;

      ctx.strokeStyle = `rgba(110, 110, 125, ${shade})`;
      ctx.lineWidth = 2.5 * zoom;
      ctx.beginPath();
      ctx.moveTo(plateX1, plateY1);
      ctx.lineTo(plateX2, plateY2);
      ctx.stroke();

      // Plate rivets
      ctx.fillStyle = `rgba(85, 85, 100, ${shade})`;
      ctx.beginPath();
      ctx.arc(plateX2, plateY2, s * 0.018, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // ========== CENTRAL PIVOT & CORE ==========
  ctx.fillStyle = "#2a2a35";
  ctx.beginPath();
  ctx.arc(turretX, turretY - s * 0.06, s * 0.1, 0, Math.PI * 2);
  ctx.fill();

  // Inner ring
  ctx.strokeStyle = "#5a5a68";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.arc(turretX, turretY - s * 0.06, s * 0.07, 0, Math.PI * 2);
  ctx.stroke();

  // Power core glow
  const coreGlow = 0.65 + Math.sin(time * 5) * 0.25 + heatGlow * 0.4;
  const coreGrad = ctx.createRadialGradient(
    turretX,
    turretY - s * 0.06,
    0,
    turretX,
    turretY - s * 0.06,
    s * 0.06
  );
  coreGrad.addColorStop(0, `rgba(255, 180, 80, ${coreGlow})`);
  coreGrad.addColorStop(0.35, `rgba(255, 120, 30, ${coreGlow * 0.75})`);
  coreGrad.addColorStop(0.7, `rgba(255, 80, 0, ${coreGlow * 0.4})`);
  coreGrad.addColorStop(1, `rgba(255, 50, 0, 0)`);
  ctx.fillStyle = coreGrad;
  ctx.beginPath();
  ctx.arc(turretX, turretY - s * 0.06, s * 0.055, 0, Math.PI * 2);
  ctx.fill();

  // ========== SENSOR ARRAY ==========
  // Main sensor
  const sensorGlow = 0.6 + Math.sin(time * 4) * 0.3;
  ctx.fillStyle = "#3a3a48";
  ctx.beginPath();
  ctx.arc(turretX, turretY - s * 0.2, s * 0.055, 0, Math.PI * 2);
  ctx.fill();

  // Sensor eye - changes color when targeting
  const sensorColor = targetPos
    ? `rgba(255, 100, 100, ${sensorGlow})`
    : `rgba(0, 200, 255, ${sensorGlow})`;
  ctx.fillStyle = sensorColor;
  ctx.shadowColor = targetPos ? "#ff6464" : "#00ccff";
  ctx.shadowBlur = 8 * zoom;
  ctx.beginPath();
  ctx.arc(turretX, turretY - s * 0.2, s * 0.035, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Targeting sweep when active
  if (targetPos) {
    ctx.strokeStyle = `rgba(255, 100, 100, ${sensorGlow * 0.5})`;
    ctx.lineWidth = 1.5 * zoom;
    const sweepAngle = time * 8;
    ctx.beginPath();
    ctx.arc(
      turretX,
      turretY - s * 0.2,
      s * 0.045,
      sweepAngle,
      sweepAngle + 0.8
    );
    ctx.stroke();
  }

  // Side sensors
  for (let side = -1; side <= 1; side += 2) {
    const sideX = turretX + side * s * 0.16;
    const sideY = turretY - s * 0.14;

    ctx.fillStyle = "#3a3a48";
    ctx.beginPath();
    ctx.arc(sideX, sideY, s * 0.03, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = `rgba(100, 255, 150, ${
      0.5 + Math.sin(time * 5 + side) * 0.3
    })`;
    ctx.beginPath();
    ctx.arc(sideX, sideY, s * 0.018, 0, Math.PI * 2);
    ctx.fill();
  }

  // ========== DRAW BARRELS (if not facing away) ==========
  if (!facingAway) {
    drawTurretGunAssembly(
      ctx,
      turretX,
      turretY,
      rotation,
      foreshorten,
      pitch,
      pitchCos,
      pitchSin,
      s,
      zoom,
      time,
      recoilOffset,
      isAttacking,
      heatGlow
    );
  }

  // ========== DRAW FRONT LEGS ==========
  legConfigs
    .filter((l) => Math.sin(l.angle + rotation) >= 0)
    .forEach((leg) => {
      drawSpiderLeg(
        ctx,
        x,
        y,
        s,
        leg.angle + rotation * 0.3,
        leg.side,
        legCycle + leg.phase,
        legTwitch,
        zoom
      );
    });

  // ========== AMMUNITION HOPPERS ==========
  // Left hopper
  const hopperGrad = ctx.createLinearGradient(
    x - s * 0.38,
    bodyY,
    x - s * 0.22,
    bodyY + s * 0.15
  );
  hopperGrad.addColorStop(0, "#c65d0a");
  hopperGrad.addColorStop(0.5, "#f97316");
  hopperGrad.addColorStop(1, "#a54d08");
  ctx.fillStyle = hopperGrad;

  ctx.beginPath();
  ctx.moveTo(x - s * 0.35, bodyY + s * 0.1);
  ctx.lineTo(x - s * 0.35, bodyY - s * 0.04);
  ctx.lineTo(x - s * 0.28, bodyY - s * 0.1);
  ctx.lineTo(x - s * 0.2, bodyY - s * 0.1);
  ctx.lineTo(x - s * 0.2, bodyY + s * 0.06);
  ctx.lineTo(x - s * 0.28, bodyY + s * 0.1);
  ctx.closePath();
  ctx.fill();

  // Hopper top highlight
  ctx.fillStyle = "#f97316";
  ctx.beginPath();
  ctx.moveTo(x - s * 0.35, bodyY - s * 0.04);
  ctx.lineTo(x - s * 0.28, bodyY - s * 0.1);
  ctx.lineTo(x - s * 0.2, bodyY - s * 0.1);
  ctx.lineTo(x - s * 0.27, bodyY - s * 0.04);
  ctx.closePath();
  ctx.fill();

  // Ammo belt
  ctx.fillStyle = "#d97706";
  for (let i = 0; i < 5; i++) {
    const beltY = bodyY - s * 0.06 + i * s * 0.03;
    ctx.beginPath();
    ctx.ellipse(x - s * 0.27, beltY, s * 0.022, s * 0.01, 0.25, 0, Math.PI * 2);
    ctx.fill();
  }

  // Right hopper (mirrored)
  ctx.fillStyle = hopperGrad;
  ctx.beginPath();
  ctx.moveTo(x + s * 0.35, bodyY + s * 0.1);
  ctx.lineTo(x + s * 0.35, bodyY - s * 0.04);
  ctx.lineTo(x + s * 0.28, bodyY - s * 0.1);
  ctx.lineTo(x + s * 0.2, bodyY - s * 0.1);
  ctx.lineTo(x + s * 0.2, bodyY + s * 0.06);
  ctx.lineTo(x + s * 0.28, bodyY + s * 0.1);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = "#f97316";
  ctx.beginPath();
  ctx.moveTo(x + s * 0.35, bodyY - s * 0.04);
  ctx.lineTo(x + s * 0.28, bodyY - s * 0.1);
  ctx.lineTo(x + s * 0.2, bodyY - s * 0.1);
  ctx.lineTo(x + s * 0.27, bodyY - s * 0.04);
  ctx.closePath();
  ctx.fill();

  for (let i = 0; i < 5; i++) {
    const beltY = bodyY - s * 0.06 + i * s * 0.03;
    ctx.fillStyle = "#d97706";
    ctx.beginPath();
    ctx.ellipse(
      x + s * 0.27,
      beltY,
      s * 0.022,
      s * 0.01,
      -0.25,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  // ========== STATUS PANEL ==========
  // Main status light
  const statusGlow = 0.7 + Math.sin(time * 3) * 0.3;
  ctx.fillStyle = isAttacking
    ? `rgba(255, 100, 50, ${statusGlow + 0.3})`
    : `rgba(50, 255, 100, ${statusGlow})`;
  ctx.shadowColor = isAttacking ? "#ff6432" : "#32ff64";
  ctx.shadowBlur = 6 * zoom;
  ctx.beginPath();
  ctx.arc(x, bodyY + s * 0.15, s * 0.022, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Shield status indicator
  if (shieldActive) {
    ctx.fillStyle = `rgba(100, 200, 255, ${0.6 + Math.sin(time * 4) * 0.2})`;
    ctx.beginPath();
    ctx.arc(x - s * 0.08, bodyY + s * 0.15, s * 0.015, 0, Math.PI * 2);
    ctx.fill();
    ctx.arc(x + s * 0.08, bodyY + s * 0.15, s * 0.015, 0, Math.PI * 2);
    ctx.fill();
  }

  // ========== ENGINEER EMBLEM ==========
  ctx.strokeStyle = "#fbbf24";
  ctx.lineWidth = 1.5 * zoom;
  ctx.beginPath();
  ctx.arc(x, bodyY + s * 0.24, s * 0.04, 0, Math.PI * 2);
  ctx.stroke();

  // Rotating gear teeth
  for (let i = 0; i < 8; i++) {
    const gearAngle = (i / 8) * Math.PI * 2 + time * 0.8;
    ctx.beginPath();
    ctx.moveTo(
      x + Math.cos(gearAngle) * s * 0.04,
      bodyY + s * 0.24 + Math.sin(gearAngle) * s * 0.04
    );
    ctx.lineTo(
      x + Math.cos(gearAngle) * s * 0.058,
      bodyY + s * 0.24 + Math.sin(gearAngle) * s * 0.058
    );
    ctx.stroke();
  }

  // ========== TARGETING LASER ==========
  if (targetPos && isAttacking) {
    const laserIntensity = 0.7 + Math.sin(time * 25) * 0.2;

    // Calculate where laser should point
    const laserStartX = turretX;
    const laserStartY = turretY - s * 0.1;
    const laserLength = s * 0.7;
    const laserEndX = laserStartX + cosR * laserLength * pitchCos;
    const laserEndY =
      laserStartY + sinR * laserLength * 0.5 + laserLength * pitchSin * 0.4;

    // Laser beam
    ctx.strokeStyle = `rgba(255, 50, 50, ${laserIntensity * 0.6})`;
    ctx.lineWidth = 1.5 * zoom;
    ctx.setLineDash([3 * zoom, 2 * zoom]);
    ctx.beginPath();
    ctx.moveTo(laserStartX, laserStartY);
    ctx.lineTo(laserEndX, laserEndY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Laser impact point
    ctx.fillStyle = `rgba(255, 50, 50, ${laserIntensity})`;
    ctx.shadowColor = "#ff3232";
    ctx.shadowBlur = 5 * zoom;
    ctx.beginPath();
    ctx.arc(laserEndX, laserEndY, s * 0.015, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  ctx.restore();
}

// Helper function for spider legs
function drawSpiderLeg(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  s: number,
  angle: number,
  side: number,
  phase: number,
  twitch: number,
  zoom: number
) {
  const legBase = { x: x, y: y + s * 0.05 };

  // Calculate leg segments
  const upperLength = s * 0.25;
  const lowerLength = s * 0.3;

  // Add subtle idle movement
  const breathe = Math.sin(phase * Math.PI * 2) * 3 + twitch;

  // Joint positions
  const kneeAngle = angle + Math.PI * 0.15 * side;
  const kneeX = legBase.x + Math.cos(angle) * upperLength;
  const kneeY =
    legBase.y + Math.sin(angle) * upperLength * 0.5 - s * 0.08 + breathe * 0.3;

  const footAngle = angle - Math.PI * 0.1 * side;
  const footX = kneeX + Math.cos(footAngle) * lowerLength;
  const footY =
    kneeY + Math.sin(footAngle) * lowerLength * 0.5 + s * 0.15 + breathe * 0.15;

  // Draw leg with gradient
  const legGrad = ctx.createLinearGradient(legBase.x, legBase.y, footX, footY);
  legGrad.addColorStop(0, "#4a4a58");
  legGrad.addColorStop(0.4, "#5a5a68");
  legGrad.addColorStop(0.6, "#4a4a58");
  legGrad.addColorStop(1, "#3a3a48");

  ctx.strokeStyle = legGrad;
  ctx.lineWidth = s * 0.045;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";

  // Upper leg segment
  ctx.beginPath();
  ctx.moveTo(legBase.x, legBase.y);
  ctx.lineTo(kneeX, kneeY);
  ctx.stroke();

  // Lower leg segment
  ctx.beginPath();
  ctx.moveTo(kneeX, kneeY);
  ctx.lineTo(footX, footY);
  ctx.stroke();

  // Knee joint
  ctx.fillStyle = "#5a5a68";
  ctx.beginPath();
  ctx.arc(kneeX, kneeY, s * 0.035, 0, Math.PI * 2);
  ctx.fill();

  // Knee joint highlight
  ctx.fillStyle = "#6a6a78";
  ctx.beginPath();
  ctx.arc(kneeX - s * 0.01, kneeY - s * 0.01, s * 0.015, 0, Math.PI * 2);
  ctx.fill();

  // Foot pad
  ctx.fillStyle = "#3a3a48";
  ctx.beginPath();
  ctx.ellipse(footX, footY, s * 0.04, s * 0.02, angle * 0.5, 0, Math.PI * 2);
  ctx.fill();

  // Foot grip details
  ctx.fillStyle = "#f97316";
  ctx.beginPath();
  ctx.arc(footX, footY, s * 0.015, 0, Math.PI * 2);
  ctx.fill();

  // Hydraulic detail on upper leg
  ctx.strokeStyle = "#6a6a78";
  ctx.lineWidth = s * 0.015;
  const midUpperX = (legBase.x + kneeX) / 2;
  const midUpperY = (legBase.y + kneeY) / 2;
  ctx.beginPath();
  ctx.moveTo(midUpperX - s * 0.015, midUpperY);
  ctx.lineTo(midUpperX + s * 0.015, midUpperY);
  ctx.stroke();
}

// Helper function for gun assembly with isometric perspective and pitch
function drawTurretGunAssembly(
  ctx: CanvasRenderingContext2D,
  pivotX: number,
  pivotY: number,
  rotation: number,
  foreshorten: number,
  pitch: number,
  pitchCos: number,
  pitchSin: number,
  s: number,
  zoom: number,
  time: number,
  recoilOffset: number,
  isAttacking: boolean,
  heatGlow: number
) {
  const cosR = Math.cos(rotation);
  const sinR = Math.sin(rotation);

  // Barrel dimensions
  const barrelBaseLength = s * 0.4;
  const barrelWidth = s * 0.04;
  const barrelSpacing = s * 0.055;

  // Apply pitch to barrel length
  const effectiveBarrelLength =
    barrelBaseLength * (0.5 + foreshorten * 0.5) * pitchCos;
  const pitchDrop =
    barrelBaseLength * (0.5 + foreshorten * 0.5) * pitchSin * 0.5;

  // Gun housing/mantlet
  const mantletX = pivotX + cosR * s * 0.08 - cosR * recoilOffset * 0.3;
  const mantletY = pivotY + sinR * s * 0.04 - sinR * recoilOffset * 0.15;

  const mantletGrad = ctx.createLinearGradient(
    mantletX - s * 0.08,
    mantletY,
    mantletX + s * 0.08,
    mantletY
  );
  mantletGrad.addColorStop(0, "#4a4a58");
  mantletGrad.addColorStop(0.3, "#5a5a68");
  mantletGrad.addColorStop(0.7, "#4a4a58");
  mantletGrad.addColorStop(1, "#3a3a48");
  ctx.fillStyle = mantletGrad;

  ctx.beginPath();
  ctx.ellipse(mantletX, mantletY, s * 0.09, s * 0.06, rotation, 0, Math.PI * 2);
  ctx.fill();

  // Draw dual barrels
  for (let barrel = -1; barrel <= 1; barrel += 2) {
    const perpX = -sinR * barrelSpacing * barrel;
    const perpY = cosR * barrelSpacing * barrel * 0.5;

    const bStartX = pivotX + perpX + cosR * s * 0.06 - cosR * recoilOffset;
    const bStartY =
      pivotY + perpY + sinR * s * 0.03 - sinR * recoilOffset * 0.5;

    const bEndX = bStartX + cosR * effectiveBarrelLength;
    const bEndY = bStartY + sinR * effectiveBarrelLength * 0.5 + pitchDrop;

    const bPerpX = -sinR * barrelWidth;
    const bPerpY = cosR * barrelWidth * 0.5;

    // Barrel housing
    ctx.fillStyle = "#4a4a58";
    ctx.beginPath();
    ctx.ellipse(
      bStartX,
      bStartY,
      barrelWidth * 1.4,
      barrelWidth * 0.7,
      rotation,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Main barrel body
    const barrelGrad = ctx.createLinearGradient(
      bStartX + bPerpX,
      bStartY + bPerpY,
      bStartX - bPerpX,
      bStartY - bPerpY
    );
    barrelGrad.addColorStop(0, "#6a6a78");
    barrelGrad.addColorStop(0.3, "#5a5a68");
    barrelGrad.addColorStop(0.7, "#4a4a58");
    barrelGrad.addColorStop(1, "#3a3a48");
    ctx.fillStyle = barrelGrad;

    ctx.beginPath();
    ctx.moveTo(bStartX + bPerpX, bStartY + bPerpY);
    ctx.lineTo(bEndX + bPerpX * 0.7, bEndY + bPerpY * 0.7);
    ctx.lineTo(bEndX - bPerpX * 0.7, bEndY - bPerpY * 0.7);
    ctx.lineTo(bStartX - bPerpX, bStartY - bPerpY);
    ctx.closePath();
    ctx.fill();

    // Reinforcement bands
    ctx.strokeStyle = "#7a7a88";
    ctx.lineWidth = 1.5 * zoom;
    for (let i = 0; i < 3; i++) {
      const t = 0.2 + i * 0.25;
      const bx = bStartX + cosR * effectiveBarrelLength * t;
      const by =
        bStartY + sinR * effectiveBarrelLength * t * 0.5 + pitchDrop * t;
      const widthMult = 1 - t * 0.3;
      ctx.beginPath();
      ctx.moveTo(bx + bPerpX * widthMult, by + bPerpY * widthMult);
      ctx.lineTo(bx - bPerpX * widthMult, by - bPerpY * widthMult);
      ctx.stroke();
    }

    // Heat glow
    if (heatGlow > 0) {
      ctx.strokeStyle = `rgba(255, 100, 30, ${heatGlow * 0.35})`;
      ctx.lineWidth = barrelWidth * 0.7;
      ctx.beginPath();
      ctx.moveTo(bStartX, bStartY);
      ctx.lineTo(bEndX, bEndY);
      ctx.stroke();
    }

    // Muzzle brake
    const muzzleStart = 0.82;
    const msx = bStartX + cosR * effectiveBarrelLength * muzzleStart;
    const msy =
      bStartY +
      sinR * effectiveBarrelLength * muzzleStart * 0.5 +
      pitchDrop * muzzleStart;

    ctx.fillStyle = "#3a3a48";
    ctx.beginPath();
    ctx.moveTo(msx + bPerpX * 0.7, msy + bPerpY * 0.7);
    ctx.lineTo(bEndX + bPerpX * 1.15, bEndY + bPerpY * 1.15);
    ctx.lineTo(bEndX - bPerpX * 1.15, bEndY - bPerpY * 1.15);
    ctx.lineTo(msx - bPerpX * 0.7, msy - bPerpY * 0.7);
    ctx.closePath();
    ctx.fill();

    // Muzzle bore
    ctx.fillStyle = "#1a1a1a";
    ctx.beginPath();
    ctx.ellipse(
      bEndX + cosR * zoom,
      bEndY + sinR * zoom * 0.5 + pitchSin * zoom,
      barrelWidth * 0.5 * foreshorten * pitchCos + barrelWidth * 0.2,
      barrelWidth * 0.35,
      rotation,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Muzzle flash
    if (isAttacking && heatGlow > 0.25) {
      const flashSize = s * 0.07 * heatGlow;
      const flashX = bEndX + cosR * s * 0.04;
      const flashY = bEndY + sinR * s * 0.02 + pitchDrop * 0.12;

      ctx.shadowColor = "#ffaa00";
      ctx.shadowBlur = 12 * zoom;

      const flashGrad = ctx.createRadialGradient(
        flashX,
        flashY,
        0,
        flashX,
        flashY,
        flashSize
      );
      flashGrad.addColorStop(0, `rgba(255, 255, 220, ${heatGlow})`);
      flashGrad.addColorStop(0.2, `rgba(255, 220, 100, ${heatGlow * 0.9})`);
      flashGrad.addColorStop(0.5, `rgba(255, 150, 50, ${heatGlow * 0.6})`);
      flashGrad.addColorStop(1, `rgba(255, 80, 0, 0)`);

      ctx.fillStyle = flashGrad;
      ctx.beginPath();
      ctx.arc(flashX, flashY, flashSize, 0, Math.PI * 2);
      ctx.fill();

      // Flash streaks
      ctx.strokeStyle = `rgba(255, 200, 100, ${heatGlow * 0.5})`;
      ctx.lineWidth = 1.5 * zoom;
      for (let i = 0; i < 4; i++) {
        const streakAngle = rotation + (i / 4) * Math.PI * 2 + time * 12;
        const streakLen = flashSize * (0.7 + Math.random() * 0.5);
        ctx.beginPath();
        ctx.moveTo(flashX, flashY);
        ctx.lineTo(
          flashX + Math.cos(streakAngle) * streakLen,
          flashY + Math.sin(streakAngle) * streakLen * 0.5
        );
        ctx.stroke();
      }

      ctx.shadowBlur = 0;
    }
  }

  // Shell casings
  if (isAttacking && heatGlow > 0.45) {
    const casingEjectX = pivotX - sinR * s * 0.12;
    const casingEjectY = pivotY + cosR * s * 0.06;

    ctx.fillStyle = "#daa520";
    for (let i = 0; i < 2; i++) {
      const casingOffset = (1 - heatGlow) * s * 0.12 + i * s * 0.04;
      const casingX = casingEjectX + casingOffset * (Math.random() - 0.5);
      const casingY = casingEjectY + casingOffset + Math.random() * s * 0.04;

      ctx.beginPath();
      ctx.ellipse(
        casingX,
        casingY,
        s * 0.012,
        s * 0.006,
        Math.random() * Math.PI,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }
  }

  // Smoke wisps
  if (isAttacking && heatGlow < 0.65 && heatGlow > 0.08) {
    const smokePhase = 1 - heatGlow;
    for (let barrel = -1; barrel <= 1; barrel += 2) {
      const perpX = -sinR * barrelSpacing * barrel;
      const perpY = cosR * barrelSpacing * barrel * 0.5;

      const smokeX =
        pivotX +
        perpX +
        cosR * effectiveBarrelLength +
        (Math.random() - 0.5) * s * 0.04;
      const smokeY =
        pivotY +
        perpY +
        sinR * effectiveBarrelLength * 0.5 +
        pitchDrop -
        smokePhase * s * 0.08;

      ctx.fillStyle = `rgba(100, 100, 110, ${(1 - smokePhase) * 0.2})`;
      ctx.beginPath();
      ctx.arc(
        smokeX,
        smokeY,
        s * 0.018 + smokePhase * s * 0.025,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }
  }
}

// ============================================================================
// PROJECTILE RENDERING - Fixed to come from correct positions
// ============================================================================
export function renderProjectile(
  ctx: CanvasRenderingContext2D,
  proj: Projectile,
  canvasWidth: number,
  canvasHeight: number,
  dpr: number,
  cameraOffset?: Position,
  cameraZoom?: number
) {
  const zoom = cameraZoom || 1;
  const t = proj.progress;

  let currentX = proj.from.x + (proj.to.x - proj.from.x) * t;
  let currentY = proj.from.y + (proj.to.y - proj.from.y) * t;

  let arcOffset = 0;
  if (proj.arcHeight) {
    arcOffset = Math.sin(t * Math.PI) * proj.arcHeight;
  }

  const elevationFade = proj.elevation ? proj.elevation * (1 - t) : 0;
  const currentPos = { x: currentX, y: currentY - arcOffset - elevationFade };
  const screenPos = worldToScreen(
    currentPos,
    canvasWidth,
    canvasHeight,
    dpr,
    cameraOffset,
    cameraZoom
  );

  // Trail
  const trailLength = 5;
  for (let i = 1; i <= trailLength; i++) {
    const trailT = Math.max(0, t - i * 0.06);
    const trailX = proj.from.x + (proj.to.x - proj.from.x) * trailT;
    const trailY = proj.from.y + (proj.to.y - proj.from.y) * trailT;
    let trailArc = 0;
    if (proj.arcHeight) {
      trailArc = Math.sin(trailT * Math.PI) * proj.arcHeight;
    }
    const trailElevation = proj.elevation ? proj.elevation * (1 - trailT) : 0;
    const trailPos = worldToScreen(
      { x: trailX, y: trailY - trailArc - trailElevation },
      canvasWidth,
      canvasHeight,
      dpr,
      cameraOffset,
      cameraZoom
    );

    const alpha = 0.35 * (1 - i / trailLength);
    ctx.fillStyle = proj.isFlamethrower
      ? `rgba(200, 80, 0, ${alpha})`
      : proj.type === "lab" || proj.type === "lightning"
      ? `rgba(0, 255, 255, ${alpha})`
      : proj.type === "arch"
      ? `rgba(50, 200, 100, ${alpha})`
      : `rgba(255, 150, 50, ${alpha})`;
    ctx.beginPath();
    ctx.arc(trailPos.x, trailPos.y, (5 - i * 0.7) * zoom, 0, Math.PI * 2);
    ctx.fill();
  }

  const projSize = proj.type === "cannon" ? 7 : proj.type === "hero" ? 6 : 5;

  ctx.save();
  ctx.translate(screenPos.x, screenPos.y);
  ctx.rotate(proj.rotation);

  if (proj.type === "flame") {
    ctx.shadowColor = "#ff4400";
    ctx.shadowBlur = 15 * zoom;
    for (let i = 0; i < 4; i++) {
      const flameOffset = (Math.random() - 0.5) * 6 * zoom;
      const flameSize = (4 + Math.random() * 4) * zoom;
      const flameGrad = ctx.createRadialGradient(
        flameOffset,
        flameOffset * 0.5,
        0,
        flameOffset,
        flameOffset * 0.5,
        flameSize
      );
      flameGrad.addColorStop(0, "rgba(255, 255, 100, 0.9)");
      flameGrad.addColorStop(0.4, "rgba(200, 120, 0, 0.7)");
      flameGrad.addColorStop(1, "rgba(255, 50, 0, 0)");
      ctx.fillStyle = flameGrad;
      ctx.beginPath();
      ctx.arc(flameOffset, flameOffset * 0.5, flameSize, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
    return;
  }

  if (proj.type === "bullet") {
    ctx.shadowColor = "#ffcc00";
    ctx.shadowBlur = 8 * zoom;
    ctx.fillStyle = "rgba(255, 200, 0, 0.6)";
    ctx.fillRect(-8 * zoom, -1.5 * zoom, 16 * zoom, 3 * zoom);
    ctx.fillStyle = "#ffdd44";
    ctx.beginPath();
    ctx.arc(4 * zoom, 0, 3 * zoom, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    return;
  }

  if (proj.type === "lab" || proj.type === "lightning") {
    // Lightning bolt projectile
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 12 * zoom;

    // Electric core
    const boltGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 8 * zoom);
    boltGrad.addColorStop(0, "#ffffff");
    boltGrad.addColorStop(0.3, "#ccffff");
    boltGrad.addColorStop(0.6, "#00ffff");
    boltGrad.addColorStop(1, "#0088ff");

    ctx.fillStyle = boltGrad;
    ctx.beginPath();
    ctx.arc(0, 0, 6 * zoom, 0, Math.PI * 2);
    ctx.fill();

    // Electric sparks
    ctx.strokeStyle = "#00ffff";
    ctx.lineWidth = 1.5 * zoom;
    for (let i = 0; i < 4; i++) {
      const sparkAngle = (i / 4) * Math.PI * 2 + Date.now() / 100;
      const sparkLen = 8 + Math.random() * 6;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(
        Math.cos(sparkAngle) * sparkLen * zoom,
        Math.sin(sparkAngle) * sparkLen * zoom
      );
      ctx.stroke();
    }

    ctx.restore();
    return;
  }

  if (proj.type === "arch") {
    // Music note beam projectile
    const time = Date.now() / 1000;
    ctx.shadowColor = "#32c864";
    ctx.shadowBlur = 15 * zoom;

    // Glowing green core
    const noteGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 10 * zoom);
    noteGrad.addColorStop(0, "#ffffff");
    noteGrad.addColorStop(0.3, "#aaffaa");
    noteGrad.addColorStop(0.6, "#32c864");
    noteGrad.addColorStop(1, "#228844");

    ctx.fillStyle = noteGrad;
    ctx.beginPath();
    ctx.arc(0, 0, 8 * zoom, 0, Math.PI * 2);
    ctx.fill();

    // Music notes orbiting the projectile
    ctx.fillStyle = "#ffffff";
    ctx.font = `bold ${12 * zoom}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    const symbols = ["", "", "", ""];
    for (let i = 0; i < 4; i++) {
      const noteAngle = (i / 4) * Math.PI * 2 + time * 8;
      const noteRadius = 14 * zoom;
      const nx = Math.cos(noteAngle) * noteRadius;
      const ny = Math.sin(noteAngle) * noteRadius * 0.5;
      ctx.fillText(symbols[i], nx, ny);
    }

    // Musical wave rings
    ctx.strokeStyle = "rgba(50, 200, 100, 0.5)";
    ctx.lineWidth = 2 * zoom;
    for (let ring = 0; ring < 3; ring++) {
      const ringPhase = (time * 4 + ring * 0.3) % 1;
      const ringSize = 5 + ringPhase * 20;
      const ringAlpha = 0.6 * (1 - ringPhase);
      ctx.strokeStyle = `rgba(50, 200, 100, ${ringAlpha})`;
      ctx.beginPath();
      ctx.ellipse(
        0,
        0,
        ringSize * zoom,
        ringSize * zoom * 0.5,
        0,
        0,
        Math.PI * 2
      );
      ctx.stroke();
    }

    // Trailing music notes behind projectile
    ctx.fillStyle = "rgba(50, 200, 100, 0.7)";
    for (let i = 1; i <= 3; i++) {
      const trailOffset = -i * 12 * zoom;
      const wobble = Math.sin(time * 10 + i * 2) * 4 * zoom;
      ctx.font = `${(10 - i) * zoom}px Arial`;
      ctx.fillText(symbols[i % 4], trailOffset, wobble);
    }

    ctx.restore();
    return;
  }

  if (proj.type === "spear") {
    ctx.shadowColor = "#8b4513";
    ctx.shadowBlur = 6 * zoom;
    ctx.fillStyle = "#8b4513";
    ctx.fillRect(-12 * zoom, -2 * zoom, 24 * zoom, 4 * zoom);
    ctx.fillStyle = "#c0c0c0";
    ctx.beginPath();
    ctx.moveTo(12 * zoom, 0);
    ctx.lineTo(4 * zoom, -4 * zoom);
    ctx.lineTo(4 * zoom, 4 * zoom);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    return;
  }

  // Default projectile
  ctx.shadowColor =
    proj.type === "cannon"
      ? "#ff6b35"
      : proj.type === "hero"
      ? "#c9a227"
      : "#c9a227";
  ctx.shadowBlur = 12 * zoom;

  const projGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, projSize * zoom);
  if (proj.type === "cannon") {
    projGradient.addColorStop(0, "#ffff00");
    projGradient.addColorStop(0.5, "#ff6600");
    projGradient.addColorStop(1, "#cc3300");
  } else {
    projGradient.addColorStop(0, "#ffffff");
    projGradient.addColorStop(0.5, "#c9a227");
    projGradient.addColorStop(1, "#ff8800");
  }

  ctx.fillStyle = projGradient;
  ctx.beginPath();
  ctx.arc(0, 0, projSize * zoom, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

// ============================================================================
// EFFECT RENDERING
// ============================================================================
export function renderEffect(
  ctx: CanvasRenderingContext2D,
  effect: Effect,
  canvasWidth: number,
  canvasHeight: number,
  dpr: number,
  enemies: Enemy[],
  towers: Tower[],
  selectedMap: string,
  cameraOffset?: Position,
  cameraZoom?: number
) {
  const screenPos = worldToScreen(
    effect.pos,
    canvasWidth,
    canvasHeight,
    dpr,
    cameraOffset,
    cameraZoom
  );
  const zoom = cameraZoom || 1;
  const progress = effect.progress;
  const alpha = 1 - progress;

  switch (effect.type) {
    case "explosion":
      const expRadius = effect.size * zoom * (0.5 + progress * 0.5);
      const expGradient = ctx.createRadialGradient(
        screenPos.x,
        screenPos.y,
        0,
        screenPos.x,
        screenPos.y,
        expRadius
      );
      expGradient.addColorStop(0, `rgba(255, 200, 50, ${alpha})`);
      expGradient.addColorStop(0.4, `rgba(200, 80, 0, ${alpha * 0.8})`);
      expGradient.addColorStop(0.7, `rgba(200, 50, 0, ${alpha * 0.5})`);
      expGradient.addColorStop(1, `rgba(100, 0, 0, 0)`);
      ctx.fillStyle = expGradient;
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        screenPos.y,
        expRadius,
        expRadius * 0.5,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();
      break;

    case "lightning":
    case "zap":
    case "beam":
    case "chain":
      if (effect.targetPos) {
        const targetScreen = worldToScreen(
          effect.targetPos,
          canvasWidth,
          canvasHeight,
          dpr,
          cameraOffset,
          cameraZoom
        );
        const intensity = effect.intensity || 1;

        // Find the source lab tower to get correct orb position
        let sourceX = screenPos.x;
        let sourceY = screenPos.y;

        // If we have a towerId, find that specific tower
        let sourceTower: Tower | undefined;
        if (effect.towerId) {
          sourceTower = towers.find((t) => t.id === effect.towerId);
        }

        // If no towerId or tower not found, search for nearby lab tower
        if (!sourceTower) {
          for (const tower of towers) {
            if (tower.type === "lab") {
              const towerWorld = gridToWorld(tower.pos);
              const distToEffect = Math.sqrt(
                Math.pow(towerWorld.x - effect.pos.x, 2) +
                  Math.pow(towerWorld.y - effect.pos.y, 2)
              );
              // Use larger threshold since effect pos might be offset
              if (distToEffect < 150) {
                sourceTower = tower;
                break;
              }
            }
          }
        }

        if (sourceTower) {
          const towerWorld = gridToWorld(sourceTower.pos);
          const towerScreen = worldToScreen(
            towerWorld,
            canvasWidth,
            canvasHeight,
            dpr,
            cameraOffset,
            cameraZoom
          );

          // Calculate orb position based on tower level and upgrade
          const towerLevel = effect.towerLevel || sourceTower.level;
          const towerUpgrade = effect.towerUpgrade || sourceTower.upgrade;
          const baseHeight = (25 + towerLevel * 8) * zoom;
          const topY = towerScreen.y - baseHeight;
          let coilHeight = (35 + towerLevel * 8) * zoom;

          // Adjust for level 3 upgrades
          if (towerLevel === 3) {
            if (towerUpgrade === "A") {
              coilHeight = 50 * zoom; // Focused beam
            } else if (towerUpgrade === "B") {
              coilHeight = 45 * zoom; // Chain lightning
            }
          }

          // Set source to orb position at top of coil
          sourceX = towerScreen.x;
          sourceY = topY - coilHeight + 5 * zoom;
        }

        ctx.save();
        ctx.strokeStyle = `rgba(0, 255, 255, ${alpha * intensity})`;
        ctx.lineWidth = 3 * zoom * intensity;
        ctx.lineCap = "round";
        ctx.shadowColor = "#00ffff";
        ctx.shadowBlur = 15 * zoom * intensity;

        ctx.beginPath();
        ctx.moveTo(sourceX, sourceY);

        const dx = targetScreen.x - sourceX;
        const dy = targetScreen.y - sourceY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const segments = Math.max(5, Math.floor(dist / 30));
        const jitter = 20 * zoom * intensity;

        for (let i = 1; i < segments; i++) {
          const t = i / segments;
          const baseX = sourceX + dx * t;
          const baseY = sourceY + dy * t;
          const perpX = -dy / dist;
          const perpY = dx / dist;
          const offset =
            (Math.random() - 0.5) * jitter * (1 - Math.abs(t - 0.5) * 2);
          ctx.lineTo(baseX + perpX * offset, baseY + perpY * offset);
        }
        ctx.lineTo(targetScreen.x, targetScreen.y);
        ctx.stroke();

        // Impact spark
        ctx.fillStyle = `rgba(150, 255, 255, ${alpha * intensity})`;
        ctx.beginPath();
        ctx.arc(
          targetScreen.x,
          targetScreen.y,
          8 * zoom * intensity,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.restore();
      }
      break;

    case "music_notes":
      if (effect.targetPos) {
        const targetScreen = worldToScreen(
          effect.targetPos,
          canvasWidth,
          canvasHeight,
          dpr,
          cameraOffset,
          cameraZoom
        );
        const intensity = effect.intensity || 1;
        const noteIndex = effect.noteIndex || 0;

        // Find the source arch tower to get correct portal position
        let sourceX = screenPos.x;
        let sourceY = screenPos.y;

        let sourceTower: Tower | undefined;
        if (effect.towerId) {
          sourceTower = towers.find((t) => t.id === effect.towerId);
        }

        if (sourceTower) {
          const towerWorld = gridToWorld(sourceTower.pos);
          const towerScreen = worldToScreen(
            towerWorld,
            canvasWidth,
            canvasHeight,
            dpr,
            cameraOffset,
            cameraZoom
          );

          // Calculate portal position (arch center)
          const towerLevel = effect.towerLevel || sourceTower.level;
          const pillarHeight = (35 + towerLevel * 8) * zoom;
          const archTopY = towerScreen.y - pillarHeight - 6 * zoom;
          const archCenterY = archTopY + 8 * zoom;

          sourceX = towerScreen.x;
          sourceY = archCenterY;
        }

        const glowColor =
          effect.towerUpgrade === "A"
            ? "255, 100, 100"
            : effect.towerUpgrade === "B"
            ? "100, 200, 255"
            : "50, 200, 100";

        ctx.save();

        const time = Date.now() / 1000;
        const dx = targetScreen.x - sourceX;
        const dy = targetScreen.y - sourceY;

        // Note flies along path with wobble
        const noteT = progress;
        const wobbleAmplitude = 15 * zoom * (1 - noteT); // Wobble decreases as it approaches target
        const wobbleX = Math.sin(time * 12 + noteIndex * 1.5) * wobbleAmplitude;
        const wobbleY =
          Math.cos(time * 10 + noteIndex * 2) * wobbleAmplitude * 0.5;

        const noteX = sourceX + dx * noteT + wobbleX;
        const noteY = sourceY + dy * noteT + wobbleY;

        // Different note sizes based on index
        const noteSize = (14 + Math.sin(noteIndex * 0.7) * 4) * zoom;
        const noteAlpha =
          alpha * intensity * (noteT < 0.9 ? 1 : (1 - noteT) * 10);

        // Glow trail
        ctx.shadowColor = `rgb(${glowColor})`;
        ctx.shadowBlur = 10 * zoom;

        // Draw music note
        ctx.fillStyle = `rgba(${glowColor}, ${noteAlpha})`;
        ctx.font = `bold ${noteSize}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const symbols = ["", "", "", "", ""];
        ctx.fillText(symbols[noteIndex % 5], noteX, noteY);

        // Note sparkle trail
        for (let t = 0; t < 3; t++) {
          const trailT = Math.max(0, noteT - t * 0.08);
          const trailX =
            sourceX +
            dx * trailT +
            Math.sin(time * 12 + noteIndex * 1.5 + t) * wobbleAmplitude * 0.5;
          const trailY =
            sourceY +
            dy * trailT +
            Math.cos(time * 10 + noteIndex * 2 + t) * wobbleAmplitude * 0.3;
          const trailAlpha = noteAlpha * (1 - t * 0.3);

          ctx.fillStyle = `rgba(${glowColor}, ${trailAlpha * 0.5})`;
          ctx.beginPath();
          ctx.arc(trailX, trailY, (3 - t) * zoom, 0, Math.PI * 2);
          ctx.fill();
        }

        // Impact effect at target when note arrives
        if (noteT > 0.85) {
          const impactPhase = (noteT - 0.85) / 0.15;
          const impactSize = impactPhase * 15 * zoom;
          ctx.fillStyle = `rgba(${glowColor}, ${(1 - impactPhase) * 0.6})`;
          ctx.beginPath();
          ctx.arc(targetScreen.x, targetScreen.y, impactSize, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.shadowBlur = 0;
        ctx.restore();
      }
      break;

    case "cannon_shot":
    case "bullet_stream":
    case "flame_burst":
      if (effect.targetPos) {
        const targetScreen = worldToScreen(
          effect.targetPos,
          canvasWidth,
          canvasHeight,
          dpr,
          cameraOffset,
          cameraZoom
        );

        // Find the source cannon tower
        let sourceX = screenPos.x;
        let sourceY = screenPos.y;

        let sourceTower: Tower | undefined;
        if (effect.towerId) {
          sourceTower = towers.find((t) => t.id === effect.towerId);
        }

        if (sourceTower) {
          const towerWorld = gridToWorld(sourceTower.pos);
          const towerScreen = worldToScreen(
            towerWorld,
            canvasWidth,
            canvasHeight,
            dpr,
            cameraOffset,
            cameraZoom
          );

          // Calculate turret position
          const towerLevel = effect.towerLevel || sourceTower.level;
          const baseHeight = (24 + towerLevel * 10) * zoom;
          const turretY = towerScreen.y - baseHeight - 12 * zoom;

          // Calculate barrel end position based on rotation
          const rotation = effect.rotation || sourceTower.rotation || 0;
          const cosR = Math.cos(rotation);
          const sinR = Math.sin(rotation);
          const foreshorten = Math.abs(cosR);

          // Turret radius - barrel starts from inside the turret
          const turretRadius = (towerLevel >= 3 ? 10 : 8) * zoom;

          // Barrel length varies by level
          const baseBarrelLength = (30 + towerLevel * 12) * zoom;
          const barrelLength = baseBarrelLength * (0.4 + foreshorten * 0.6);

          // Projectile spawns from barrel end (turret radius + barrel length)
          const totalLength = turretRadius + barrelLength;
          sourceX = towerScreen.x + cosR * totalLength;
          sourceY = turretY + sinR * totalLength * 0.5;
        }

        ctx.save();

        const dx = targetScreen.x - sourceX;
        const dy = targetScreen.y - sourceY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (effect.type === "cannon_shot") {
          // Cannon ball projectile
          const projT = progress;
          const projX = sourceX + dx * projT;
          const projY =
            sourceY + dy * projT - Math.sin(projT * Math.PI) * 20 * zoom; // Arc

          // Projectile glow
          ctx.shadowColor = "#ff6600";
          ctx.shadowBlur = 15 * zoom;

          const projGrad = ctx.createRadialGradient(
            projX,
            projY,
            0,
            projX,
            projY,
            8 * zoom
          );
          projGrad.addColorStop(0, `rgba(255, 255, 150, ${alpha})`);
          projGrad.addColorStop(0.4, `rgba(255, 150, 50, ${alpha})`);
          projGrad.addColorStop(1, `rgba(200, 80, 0, ${alpha * 0.5})`);

          ctx.fillStyle = projGrad;
          ctx.beginPath();
          ctx.arc(projX, projY, 7 * zoom, 0, Math.PI * 2);
          ctx.fill();

          // Smoke trail
          for (let t = 0; t < 4; t++) {
            const trailT = Math.max(0, projT - t * 0.08);
            const trailX = sourceX + dx * trailT;
            const trailY =
              sourceY + dy * trailT - Math.sin(trailT * Math.PI) * 20 * zoom;
            ctx.fillStyle = `rgba(100, 100, 100, ${
              alpha * (1 - t * 0.25) * 0.5
            })`;
            ctx.beginPath();
            ctx.arc(trailX, trailY, (4 - t) * zoom, 0, Math.PI * 2);
            ctx.fill();
          }
        } else if (effect.type === "bullet_stream") {
          // Gatling bullets - spawn from barrel end, not center
          // Calculate barrel end position based on rotation
          const rotation = effect.rotation || 0;
          const cosR = Math.cos(rotation);
          const sinR = Math.sin(rotation);
          const foreshorten = Math.abs(cosR);

          // Barrel length adjusted for foreshortening
          const barrelOffset = -42 * zoom * (0.5 + foreshorten * 0.5);

          // Actual bullet source is at the end of the barrel
          const bulletSourceX = sourceX + cosR * barrelOffset;
          const bulletSourceY = sourceY + sinR * barrelOffset * 0.5;

          // Recalculate distance from new source
          const bulletDx = targetScreen.x - bulletSourceX;
          const bulletDy = targetScreen.y - bulletSourceY;
          const bulletDist = Math.sqrt(
            bulletDx * bulletDx + bulletDy * bulletDy
          );

          // Multiple spinning barrels = multiple bullet streams
          for (let barrel = 0; barrel < 3; barrel++) {
            // Slight perpendicular offset for each barrel
            const barrelAngle =
              (Date.now() / 50 + (barrel * Math.PI * 2) / 8) % (Math.PI * 2);
            const perpOffset = Math.sin(barrelAngle) * 3 * zoom;
            const perpX = -sinR * perpOffset;
            const perpY = cosR * perpOffset * 0.5;

            const thisSourceX = bulletSourceX + perpX;
            const thisSourceY = bulletSourceY + perpY;

            for (let b = 0; b < 2; b++) {
              const bulletT = Math.min(
                1,
                progress * 1.8 + barrel * 0.08 + b * 0.12
              );
              if (bulletT > 0 && bulletT < 1) {
                const bulletX = thisSourceX + bulletDx * bulletT;
                const bulletY = thisSourceY + bulletDy * bulletT;

                ctx.fillStyle = `rgba(255, 220, 100, ${alpha})`;
                ctx.shadowColor = "#ffcc00";
                ctx.shadowBlur = 10 * zoom;
                ctx.beginPath();
                ctx.arc(bulletX, bulletY, 3.5 * zoom, 0, Math.PI * 2);
                ctx.fill();

                // Hot core
                ctx.fillStyle = `rgba(255, 255, 200, ${alpha * 0.8})`;
                ctx.beginPath();
                ctx.arc(bulletX, bulletY, 1.5 * zoom, 0, Math.PI * 2);
                ctx.fill();

                // Tracer line
                const tracerLen = 18 * zoom;
                const tracerStartT = Math.max(
                  0,
                  bulletT - tracerLen / bulletDist
                );
                ctx.strokeStyle = `rgba(255, 180, 50, ${alpha * 0.6})`;
                ctx.lineWidth = 2.5 * zoom;
                ctx.beginPath();
                ctx.moveTo(
                  thisSourceX + bulletDx * tracerStartT,
                  thisSourceY + bulletDy * tracerStartT
                );
                ctx.lineTo(bulletX, bulletY);
                ctx.stroke();
              }
            }
          }
        } else if (effect.type === "flame_burst") {
          // Flamethrower stream
          ctx.shadowColor = "#ff4400";
          ctx.shadowBlur = 20 * zoom;

          for (let f = 0; f < 8; f++) {
            const flameT = Math.min(1, progress * 1.2 + f * 0.05);
            if (flameT > 0 && flameT < 1) {
              const wobble =
                Math.sin(Date.now() / 50 + f) * 8 * zoom * (1 - flameT);
              const perpX = -dy / dist;
              const perpY = dx / dist;

              const flameX = sourceX + dx * flameT + perpX * wobble;
              const flameY = sourceY + dy * flameT + perpY * wobble * 0.5;
              const flameSize = (12 - f * 0.8 - flameT * 6) * zoom;

              const flameGrad = ctx.createRadialGradient(
                flameX,
                flameY,
                0,
                flameX,
                flameY,
                flameSize
              );
              flameGrad.addColorStop(
                0,
                `rgba(255, 255, 150, ${alpha * (1 - flameT * 0.5)})`
              );
              flameGrad.addColorStop(
                0.3,
                `rgba(255, 180, 50, ${alpha * (1 - flameT * 0.5)})`
              );
              flameGrad.addColorStop(
                0.7,
                `rgba(255, 80, 0, ${alpha * (1 - flameT * 0.7)})`
              );
              flameGrad.addColorStop(1, `rgba(200, 30, 0, 0)`);

              ctx.fillStyle = flameGrad;
              ctx.beginPath();
              ctx.arc(flameX, flameY, flameSize, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }

        ctx.shadowBlur = 0;
        ctx.restore();
      }
      break;

    case "sonic":
      const sonicRadius = effect.size * zoom * (0.2 + progress * 0.8);
      for (let ring = 0; ring < 3; ring++) {
        const ringProgress = (progress + ring * 0.15) % 1;
        const ringRadius = sonicRadius * (0.3 + ringProgress * 0.7);
        const ringAlpha = (1 - ringProgress) * alpha * 0.6;

        ctx.strokeStyle = `rgba(180, 100, 255, ${ringAlpha})`;
        ctx.lineWidth = 2 * zoom;
        ctx.beginPath();
        ctx.ellipse(
          screenPos.x,
          screenPos.y,
          ringRadius,
          ringRadius * 0.5,
          0,
          0,
          Math.PI * 2
        );
        ctx.stroke();
      }
      break;

    // ========== NEW SPELL EFFECTS ==========

    case "meteor_incoming": {
      // Meteor falling from sky with warning circle
      const meteorProgress = progress;
      const targetScreen = effect.targetPos
        ? worldToScreen(
            effect.targetPos,
            canvasWidth,
            canvasHeight,
            dpr,
            cameraOffset,
            cameraZoom
          )
        : screenPos;

      // Warning circle on ground (pulsing)
      const warningPulse = 0.5 + Math.sin(Date.now() / 100) * 0.3;
      ctx.strokeStyle = `rgba(200, 80, 0, ${warningPulse})`;
      ctx.lineWidth = 3 * zoom;
      ctx.setLineDash([10, 5]);
      ctx.beginPath();
      ctx.ellipse(
        targetScreen.x,
        targetScreen.y,
        effect.size * zoom * 0.6,
        effect.size * zoom * 0.3,
        0,
        0,
        Math.PI * 2
      );
      ctx.stroke();
      ctx.setLineDash([]);

      // Meteor position (falling from sky)
      const meteorY = targetScreen.y - 300 * zoom * (1 - meteorProgress);
      const meteorX = targetScreen.x;

      // Fire trail
      for (let t = 0; t < 8; t++) {
        const trailY = meteorY - t * 15 * zoom;
        const trailAlpha = (1 - t / 8) * 0.6;
        const trailSize = (20 - t * 2) * zoom;

        const trailGrad = ctx.createRadialGradient(
          meteorX,
          trailY,
          0,
          meteorX,
          trailY,
          trailSize
        );
        trailGrad.addColorStop(0, `rgba(255, 200, 50, ${trailAlpha})`);
        trailGrad.addColorStop(0.5, `rgba(200, 80, 0, ${trailAlpha * 0.6})`);
        trailGrad.addColorStop(1, `rgba(200, 50, 0, 0)`);
        ctx.fillStyle = trailGrad;
        ctx.beginPath();
        ctx.arc(
          meteorX + Math.sin(t) * 3 * zoom,
          trailY,
          trailSize,
          0,
          Math.PI * 2
        );
        ctx.fill();
      }

      // Meteor core
      ctx.shadowColor = "#ff6600";
      ctx.shadowBlur = 30 * zoom;
      const meteorGrad = ctx.createRadialGradient(
        meteorX,
        meteorY,
        0,
        meteorX,
        meteorY,
        25 * zoom
      );
      meteorGrad.addColorStop(0, "#ffffff");
      meteorGrad.addColorStop(0.3, "#ffcc00");
      meteorGrad.addColorStop(0.6, "#ff6600");
      meteorGrad.addColorStop(1, "#cc3300");
      ctx.fillStyle = meteorGrad;
      ctx.beginPath();
      ctx.arc(meteorX, meteorY, 20 * zoom, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      break;
    }

    case "meteor_impact": {
      // Massive explosion with shockwave
      const impactProgress = progress;

      // Ground crater
      ctx.fillStyle = `rgba(50, 30, 20, ${alpha * 0.6})`;
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        screenPos.y + 5 * zoom,
        effect.size * zoom * 0.4,
        effect.size * zoom * 0.2,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // Main explosion
      const expSize = effect.size * zoom * (0.3 + impactProgress * 0.7);
      ctx.shadowColor = "#ff4400";
      ctx.shadowBlur = 40 * zoom * alpha;

      const expGrad = ctx.createRadialGradient(
        screenPos.x,
        screenPos.y,
        0,
        screenPos.x,
        screenPos.y,
        expSize
      );
      expGrad.addColorStop(0, `rgba(255, 255, 200, ${alpha})`);
      expGrad.addColorStop(0.2, `rgba(255, 200, 50, ${alpha * 0.9})`);
      expGrad.addColorStop(0.5, `rgba(200, 80, 0, ${alpha * 0.7})`);
      expGrad.addColorStop(0.8, `rgba(200, 50, 0, ${alpha * 0.4})`);
      expGrad.addColorStop(1, `rgba(100, 20, 0, 0)`);
      ctx.fillStyle = expGrad;
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        screenPos.y,
        expSize,
        expSize * 0.6,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // Shockwave rings
      for (let ring = 0; ring < 3; ring++) {
        const ringProgress = Math.min(1, impactProgress * 1.5 + ring * 0.1);
        const ringRadius = effect.size * zoom * ringProgress;
        const ringAlpha = (1 - ringProgress) * alpha * 0.5;

        ctx.strokeStyle = `rgba(255, 150, 50, ${ringAlpha})`;
        ctx.lineWidth = (4 - ring) * zoom;
        ctx.beginPath();
        ctx.ellipse(
          screenPos.x,
          screenPos.y,
          ringRadius,
          ringRadius * 0.5,
          0,
          0,
          Math.PI * 2
        );
        ctx.stroke();
      }

      // Flying debris
      for (let d = 0; d < 12; d++) {
        const debrisAngle = (d / 12) * Math.PI * 2;
        const debrisDist =
          effect.size *
          zoom *
          0.3 *
          impactProgress *
          (0.5 + Math.sin(d * 2.5) * 0.5);
        const debrisX = screenPos.x + Math.cos(debrisAngle) * debrisDist;
        const debrisY =
          screenPos.y +
          Math.sin(debrisAngle) * debrisDist * 0.5 -
          impactProgress * 30 * zoom * Math.sin(d);

        ctx.fillStyle = `rgba(100, 60, 30, ${alpha * (1 - impactProgress)})`;
        ctx.beginPath();
        ctx.arc(debrisX, debrisY, 3 * zoom, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;
      break;
    }

    case "lightning_bolt": {
      // Lightning strike from sky
      const strikeProgress = progress;
      const targetScreen = effect.targetPos
        ? worldToScreen(
            effect.targetPos,
            canvasWidth,
            canvasHeight,
            dpr,
            cameraOffset,
            cameraZoom
          )
        : screenPos;

      // Sky flash
      if (strikeProgress < 0.3) {
        ctx.fillStyle = `rgba(200, 220, 255, ${(0.3 - strikeProgress) * 0.3})`;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      }

      // Lightning bolt with branching
      ctx.save();
      ctx.strokeStyle = `rgba(200, 220, 255, ${alpha})`;
      ctx.lineWidth = 4 * zoom;
      ctx.shadowColor = "#88aaff";
      ctx.shadowBlur = 25 * zoom;
      ctx.lineCap = "round";

      const startY = targetScreen.y - 400 * zoom;
      const segments = 12;

      // Main bolt
      ctx.beginPath();
      ctx.moveTo(targetScreen.x, startY);
      let lastX = targetScreen.x;
      let lastY = startY;

      for (let i = 1; i <= segments; i++) {
        const t = i / segments;
        const baseY = startY + (targetScreen.y - startY) * t;
        const jitter = (1 - t) * 30 * zoom * (Math.random() - 0.5);
        const x = targetScreen.x + jitter;
        ctx.lineTo(x, baseY);

        // Branch lightning
        if (i > 2 && i < segments - 2 && Math.random() > 0.6) {
          ctx.moveTo(x, baseY);
          const branchAngle = (Math.random() - 0.5) * Math.PI * 0.5;
          const branchLen = 40 * zoom * Math.random();
          ctx.lineTo(
            x + Math.cos(branchAngle) * branchLen,
            baseY + Math.sin(branchAngle) * branchLen * 0.3
          );
          ctx.moveTo(x, baseY);
        }
        lastX = x;
        lastY = baseY;
      }
      ctx.lineTo(targetScreen.x, targetScreen.y);
      ctx.stroke();

      // Impact glow
      const impactGrad = ctx.createRadialGradient(
        targetScreen.x,
        targetScreen.y,
        0,
        targetScreen.x,
        targetScreen.y,
        50 * zoom
      );
      impactGrad.addColorStop(0, `rgba(200, 220, 255, ${alpha})`);
      impactGrad.addColorStop(0.3, `rgba(100, 150, 255, ${alpha * 0.6})`);
      impactGrad.addColorStop(1, `rgba(50, 80, 200, 0)`);
      ctx.fillStyle = impactGrad;
      ctx.beginPath();
      ctx.arc(targetScreen.x, targetScreen.y, 40 * zoom, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.restore();
      break;
    }

    case "freeze_wave": {
      // Expanding ice wave
      const freezeRadius = effect.size * zoom * progress;

      // Ice crystals pattern
      ctx.save();
      ctx.strokeStyle = `rgba(150, 220, 255, ${alpha * 0.6})`;
      ctx.fillStyle = `rgba(200, 240, 255, ${alpha * 0.2})`;
      ctx.lineWidth = 2 * zoom;

      // Central frost
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        screenPos.y,
        freezeRadius,
        freezeRadius * 0.5,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();
      ctx.stroke();

      // Ice crystals radiating outward
      for (let c = 0; c < 8; c++) {
        const angle = (c / 8) * Math.PI * 2;
        const crystalDist = freezeRadius * 0.8;
        const cx = screenPos.x + Math.cos(angle) * crystalDist;
        const cy = screenPos.y + Math.sin(angle) * crystalDist * 0.5;

        // Snowflake pattern
        ctx.strokeStyle = `rgba(200, 240, 255, ${alpha * 0.8})`;
        for (let arm = 0; arm < 6; arm++) {
          const armAngle = angle + (arm / 6) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(
            cx + Math.cos(armAngle) * 8 * zoom,
            cy + Math.sin(armAngle) * 4 * zoom
          );
          ctx.stroke();
        }
      }
      ctx.restore();
      break;
    }

    case "payday_aura": {
      // Gold aura effect (rendered around enemies in main loop)
      const auraRadius = effect.size * zoom;
      const time = Date.now() / 1000;
      ctx.save();
      ctx.strokeStyle = `rgba(255, 215, 0, ${0.5 + Math.sin(time * 3) * 0.2})`;
      ctx.lineWidth = 4 * zoom;
      ctx.setLineDash([15, 10]);
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        screenPos.y,
        auraRadius,
        auraRadius * 0.5,
        0,
        0,
        Math.PI * 2
      );
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();

      break;
    }

    // ========== NEW HERO ABILITY EFFECTS ==========

    case "roar_wave": {
      // Tiger's roar shockwave
      const roarRadius = effect.size * zoom * (0.2 + progress * 0.8);

      // Orange fear energy
      ctx.save();
      ctx.shadowColor = "#ff6600";
      ctx.shadowBlur = 20 * zoom;

      for (let ring = 0; ring < 4; ring++) {
        const ringProgress = (progress + ring * 0.1) % 1;
        const ringRadius = roarRadius * (0.4 + ringProgress * 0.6);
        const ringAlpha = (1 - ringProgress) * alpha * 0.5;

        ctx.strokeStyle = `rgba(255, 150, 50, ${ringAlpha})`;
        ctx.lineWidth = (4 - ring) * zoom;
        ctx.beginPath();
        ctx.ellipse(
          screenPos.x,
          screenPos.y,
          ringRadius,
          ringRadius * 0.5,
          0,
          0,
          Math.PI * 2
        );
        ctx.stroke();
      }

      // Roar lines radiating outward
      for (let line = 0; line < 12; line++) {
        const angle = (line / 12) * Math.PI * 2;
        const lineAlpha = alpha * 0.6;
        ctx.strokeStyle = `rgba(255, 200, 100, ${lineAlpha})`;
        ctx.lineWidth = 2 * zoom;
        ctx.beginPath();
        ctx.moveTo(
          screenPos.x + Math.cos(angle) * 20 * zoom,
          screenPos.y + Math.sin(angle) * 10 * zoom
        );
        ctx.lineTo(
          screenPos.x + Math.cos(angle) * roarRadius * 0.8,
          screenPos.y + Math.sin(angle) * roarRadius * 0.4
        );
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
      ctx.restore();
      break;
    }

    case "high_note": {
      // Tenor's sonic blast with musical notes
      const noteRadius = effect.size * zoom * (0.3 + progress * 0.7);

      ctx.save();
      ctx.shadowColor = "#aa66ff";
      ctx.shadowBlur = 15 * zoom;

      // Purple sonic waves
      for (let wave = 0; wave < 5; wave++) {
        const waveProgress = (progress + wave * 0.08) % 1;
        const waveRadius = noteRadius * (0.3 + waveProgress * 0.7);
        const waveAlpha = (1 - waveProgress) * alpha * 0.4;

        ctx.strokeStyle = `rgba(180, 100, 255, ${waveAlpha})`;
        ctx.lineWidth = (3 - wave * 0.4) * zoom;
        ctx.beginPath();
        ctx.ellipse(
          screenPos.x,
          screenPos.y,
          waveRadius,
          waveRadius * 0.5,
          0,
          0,
          Math.PI * 2
        );
        ctx.stroke();
      }

      // Floating musical notes
      for (let n = 0; n < 8; n++) {
        const noteAngle = (n / 8) * Math.PI * 2 + progress * Math.PI;
        const noteDist =
          noteRadius * 0.6 * (0.5 + Math.sin(progress * Math.PI * 2 + n) * 0.3);
        const noteX = screenPos.x + Math.cos(noteAngle) * noteDist;
        const noteY =
          screenPos.y +
          Math.sin(noteAngle) * noteDist * 0.5 -
          progress * 20 * zoom;
        const noteAlpha = alpha * 0.8;

        ctx.fillStyle = `rgba(200, 150, 255, ${noteAlpha})`;
        ctx.font = `${14 * zoom}px Arial`;
        ctx.fillText("", noteX, noteY);
      }
      ctx.shadowBlur = 0;
      ctx.restore();
      break;
    }

    case "fortress_shield": {
      // Mathey Knight's invincibility shield
      const shieldRadius = effect.size * zoom;
      const time = Date.now() / 1000;

      ctx.save();
      ctx.shadowColor = "#6666ff";
      ctx.shadowBlur = 20 * zoom;

      // Hexagonal shield pattern
      const hexPoints = 6;
      ctx.strokeStyle = `rgba(100, 150, 255, ${
        0.6 + Math.sin(time * 5) * 0.2
      })`;
      ctx.lineWidth = 3 * zoom;
      ctx.beginPath();
      for (let i = 0; i <= hexPoints; i++) {
        const angle = (i / hexPoints) * Math.PI * 2 - Math.PI / 2;
        const x = screenPos.x + Math.cos(angle) * shieldRadius;
        const y = screenPos.y + Math.sin(angle) * shieldRadius * 0.5;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Inner glow
      const shieldGrad = ctx.createRadialGradient(
        screenPos.x,
        screenPos.y,
        0,
        screenPos.x,
        screenPos.y,
        shieldRadius
      );
      shieldGrad.addColorStop(0, `rgba(100, 150, 255, 0.1)`);
      shieldGrad.addColorStop(0.7, `rgba(100, 150, 255, 0.2)`);
      shieldGrad.addColorStop(1, `rgba(100, 150, 255, 0)`);
      ctx.fillStyle = shieldGrad;
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        screenPos.y,
        shieldRadius,
        shieldRadius * 0.5,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // Rotating runes
      for (let r = 0; r < 4; r++) {
        const runeAngle = time * 2 + (r / 4) * Math.PI * 2;
        const runeX = screenPos.x + Math.cos(runeAngle) * shieldRadius * 0.7;
        const runeY = screenPos.y + Math.sin(runeAngle) * shieldRadius * 0.35;

        ctx.fillStyle = `rgba(150, 200, 255, ${
          0.7 + Math.sin(time * 3 + r) * 0.3
        })`;
        ctx.font = `${10 * zoom}px Arial`;
        ctx.fillText("", runeX - 4 * zoom, runeY + 4 * zoom);
      }
      ctx.shadowBlur = 0;
      ctx.restore();
      break;
    }

    case "meteor_strike": {
      // Rocky's meteor ability (similar to spell but hero-sized)
      const strikeRadius = effect.size * zoom * (0.4 + progress * 0.6);

      ctx.save();
      ctx.shadowColor = "#996633";
      ctx.shadowBlur = 25 * zoom;

      // Ground impact crater
      ctx.fillStyle = `rgba(80, 60, 40, ${alpha * 0.5})`;
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        screenPos.y,
        strikeRadius * 0.6,
        strikeRadius * 0.3,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // Dust cloud
      const dustGrad = ctx.createRadialGradient(
        screenPos.x,
        screenPos.y,
        0,
        screenPos.x,
        screenPos.y,
        strikeRadius
      );
      dustGrad.addColorStop(0, `rgba(150, 120, 80, ${alpha * 0.7})`);
      dustGrad.addColorStop(0.5, `rgba(120, 90, 60, ${alpha * 0.4})`);
      dustGrad.addColorStop(1, `rgba(80, 60, 40, 0)`);
      ctx.fillStyle = dustGrad;
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        screenPos.y - 10 * zoom * progress,
        strikeRadius,
        strikeRadius * 0.6,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // Rock fragments
      for (let rock = 0; rock < 8; rock++) {
        const rockAngle = (rock / 8) * Math.PI * 2;
        const rockDist = strikeRadius * 0.5 * progress;
        const rockX = screenPos.x + Math.cos(rockAngle) * rockDist;
        const rockY =
          screenPos.y +
          Math.sin(rockAngle) * rockDist * 0.5 -
          progress * 15 * zoom;

        ctx.fillStyle = `rgba(100, 80, 60, ${alpha})`;
        ctx.beginPath();
        ctx.arc(rockX, rockY, (4 - progress * 2) * zoom, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;
      ctx.restore();
      break;
    }

    case "inspiration": {
      // F. Scott's tower buff aura
      const auraRadius = effect.size * zoom * (0.5 + progress * 0.3);
      const time = Date.now() / 1000;

      ctx.save();

      // Golden light rays
      for (let ray = 0; ray < 12; ray++) {
        const rayAngle = (ray / 12) * Math.PI * 2 + time * 0.5;
        const rayAlpha = alpha * 0.3 * (0.5 + Math.sin(time * 3 + ray) * 0.5);

        ctx.strokeStyle = `rgba(255, 215, 0, ${rayAlpha})`;
        ctx.lineWidth = 2 * zoom;
        ctx.beginPath();
        ctx.moveTo(screenPos.x, screenPos.y);
        ctx.lineTo(
          screenPos.x + Math.cos(rayAngle) * auraRadius,
          screenPos.y + Math.sin(rayAngle) * auraRadius * 0.5
        );
        ctx.stroke();
      }

      // Central glow
      const inspireGrad = ctx.createRadialGradient(
        screenPos.x,
        screenPos.y,
        0,
        screenPos.x,
        screenPos.y,
        auraRadius * 0.3
      );
      inspireGrad.addColorStop(0, `rgba(255, 230, 150, ${alpha * 0.4})`);
      inspireGrad.addColorStop(1, `rgba(255, 215, 0, 0)`);
      ctx.fillStyle = inspireGrad;
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        screenPos.y,
        auraRadius * 0.3,
        auraRadius * 0.15,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();

      ctx.restore();
      break;
    }

    case "knight_summon": {
      // Captain's knight summoning effect
      const summonRadius = effect.size * zoom;
      const time = Date.now() / 1000;

      ctx.save();
      ctx.shadowColor = "#ffaa00";
      ctx.shadowBlur = 15 * zoom;

      // Summoning circle
      ctx.strokeStyle = `rgba(255, 200, 100, ${alpha})`;
      ctx.lineWidth = 3 * zoom;
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        screenPos.y,
        summonRadius,
        summonRadius * 0.5,
        0,
        0,
        Math.PI * 2
      );
      ctx.stroke();

      // Rising energy pillars for each knight
      for (let k = 0; k < 3; k++) {
        const pillarAngle = (k / 3) * Math.PI * 2 - Math.PI / 2;
        const pillarX =
          screenPos.x + Math.cos(pillarAngle) * summonRadius * 0.6;
        const pillarY =
          screenPos.y + Math.sin(pillarAngle) * summonRadius * 0.3;
        const pillarHeight = 40 * zoom * (1 - progress);

        const pillarGrad = ctx.createLinearGradient(
          pillarX,
          pillarY,
          pillarX,
          pillarY - pillarHeight
        );
        pillarGrad.addColorStop(0, `rgba(255, 200, 100, ${alpha})`);
        pillarGrad.addColorStop(1, `rgba(255, 200, 100, 0)`);
        ctx.fillStyle = pillarGrad;
        ctx.fillRect(
          pillarX - 4 * zoom,
          pillarY - pillarHeight,
          8 * zoom,
          pillarHeight
        );
      }
      ctx.shadowBlur = 0;
      ctx.restore();
      break;
    }

    case "turret_deploy": {
      // Engineer's turret deployment effect
      const deployRadius = effect.size * zoom;

      ctx.save();
      ctx.shadowColor = "#ffcc00";
      ctx.shadowBlur = 12 * zoom;

      // Construction sparks
      for (let spark = 0; spark < 8; spark++) {
        const sparkAngle = (spark / 8) * Math.PI * 2 + progress * Math.PI * 4;
        const sparkDist = deployRadius * 0.5 * (1 - progress * 0.5);
        const sparkX = screenPos.x + Math.cos(sparkAngle) * sparkDist;
        const sparkY =
          screenPos.y +
          Math.sin(sparkAngle) * sparkDist * 0.5 -
          progress * 10 * zoom;

        ctx.fillStyle = `rgba(255, 220, 100, ${alpha * (1 - progress)})`;
        ctx.beginPath();
        ctx.arc(sparkX, sparkY, 2 * zoom, 0, Math.PI * 2);
        ctx.fill();
      }

      // Build-up circle
      ctx.strokeStyle = `rgba(255, 200, 50, ${alpha})`;
      ctx.lineWidth = 2 * zoom;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        screenPos.y,
        deployRadius * (1 - progress * 0.5),
        deployRadius * 0.5 * (1 - progress * 0.5),
        0,
        0,
        Math.PI * 2
      );
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.shadowBlur = 0;
      ctx.restore();
      break;
    }
  }
}

// ============================================================================
// PARTICLE RENDERING
// ============================================================================
export function renderParticle(
  ctx: CanvasRenderingContext2D,
  particle: Particle,
  canvasWidth: number,
  canvasHeight: number,
  dpr: number,
  cameraOffset?: Position,
  cameraZoom?: number
) {
  const screenPos = worldToScreen(
    particle.pos,
    canvasWidth,
    canvasHeight,
    dpr,
    cameraOffset,
    cameraZoom
  );
  const zoom = cameraZoom || 1;
  const lifeRatio = particle.life / particle.maxLife;
  const alpha = lifeRatio;
  const size = particle.size * zoom * lifeRatio;

  ctx.save();
  ctx.globalAlpha = alpha;

  if (
    particle.type === "glow" ||
    particle.type === "light" ||
    particle.type === "magic"
  ) {
    const glowGradient = ctx.createRadialGradient(
      screenPos.x,
      screenPos.y,
      0,
      screenPos.x,
      screenPos.y,
      size * 2
    );
    glowGradient.addColorStop(0, particle.color);
    glowGradient.addColorStop(1, "transparent");
    ctx.fillStyle = glowGradient;
    ctx.beginPath();
    ctx.arc(screenPos.x, screenPos.y, size * 2, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.fillStyle = particle.color;
  ctx.beginPath();
  ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

// ============================================================================
// TOWER PREVIEW
// ============================================================================
export function renderTowerPreview(
  ctx: CanvasRenderingContext2D,
  dragging: DraggingTower,
  canvasWidth: number,
  canvasHeight: number,
  dpr: number,
  towers: Tower[],
  selectedMap: string,
  gridWidth: number = 16,
  gridHeight: number = 10,
  cameraOffset?: Position,
  cameraZoom?: number,
  decorationPositions?: Set<string>
) {
  const zoom = cameraZoom || 1;
  const width = canvasWidth / dpr;
  const height = canvasHeight / dpr;
  const offset = cameraOffset || { x: 0, y: 0 };

  const isoX = (dragging.pos.x - width / 2) / zoom - offset.x;
  const isoY = (dragging.pos.y - height / 3) / zoom - offset.y;
  const worldX = isoX + isoY * 2;
  const worldY = isoY * 2 - isoX;
  const gridPos = {
    x: Math.floor(worldX / TILE_SIZE),
    y: Math.floor(worldY / TILE_SIZE),
  };

  const worldPos = gridToWorld(gridPos);
  const screenPos = worldToScreen(
    worldPos,
    canvasWidth,
    canvasHeight,
    dpr,
    cameraOffset,
    cameraZoom
  );

  // Check if position has a decoration
  const hasDecoration =
    decorationPositions?.has(`${gridPos.x},${gridPos.y}`) || false;

  const isValid =
    !hasDecoration &&
    isValidBuildPosition(
      gridPos,
      selectedMap,
      towers,
      gridWidth,
      gridHeight,
      40
    );

  // Base indicator
  ctx.fillStyle = isValid
    ? "rgba(100, 255, 100, 0.4)"
    : "rgba(255, 80, 80, 0.4)";
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    screenPos.y + 8 * zoom,
    32 * zoom,
    16 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.fill();

  ctx.strokeStyle = isValid
    ? "rgba(50, 200, 50, 0.8)"
    : "rgba(200, 50, 50, 0.8)";
  ctx.lineWidth = 2 * zoom;
  ctx.beginPath();
  ctx.ellipse(
    screenPos.x,
    screenPos.y + 8 * zoom,
    32 * zoom,
    16 * zoom,
    0,
    0,
    Math.PI * 2
  );
  ctx.stroke();

  ctx.save();
  ctx.globalAlpha = 0.75;

  const baseWidth = 34;
  const baseHeight = 28;
  const towerColors = TOWER_COLORS[dragging.type];

  const foundColors = {
    top: isValid ? darkenColor(towerColors.base, 30) : "#993333",
    left: isValid ? darkenColor(towerColors.base, 50) : "#882222",
    right: isValid ? darkenColor(towerColors.base, 40) : "#772222",
  };

  drawIsometricPrism(
    ctx,
    screenPos.x,
    screenPos.y + 8 * zoom,
    baseWidth + 8,
    baseWidth + 8,
    6,
    foundColors,
    zoom
  );

  const bodyColors = {
    top: isValid ? lightenColor(towerColors.light, 10) : "#ff6666",
    left: isValid ? towerColors.base : "#dd4444",
    right: isValid ? towerColors.dark : "#bb3333",
  };

  drawIsometricPrism(
    ctx,
    screenPos.x,
    screenPos.y,
    baseWidth,
    baseWidth,
    baseHeight,
    bodyColors,
    zoom
  );

  ctx.restore();

  // Range preview - show level 1 base range when placing
  const tData = TOWER_DATA[dragging.type];
  if (tData.range > 0) {
    ctx.strokeStyle = isValid
      ? "rgba(100, 200, 255, 0.6)"
      : "rgba(255, 100, 100, 0.6)";
    ctx.lineWidth = 2 * zoom;
    ctx.setLineDash([8, 6]);
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      screenPos.y,
      tData.range * zoom * 0.7,
      tData.range * zoom * 0.35,
      0,
      0,
      Math.PI * 2
    );
    ctx.stroke();
    ctx.setLineDash([]);
  }

  if (dragging.type === "station" && tData.spawnRange) {
    ctx.strokeStyle = isValid
      ? "rgba(255, 200, 100, 0.5)"
      : "rgba(255, 100, 100, 0.5)";
    ctx.lineWidth = 2 * zoom;
    ctx.setLineDash([6, 4]);
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      screenPos.y,
      tData.spawnRange * zoom * 0.7,
      tData.spawnRange * zoom * 0.35,
      0,
      0,
      Math.PI * 2
    );
    ctx.stroke();
    ctx.setLineDash([]);
  }
}

// Re-export environment effects
export { renderEnvironment, renderAmbientVisuals } from "./maps/environment";

// Re-export path rendering functions
export {
  renderPath,
  renderSecondaryPath,
  gridToWorldPath,
  generateSmoothPath,
  addPathWobble,
  createSeededRandom,
  catmullRom,
  hexToRgba,
  type PathRenderContext,
} from "./scene/path";

// Re-export fog effects
export { renderRoadEndFog } from "./effects/fog";

// Re-export hazards rendering
export { renderHazard } from "./hazards";
